<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æœ€ç»ˆå®æ—¶éŸ³é¢‘èŠå¤©</title>
    <script src="https://unpkg.com/openpgp@6.2.0/dist/openpgp.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }
        .container {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 20px;
            height: 80vh;
        }
        .panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }
        .messages {
            height: 400px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 15px;
            margin: 15px 0;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }
        .message {
            margin: 10px 0;
            padding: 12px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
        }
        .message.system {
            background: rgba(255, 193, 7, 0.3);
            font-style: italic;
        }
        .message.success {
            background: rgba(40, 167, 69, 0.3);
        }
        .message.error {
            background: rgba(220, 53, 69, 0.3);
        }
        button {
            padding: 12px 20px;
            margin: 8px 5px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }
        button:hover { 
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }
        button:disabled { 
            background: rgba(255, 255, 255, 0.1);
            cursor: not-allowed;
            transform: none;
        }
        button.recording { 
            background: #dc3545;
            animation: pulse 1.5s infinite;
        }
        button.connected {
            background: #28a745;
        }
        @keyframes pulse { 
            0%, 100% { opacity: 1; transform: scale(1); } 
            50% { opacity: 0.8; transform: scale(1.05); } 
        }
        input, textarea {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            backdrop-filter: blur(5px);
        }
        input::placeholder, textarea::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }
        .status {
            padding: 12px;
            margin: 12px 0;
            border-radius: 8px;
            background: rgba(40, 167, 69, 0.3);
            border: 1px solid rgba(40, 167, 69, 0.5);
        }
        .status.error { 
            background: rgba(220, 53, 69, 0.3);
            border-color: rgba(220, 53, 69, 0.5);
        }
        .status.warning { 
            background: rgba(255, 193, 7, 0.3);
            border-color: rgba(255, 193, 7, 0.5);
        }
        .audio-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(40, 167, 69, 0.9);
            color: white;
            padding: 12px 20px;
            border-radius: 25px;
            font-size: 14px;
            z-index: 1000;
            display: none;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        .audio-indicator.show { 
            display: flex;
            align-items: center;
            gap: 8px;
            animation: slideIn 0.3s ease;
        }
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        .smart-status {
            background: rgba(0, 123, 255, 0.3);
            border: 1px solid rgba(0, 123, 255, 0.5);
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 12px;
        }
        .user-item {
            padding: 10px;
            margin: 8px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .user-name {
            font-weight: bold;
            margin-bottom: 4px;
        }
        .user-id {
            font-size: 11px;
            opacity: 0.7;
            font-family: monospace;
        }
        h1, h2, h3 {
            margin-bottom: 15px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body>
    <h1>ğŸ¯ æœ€ç»ˆå®æ—¶éŸ³é¢‘èŠå¤©</h1>
    <p style="opacity: 0.8; margin-bottom: 20px;">åŸºäºæµ‹è¯•ç»“æœä¼˜åŒ–çš„æ™ºèƒ½éŸ³é¢‘æ’­æ”¾è§£å†³æ–¹æ¡ˆ</p>
    
    <div class="container">
        <div class="panel">
            <h3>ğŸ‘¥ ç”¨æˆ·ç®¡ç†</h3>
            <div class="status" id="connectionStatus">æœªè¿æ¥</div>
            <div id="userList"></div>
            
            <h3>ğŸ¤ æ™ºèƒ½éŸ³é¢‘</h3>
            <button id="generateKeys">ç”Ÿæˆå¯†é’¥</button>
            <button id="startLiveVoice">å¼€å§‹å®æ—¶è¯­éŸ³</button>
            
            <div class="smart-status" id="smartStatus">
                <div>ğŸ§  æ™ºèƒ½æ’­æ”¾çŠ¶æ€</div>
                <div>å¤´ä¿¡æ¯å—: æœªæ£€æµ‹</div>
                <div>æ’­æ”¾æˆåŠŸç‡: 0%</div>
                <div>å½“å‰ç­–ç•¥: åˆå§‹åŒ–</div>
            </div>
            
            <div>
                <label>æˆ¿é—´ID:</label>
                <input type="text" id="roomInput" placeholder="è¾“å…¥æˆ¿é—´IDæˆ–ç•™ç©ºè‡ªåŠ¨ç”Ÿæˆ">
                <button id="connectBtn">è¿æ¥æˆ¿é—´</button>
            </div>
        </div>
        
        <div class="panel">
            <h3>ğŸ’¬ æ¶ˆæ¯åŒºåŸŸ</h3>
            <div class="messages" id="messages"></div>
            <textarea id="messageInput" placeholder="è¾“å…¥æ¶ˆæ¯..." rows="3"></textarea>
            <button id="sendMessage">å‘é€æ¶ˆæ¯</button>
        </div>
    </div>
    
    <div class="audio-indicator" id="audioIndicator">
        <div style="width: 8px; height: 8px; background: #fff; border-radius: 50%; animation: pulse 1s infinite;"></div>
        ğŸ”Š æ¥æ”¶éŸ³é¢‘
    </div>

    <script>
        // å…¨å±€å˜é‡
        let websocket = null;
        let privateKey = null;
        let publicKey = null;
        let userId = '';
        let userName = '';
        let roomId = '';
        let users = new Map();
        
        // éŸ³é¢‘ç›¸å…³
        let mediaRecorder = null;
        let audioStream = null;
        let isRecording = false;
        
        // æ™ºèƒ½éŸ³é¢‘æ’­æ”¾
        let userAudioBuffers = new Map();
        let headerChunks = new Map(); // å­˜å‚¨æ¯ä¸ªç”¨æˆ·çš„å¤´ä¿¡æ¯å—
        let playbackStats = new Map(); // æ’­æ”¾ç»Ÿè®¡
        
        // DOMå…ƒç´ 
        const connectionStatusEl = document.getElementById('connectionStatus');
        const userListEl = document.getElementById('userList');
        const messagesEl = document.getElementById('messages');
        const messageInputEl = document.getElementById('messageInput');
        const roomInputEl = document.getElementById('roomInput');
        const connectBtnEl = document.getElementById('connectBtn');
        const generateKeysBtn = document.getElementById('generateKeys');
        const startLiveVoiceBtn = document.getElementById('startLiveVoice');
        const sendMessageBtn = document.getElementById('sendMessage');
        const audioIndicatorEl = document.getElementById('audioIndicator');
        const smartStatusEl = document.getElementById('smartStatus');
        
        // æ·»åŠ æ¶ˆæ¯åˆ°ç•Œé¢
        function addMessage(content, type = 'normal') {
            const messageEl = document.createElement('div');
            messageEl.className = `message ${type}`;
            messageEl.innerHTML = `<div style="font-size: 11px; opacity: 0.7; margin-bottom: 5px;">[${new Date().toLocaleTimeString()}]</div>${content}`;
            messagesEl.appendChild(messageEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }
        
        // æ›´æ–°è¿æ¥çŠ¶æ€
        function updateConnectionStatus(status, type = 'normal') {
            connectionStatusEl.textContent = status;
            connectionStatusEl.className = `status ${type}`;
        }
        
        // æ›´æ–°æ™ºèƒ½æ’­æ”¾çŠ¶æ€
        function updateSmartStatus(userId) {
            const stats = playbackStats.get(userId) || { success: 0, total: 0 };
            const hasHeader = headerChunks.has(userId);
            const successRate = stats.total > 0 ? ((stats.success / stats.total) * 100).toFixed(1) : 0;
            
            let strategy = 'åˆå§‹åŒ–';
            if (hasHeader) {
                strategy = 'å¤´ä¿¡æ¯åˆå¹¶';
            } else if (stats.total > 0) {
                strategy = 'ç¼“å†²åˆå¹¶';
            }
            
            smartStatusEl.innerHTML = `
                <div>ğŸ§  æ™ºèƒ½æ’­æ”¾çŠ¶æ€</div>
                <div>å¤´ä¿¡æ¯å—: ${hasHeader ? 'å·²æ£€æµ‹' : 'æœªæ£€æµ‹'}</div>
                <div>æ’­æ”¾æˆåŠŸç‡: ${successRate}%</div>
                <div>å½“å‰ç­–ç•¥: ${strategy}</div>
            `;
        }
        
        // ç”Ÿæˆå¯†é’¥å¯¹
        async function generateKeys() {
            try {
                addMessage('æ­£åœ¨ç”Ÿæˆå¯†é’¥å¯¹...', 'system');
                
                const { privateKey: privKey, publicKey: pubKey } = await openpgp.generateKey({
                    type: 'ecc',
                    curve: 'curve25519',
                    userIDs: [{ name: `User_${Date.now()}`, email: `user${Date.now()}@example.com` }],
                    passphrase: '',
                    format: 'armored'
                });
                
                privateKey = privKey;
                publicKey = pubKey;
                
                const key = await openpgp.readKey({ armoredKey: publicKey });
                const primaryUser = await key.getPrimaryUser();
                userId = key.getFingerprint().toUpperCase();
                userName = primaryUser.user.userID?.name || `User_${userId.slice(-8)}`;
                
                addMessage(`å¯†é’¥ç”ŸæˆæˆåŠŸï¼Œç”¨æˆ·: ${userName}`, 'success');
                generateKeysBtn.textContent = 'âœ… å¯†é’¥å·²ç”Ÿæˆ';
                generateKeysBtn.disabled = true;
                
            } catch (error) {
                addMessage(`å¯†é’¥ç”Ÿæˆå¤±è´¥: ${error.message}`, 'error');
            }
        }
        
        // è¿æ¥åˆ°æˆ¿é—´
        async function connectToRoom() {
            if (!privateKey || !publicKey) {
                addMessage('è¯·å…ˆç”Ÿæˆå¯†é’¥', 'error');
                return;
            }
            
            try {
                roomId = roomInputEl.value.trim();
                if (!roomId) {
                    const response = await fetch('/api/room', { method: 'POST' });
                    roomId = await response.text();
                    roomInputEl.value = roomId;
                }
                
                const wsUrl = `${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.host}/api/room/${roomId}/websocket`;
                websocket = new WebSocket(wsUrl);
                
                websocket.onopen = () => {
                    updateConnectionStatus('å·²è¿æ¥', 'normal');
                    addMessage('WebSocketè¿æ¥æˆåŠŸ', 'success');
                    
                    websocket.send(JSON.stringify({
                        type: 'register',
                        publicKey: publicKey
                    }));
                };
                
                websocket.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        handleMessage(message);
                    } catch (error) {
                        addMessage(`æ¶ˆæ¯è§£æé”™è¯¯: ${error.message}`, 'error');
                    }
                };
                
                websocket.onclose = () => {
                    updateConnectionStatus('è¿æ¥æ–­å¼€', 'error');
                    addMessage('WebSocketè¿æ¥æ–­å¼€', 'error');
                };
                
                connectBtnEl.textContent = 'è¿æ¥ä¸­...';
                connectBtnEl.disabled = true;
                
            } catch (error) {
                addMessage(`è¿æ¥å¤±è´¥: ${error.message}`, 'error');
                updateConnectionStatus('è¿æ¥å¤±è´¥', 'error');
            }
        }
        
        // å¤„ç†æ¥æ”¶åˆ°çš„æ¶ˆæ¯
        async function handleMessage(message) {
            switch (message.type) {
                case 'registered':
                    addMessage(`æ³¨å†ŒæˆåŠŸ: ${message.profile.name}`, 'success');
                    connectBtnEl.textContent = 'âœ… å·²è¿æ¥';
                    connectBtnEl.classList.add('connected');
                    break;
                    
                case 'userList':
                    updateUserList(message.users);
                    break;
                    
                case 'liveAudioNotification':
                    await handleSmartLiveAudio(message);
                    break;
                    
                case 'encryptedMessage':
                    await handleEncryptedMessage(message);
                    break;
                    
                case 'error':
                    addMessage(`é”™è¯¯: ${message.message}`, 'error');
                    break;
            }
        }
        
        // æ›´æ–°ç”¨æˆ·åˆ—è¡¨
        function updateUserList(userList) {
            users.clear();
            userListEl.innerHTML = '';
            
            userList.forEach(user => {
                users.set(user.id, user);
                const userEl = document.createElement('div');
                userEl.className = 'user-item';
                userEl.innerHTML = `
                    <div class="user-name">${user.name}</div>
                    <div class="user-id">${user.id.slice(-12)}</div>
                `;
                if (user.id === userId) {
                    userEl.style.background = 'rgba(0, 123, 255, 0.3)';
                }
                userListEl.appendChild(userEl);
            });
            
            addMessage(`åœ¨çº¿ç”¨æˆ·: ${userList.length}`, 'system');
        }
        
        // æ™ºèƒ½å®æ—¶éŸ³é¢‘å¤„ç†
        async function handleSmartLiveAudio(message) {
            if (!privateKey) return;
            
            try {
                const decryptedMessage = await openpgp.decrypt({
                    message: await openpgp.readMessage({ armoredMessage: message.encryptedAudioData }),
                    decryptionKeys: await openpgp.readPrivateKey({ armoredKey: privateKey })
                });
                
                const audioData = new Uint8Array(decryptedMessage.data);
                console.log(`æ¥æ”¶éŸ³é¢‘: ${audioData.length} å­—èŠ‚ from ${message.senderId}`);
                
                // æ™ºèƒ½æ’­æ”¾å¤„ç†
                await smartAudioPlayback(message.senderId, audioData);
                showAudioIndicator();
                
            } catch (error) {
                console.error('å¤„ç†å®æ—¶éŸ³é¢‘å¤±è´¥:', error);
                showAudioIndicator();
            }
        }
        
        // æ™ºèƒ½éŸ³é¢‘æ’­æ”¾æ ¸å¿ƒé€»è¾‘
        async function smartAudioPlayback(senderId, audioData) {
            // åˆå§‹åŒ–ç”¨æˆ·æ•°æ®
            if (!userAudioBuffers.has(senderId)) {
                userAudioBuffers.set(senderId, {
                    chunks: [],
                    totalSize: 0,
                    lastUpdate: Date.now(),
                    isProcessing: false
                });
                playbackStats.set(senderId, { success: 0, total: 0 });
            }
            
            const buffer = userAudioBuffers.get(senderId);
            const stats = playbackStats.get(senderId);
            
            buffer.chunks.push(audioData);
            buffer.totalSize += audioData.length;
            buffer.lastUpdate = Date.now();
            stats.total++;
            
            console.log(`ç¼“å†²éŸ³é¢‘ [${senderId.slice(-8)}]: ${audioData.length} å­—èŠ‚ï¼Œæ€»è®¡: ${buffer.totalSize} å­—èŠ‚`);
            
            // å¦‚æœä¸åœ¨å¤„ç†ä¸­ï¼Œå¼€å§‹æ™ºèƒ½æ’­æ”¾
            if (!buffer.isProcessing) {
                buffer.isProcessing = true;
                await processSmartAudioBuffer(senderId);
            }
        }
        
        // å¤„ç†æ™ºèƒ½éŸ³é¢‘ç¼“å†²åŒº
        async function processSmartAudioBuffer(senderId) {
            const buffer = userAudioBuffers.get(senderId);
            const stats = playbackStats.get(senderId);
            
            if (!buffer || buffer.chunks.length === 0) {
                if (buffer) buffer.isProcessing = false;
                return;
            }
            
            try {
                let playSuccess = false;
                
                // ç­–ç•¥1: å¦‚æœæœ‰å¤´ä¿¡æ¯å—ï¼Œä¸å¤´ä¿¡æ¯å—åˆå¹¶æ’­æ”¾
                if (headerChunks.has(senderId) && buffer.chunks.length > 0) {
                    const headerChunk = headerChunks.get(senderId);
                    const currentChunk = buffer.chunks.shift();
                    buffer.totalSize -= currentChunk.length;
                    
                    const mergedAudio = new Uint8Array(headerChunk.length + currentChunk.length);
                    mergedAudio.set(headerChunk, 0);
                    mergedAudio.set(currentChunk, headerChunk.length);
                    
                    if (await tryPlayAudio(mergedAudio)) {
                        console.log(`æ™ºèƒ½æ’­æ”¾æˆåŠŸ [${senderId.slice(-8)}]: å¤´ä¿¡æ¯åˆå¹¶`);
                        stats.success++;
                        playSuccess = true;
                    }
                }
                
                // ç­–ç•¥2: æµ‹è¯•ç¬¬ä¸€ä¸ªå—æ˜¯å¦åŒ…å«å¤´ä¿¡æ¯
                if (!playSuccess && !headerChunks.has(senderId) && buffer.chunks.length > 0) {
                    const firstChunk = buffer.chunks[0];
                    
                    if (await tryPlayAudio(firstChunk)) {
                        console.log(`å‘ç°å¤´ä¿¡æ¯å— [${senderId.slice(-8)}]: ${firstChunk.length} å­—èŠ‚`);
                        headerChunks.set(senderId, firstChunk);
                        buffer.chunks.shift();
                        buffer.totalSize -= firstChunk.length;
                        stats.success++;
                        playSuccess = true;
                    }
                }
                
                // ç­–ç•¥3: ç¼“å†²åˆå¹¶æ’­æ”¾
                if (!playSuccess && buffer.chunks.length >= 2) {
                    const chunksToMerge = buffer.chunks.splice(0, 2);
                    const mergedSize = chunksToMerge.reduce((sum, chunk) => sum + chunk.length, 0);
                    buffer.totalSize -= mergedSize;
                    
                    const mergedAudio = new Uint8Array(mergedSize);
                    let offset = 0;
                    for (const chunk of chunksToMerge) {
                        mergedAudio.set(chunk, offset);
                        offset += chunk.length;
                    }
                    
                    if (await tryPlayAudio(mergedAudio)) {
                        console.log(`æ™ºèƒ½æ’­æ”¾æˆåŠŸ [${senderId.slice(-8)}]: ç¼“å†²åˆå¹¶`);
                        stats.success++;
                        playSuccess = true;
                    }
                }
                
                // ç­–ç•¥4: å•å—æ’­æ”¾ï¼ˆæœ€åå°è¯•ï¼‰
                if (!playSuccess && buffer.chunks.length > 0) {
                    const singleChunk = buffer.chunks.shift();
                    buffer.totalSize -= singleChunk.length;
                    
                    if (await tryPlayAudio(singleChunk)) {
                        console.log(`æ™ºèƒ½æ’­æ”¾æˆåŠŸ [${senderId.slice(-8)}]: å•å—æ’­æ”¾`);
                        stats.success++;
                        playSuccess = true;
                    }
                }
                
                if (!playSuccess) {
                    console.log(`æ™ºèƒ½æ’­æ”¾å¤±è´¥ [${senderId.slice(-8)}]`);
                }
                
                // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
                updateSmartStatus(senderId);
                
                // ç»§ç»­å¤„ç†å‰©ä½™æ•°æ®
                if (buffer.chunks.length > 0) {
                    setTimeout(() => processSmartAudioBuffer(senderId), 50);
                } else {
                    buffer.isProcessing = false;
                }
                
            } catch (error) {
                console.error('æ™ºèƒ½éŸ³é¢‘å¤„ç†å¤±è´¥:', error);
                buffer.isProcessing = false;
            }
        }
        
        // å°è¯•æ’­æ”¾éŸ³é¢‘
        async function tryPlayAudio(audioData) {
            // æ–¹æ³•1: ç›´æ¥æ’­æ”¾
            if (await tryDirectPlay(audioData)) {
                return true;
            }
            
            // æ–¹æ³•2: Web Audio API
            if (await tryWebAudioPlay(audioData)) {
                return true;
            }
            
            return false;
        }
        
        // ç›´æ¥æ’­æ”¾
        async function tryDirectPlay(audioData) {
            try {
                const audioBlob = new Blob([audioData], { type: 'audio/webm;codecs=opus' });
                const audioUrl = URL.createObjectURL(audioBlob);
                const audio = new Audio();
                
                audio.src = audioUrl;
                audio.volume = 0.7;
                
                return new Promise((resolve) => {
                    let resolved = false;
                    
                    const cleanup = () => {
                        if (!resolved) {
                            resolved = true;
                            URL.revokeObjectURL(audioUrl);
                        }
                    };
                    
                    audio.oncanplaythrough = () => {
                        audio.play().then(() => {
                            cleanup();
                            resolve(true);
                        }).catch(() => {
                            cleanup();
                            resolve(false);
                        });
                    };
                    
                    audio.onerror = () => {
                        cleanup();
                        resolve(false);
                    };
                    
                    setTimeout(() => {
                        cleanup();
                        resolve(false);
                    }, 500);
                });
                
            } catch (error) {
                return false;
            }
        }
        
        // Web Audio API æ’­æ”¾
        async function tryWebAudioPlay(audioData) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const audioBuffer = await audioContext.decodeAudioData(audioData.buffer.slice());
                
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                const gainNode = audioContext.createGain();
                gainNode.gain.value = 0.7;
                
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);
                source.start(0);
                
                return true;
            } catch (error) {
                return false;
            }
        }
        
        // æ˜¾ç¤ºéŸ³é¢‘æŒ‡ç¤ºå™¨
        function showAudioIndicator() {
            audioIndicatorEl.classList.add('show');
            setTimeout(() => {
                audioIndicatorEl.classList.remove('show');
            }, 1500);
        }
        
        // å¼€å§‹/åœæ­¢å®æ—¶è¯­éŸ³
        async function toggleLiveVoice() {
            if (!isRecording) {
                await startLiveVoice();
            } else {
                stopLiveVoice();
            }
        }
        
        // å¼€å§‹å®æ—¶è¯­éŸ³
        async function startLiveVoice() {
            try {
                audioStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: 16000
                    }
                });
                
                mediaRecorder = new MediaRecorder(audioStream, {
                    mimeType: 'audio/webm;codecs=opus',
                    audioBitsPerSecond: 32000
                });
                
                mediaRecorder.ondataavailable = async (event) => {
                    if (event.data.size > 0 && websocket && websocket.readyState === WebSocket.OPEN) {
                        await sendAudioChunk(event.data);
                    }
                };
                
                mediaRecorder.start(200);
                isRecording = true;
                
                startLiveVoiceBtn.textContent = 'ğŸ”´ åœæ­¢è¯­éŸ³';
                startLiveVoiceBtn.classList.add('recording');
                addMessage('ğŸ¤ å®æ—¶è¯­éŸ³å·²å¼€å¯', 'success');
                
            } catch (error) {
                addMessage(`å¯åŠ¨å®æ—¶è¯­éŸ³å¤±è´¥: ${error.message}`, 'error');
            }
        }
        
        // åœæ­¢å®æ—¶è¯­éŸ³
        function stopLiveVoice() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            
            if (audioStream) {
                audioStream.getTracks().forEach(track => track.stop());
                audioStream = null;
            }
            
            isRecording = false;
            startLiveVoiceBtn.textContent = 'ğŸ¤ å¼€å§‹å®æ—¶è¯­éŸ³';
            startLiveVoiceBtn.classList.remove('recording');
            addMessage('å®æ—¶è¯­éŸ³å·²åœæ­¢', 'system');
        }
        
        // å‘é€éŸ³é¢‘å—
        async function sendAudioChunk(audioBlob) {
            try {
                const arrayBuffer = await audioBlob.arrayBuffer();
                const audioData = new Uint8Array(arrayBuffer);
                
                const encryptedData = await encryptForAllUsers(audioData);
                
                const message = {
                    type: 'liveAudio',
                    encryptedAudioData: encryptedData,
                    timestamp: Date.now()
                };
                
                websocket.send(JSON.stringify(message));
                
            } catch (error) {
                console.error('å‘é€éŸ³é¢‘å¤±è´¥:', error);
            }
        }
        
        // ä¸ºæ‰€æœ‰ç”¨æˆ·åŠ å¯†æ•°æ®
        async function encryptForAllUsers(data) {
            const publicKeys = Array.from(users.values()).map(user => user.publicKey);
            
            if (publicKeys.length === 0) {
                return '';
            }
            
            const keys = await Promise.all(
                publicKeys.map(key => openpgp.readKey({ armoredKey: key }))
            );
            
            const encrypted = await openpgp.encrypt({
                message: await openpgp.createMessage({ binary: data }),
                encryptionKeys: keys,
                format: 'armored'
            });
            
            return encrypted;
        }
        
        // å¤„ç†åŠ å¯†æ¶ˆæ¯
        async function handleEncryptedMessage(message) {
            try {
                const decryptedMessage = await openpgp.decrypt({
                    message: await openpgp.readMessage({ armoredMessage: message.encryptedData }),
                    decryptionKeys: await openpgp.readPrivateKey({ armoredKey: privateKey })
                });
                
                const senderName = users.get(message.senderId)?.name || message.senderId.slice(-8);
                addMessage(`${senderName}: ${decryptedMessage.data}`);
                
            } catch (error) {
                addMessage(`è§£å¯†æ¶ˆæ¯å¤±è´¥: ${error.message}`, 'error');
            }
        }
        
        // å‘é€æ–‡æœ¬æ¶ˆæ¯
        async function sendTextMessage() {
            const text = messageInputEl.value.trim();
            if (!text || !websocket || websocket.readyState !== WebSocket.OPEN) {
                return;
            }
            
            try {
                const encryptedData = await encryptForAllUsers(new TextEncoder().encode(text));
                
                const message = {
                    type: 'message',
                    encryptedData: encryptedData
                };
                
                websocket.send(JSON.stringify(message));
                messageInputEl.value = '';
                addMessage(`æˆ‘: ${text}`);
                
            } catch (error) {
                addMessage(`å‘é€æ¶ˆæ¯å¤±è´¥: ${error.message}`, 'error');
            }
        }
        
        // äº‹ä»¶ç›‘å¬å™¨
        generateKeysBtn.addEventListener('click', generateKeys);
        connectBtnEl.addEventListener('click', connectToRoom);
        startLiveVoiceBtn.addEventListener('click', toggleLiveVoice);
        sendMessageBtn.addEventListener('click', sendTextMessage);
        
        messageInputEl.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendTextMessage();
            }
        });
        
        // åˆå§‹åŒ–
        addMessage('ğŸ¯ æœ€ç»ˆå®æ—¶éŸ³é¢‘èŠå¤©å·²åŠ è½½', 'success');
        addMessage('âœ¨ é›†æˆæ™ºèƒ½éŸ³é¢‘æ’­æ”¾ç­–ç•¥', 'system');
        addMessage('è¯·å…ˆç”Ÿæˆå¯†é’¥ï¼Œç„¶åè¿æ¥åˆ°æˆ¿é—´', 'system');
        updateSmartStatus('default');
    </script>
</body>
</html>