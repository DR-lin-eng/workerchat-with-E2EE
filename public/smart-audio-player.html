<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ™ºèƒ½éŸ³é¢‘æ’­æ”¾å™¨</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 1000px; margin: 0 auto; padding: 20px; }
        .container { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .panel { background: #f8f9fa; padding: 20px; border-radius: 8px; border: 1px solid #dee2e6; }
        .log { background: #fff; border: 1px solid #ddd; padding: 10px; height: 300px; overflow-y: auto; font-family: monospace; font-size: 12px; margin: 10px 0; }
        button { padding: 8px 16px; margin: 5px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; }
        button:hover { background: #0056b3; }
        button:disabled { background: #6c757d; cursor: not-allowed; }
        button.recording { background: #dc3545; animation: pulse 1s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .stats { background: #e9ecef; padding: 10px; border-radius: 4px; margin: 10px 0; }
        .success { color: #28a745; }
        .error { color: #dc3545; }
        .warning { color: #ffc107; }
        .strategy { background: #d1ecf1; padding: 10px; margin: 10px 0; border-radius: 4px; }
    </style>
</head>
<body>
    <h1>ğŸ§  æ™ºèƒ½éŸ³é¢‘æ’­æ”¾å™¨</h1>
    <p>åŸºäºæµ‹è¯•ç»“æœçš„æ™ºèƒ½éŸ³é¢‘æµæ’­æ”¾è§£å†³æ–¹æ¡ˆ</p>
    
    <div class="container">
        <div class="panel">
            <h3>ğŸ¤ å½•åˆ¶ä¸æ’­æ”¾</h3>
            <button id="startRecord">å¼€å§‹å½•åˆ¶</button>
            <button id="stopRecord" disabled>åœæ­¢å½•åˆ¶</button>
            <button id="testSmart">æµ‹è¯•æ™ºèƒ½æ’­æ”¾</button>
            <button id="clearAll">æ¸…ç©ºæ‰€æœ‰</button>
            
            <div class="stats" id="stats">
                <div>å½•åˆ¶çŠ¶æ€: æœªå¼€å§‹</div>
                <div>éŸ³é¢‘å—æ•°: 0</div>
                <div>æ™ºèƒ½æ’­æ”¾æˆåŠŸ: 0</div>
                <div>æ’­æ”¾å¤±è´¥: 0</div>
            </div>
            
            <div class="strategy">
                <h4>ğŸ¯ æ™ºèƒ½æ’­æ”¾ç­–ç•¥</h4>
                <div>âœ… ä¼˜å…ˆæ’­æ”¾åŒ…å«å¤´ä¿¡æ¯çš„å—</div>
                <div>âœ… æ™ºèƒ½åˆå¹¶ç›¸é‚»éŸ³é¢‘å—</div>
                <div>âœ… åŠ¨æ€è°ƒæ•´åˆå¹¶ç­–ç•¥</div>
                <div>âœ… ç¼“å­˜æˆåŠŸçš„æ’­æ”¾æ¨¡å¼</div>
            </div>
        </div>
        
        <div class="panel">
            <h3>ğŸ“Š æ’­æ”¾åˆ†æ</h3>
            <div class="log" id="analysisLog"></div>
        </div>
    </div>
    
    <div class="panel">
        <h3>ğŸ“ è¯¦ç»†æ—¥å¿—</h3>
        <button onclick="clearLog()">æ¸…ç©ºæ—¥å¿—</button>
        <div class="log" id="debugLog"></div>
    </div>

    <script>
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;
        let smartPlaySuccessCount = 0;
        let playFailCount = 0;
        let headerChunkIndex = -1; // è®°å½•åŒ…å«å¤´ä¿¡æ¯çš„å—ç´¢å¼•
        let successfulPatterns = []; // è®°å½•æˆåŠŸçš„æ’­æ”¾æ¨¡å¼
        
        const startRecordBtn = document.getElementById('startRecord');
        const stopRecordBtn = document.getElementById('stopRecord');
        const testSmartBtn = document.getElementById('testSmart');
        const clearAllBtn = document.getElementById('clearAll');
        const statsEl = document.getElementById('stats');
        const debugLogEl = document.getElementById('debugLog');
        const analysisLogEl = document.getElementById('analysisLog');
        
        // æ—¥å¿—å‡½æ•°
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.innerHTML = `<span style="color: #666;">[${timestamp}]</span> <span class="${type}">${message}</span>`;
            debugLogEl.appendChild(logEntry);
            debugLogEl.scrollTop = debugLogEl.scrollHeight;
            console.log(message);
        }
        
        function analysisLog(message, type = 'info') {
            const logEntry = document.createElement('div');
            logEntry.innerHTML = `<span class="${type}">${message}</span>`;
            analysisLogEl.appendChild(logEntry);
            analysisLogEl.scrollTop = analysisLogEl.scrollHeight;
        }
        
        function clearLog() {
            debugLogEl.innerHTML = '';
            analysisLogEl.innerHTML = '';
        }
        
        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        function updateStats() {
            statsEl.innerHTML = `
                <div>å½•åˆ¶çŠ¶æ€: ${isRecording ? 'å½•åˆ¶ä¸­' : 'å·²åœæ­¢'}</div>
                <div>éŸ³é¢‘å—æ•°: ${audioChunks.length}</div>
                <div>æ™ºèƒ½æ’­æ”¾æˆåŠŸ: <span class="success">${smartPlaySuccessCount}</span></div>
                <div>æ’­æ”¾å¤±è´¥: <span class="error">${playFailCount}</span></div>
            `;
        }
        
        // å¼€å§‹å½•åˆ¶
        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: 16000
                    }
                });
                
                const supportedFormat = 'audio/webm;codecs=opus';
                
                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: supportedFormat,
                    audioBitsPerSecond: 32000
                });
                
                audioChunks = [];
                smartPlaySuccessCount = 0;
                playFailCount = 0;
                headerChunkIndex = -1;
                successfulPatterns = [];
                
                mediaRecorder.ondataavailable = async (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                        const index = audioChunks.length - 1;
                        
                        log(`å½•åˆ¶éŸ³é¢‘å— ${index + 1}: ${event.data.size} å­—èŠ‚`);
                        
                        // æ™ºèƒ½æ’­æ”¾æµ‹è¯•
                        await smartPlayTest(event.data, index);
                        
                        updateStats();
                    }
                };
                
                mediaRecorder.start(200);
                isRecording = true;
                
                startRecordBtn.disabled = true;
                stopRecordBtn.disabled = false;
                
                log('å¼€å§‹æ™ºèƒ½å½•åˆ¶æµ‹è¯•', 'success');
                analysisLog('ğŸ§  æ™ºèƒ½æ’­æ”¾åˆ†æå¼€å§‹', 'success');
                
            } catch (error) {
                log(`å½•åˆ¶å¤±è´¥: ${error.message}`, 'error');
            }
        }
        
        // åœæ­¢å½•åˆ¶
        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
            }
            
            isRecording = false;
            startRecordBtn.disabled = false;
            stopRecordBtn.disabled = true;
            
            log('åœæ­¢å½•åˆ¶', 'warning');
            analysisLog('ğŸ“Š å½•åˆ¶å®Œæˆï¼Œå¼€å§‹åˆ†æç»“æœ', 'warning');
            analyzeResults();
        }
        
        // æ™ºèƒ½æ’­æ”¾æµ‹è¯•
        async function smartPlayTest(audioBlob, index) {
            // ç­–ç•¥1: æµ‹è¯•å•ç‹¬æ’­æ”¾ï¼ˆæ£€æµ‹æ˜¯å¦åŒ…å«å¤´ä¿¡æ¯ï¼‰
            if (await testSinglePlay(audioBlob)) {
                log(`å— ${index + 1} å•ç‹¬æ’­æ”¾æˆåŠŸ - å¯èƒ½åŒ…å«å¤´ä¿¡æ¯`, 'success');
                analysisLog(`âœ… å— ${index + 1}: åŒ…å«å¤´ä¿¡æ¯ï¼Œå¯ç‹¬ç«‹æ’­æ”¾`, 'success');
                headerChunkIndex = index;
                smartPlaySuccessCount++;
                return;
            }
            
            // ç­–ç•¥2: å¦‚æœæœ‰å¤´ä¿¡æ¯å—ï¼Œå°è¯•ä¸å¤´ä¿¡æ¯å—åˆå¹¶
            if (headerChunkIndex >= 0 && index > headerChunkIndex) {
                const headerChunk = audioChunks[headerChunkIndex];
                const mergedBlob = new Blob([headerChunk, audioBlob], { type: audioBlob.type });
                
                if (await testSinglePlay(mergedBlob)) {
                    log(`å— ${index + 1} ä¸å¤´ä¿¡æ¯å—åˆå¹¶æ’­æ”¾æˆåŠŸ`, 'success');
                    analysisLog(`âœ… å— ${index + 1}: ä¸å¤´ä¿¡æ¯å—åˆå¹¶æˆåŠŸ`, 'success');
                    successfulPatterns.push({ type: 'header_merge', headerIndex: headerChunkIndex, dataIndex: index });
                    smartPlaySuccessCount++;
                    return;
                }
            }
            
            // ç­–ç•¥3: ä¸å‰ä¸€ä¸ªå—åˆå¹¶
            if (index > 0) {
                const prevChunk = audioChunks[index - 1];
                const mergedBlob = new Blob([prevChunk, audioBlob], { type: audioBlob.type });
                
                if (await testSinglePlay(mergedBlob)) {
                    log(`å— ${index + 1} ä¸å‰ä¸€å—åˆå¹¶æ’­æ”¾æˆåŠŸ`, 'success');
                    analysisLog(`âœ… å— ${index + 1}: ä¸å‰ä¸€å—åˆå¹¶æˆåŠŸ`, 'success');
                    successfulPatterns.push({ type: 'sequential_merge', index1: index - 1, index2: index });
                    smartPlaySuccessCount++;
                    return;
                }
            }
            
            // ç­–ç•¥4: ä¸å¤šä¸ªå‰é¢çš„å—åˆå¹¶
            if (index >= 2) {
                const chunks = audioChunks.slice(Math.max(0, index - 2), index + 1);
                const mergedBlob = new Blob(chunks, { type: audioBlob.type });
                
                if (await testSinglePlay(mergedBlob)) {
                    log(`å— ${index + 1} å¤šå—åˆå¹¶æ’­æ”¾æˆåŠŸ`, 'success');
                    analysisLog(`âœ… å— ${index + 1}: å¤šå—åˆå¹¶æˆåŠŸ`, 'success');
                    successfulPatterns.push({ type: 'multi_merge', startIndex: Math.max(0, index - 2), endIndex: index });
                    smartPlaySuccessCount++;
                    return;
                }
            }
            
            // æ‰€æœ‰ç­–ç•¥éƒ½å¤±è´¥
            log(`å— ${index + 1} æ‰€æœ‰æ™ºèƒ½æ’­æ”¾ç­–ç•¥éƒ½å¤±è´¥`, 'error');
            analysisLog(`âŒ å— ${index + 1}: æ— æ³•æ’­æ”¾`, 'error');
            playFailCount++;
        }
        
        // æµ‹è¯•å•ç‹¬æ’­æ”¾
        async function testSinglePlay(audioBlob) {
            try {
                // ä¼˜å…ˆä½¿ç”¨ç›´æ¥æ’­æ”¾ï¼ˆæ›´å¿«ï¼‰
                if (await tryDirectPlay(audioBlob)) {
                    return true;
                }
                
                // å¤‡ç”¨Web Audio API
                if (await tryWebAudioPlay(audioBlob)) {
                    return true;
                }
                
                return false;
            } catch (error) {
                return false;
            }
        }
        
        // ç›´æ¥æ’­æ”¾æµ‹è¯•
        async function tryDirectPlay(audioBlob) {
            try {
                const audioUrl = URL.createObjectURL(audioBlob);
                const audio = new Audio();
                audio.src = audioUrl;
                audio.volume = 0.1; // ä½éŸ³é‡æµ‹è¯•
                
                return new Promise((resolve) => {
                    let resolved = false;
                    
                    const cleanup = () => {
                        if (!resolved) {
                            resolved = true;
                            URL.revokeObjectURL(audioUrl);
                        }
                    };
                    
                    audio.oncanplaythrough = () => {
                        audio.play().then(() => {
                            cleanup();
                            resolve(true);
                        }).catch(() => {
                            cleanup();
                            resolve(false);
                        });
                    };
                    
                    audio.onerror = () => {
                        cleanup();
                        resolve(false);
                    };
                    
                    // å¿«é€Ÿè¶…æ—¶
                    setTimeout(() => {
                        cleanup();
                        resolve(false);
                    }, 300);
                });
                
            } catch (error) {
                return false;
            }
        }
        
        // Web Audio API æµ‹è¯•
        async function tryWebAudioPlay(audioBlob) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const arrayBuffer = await audioBlob.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                const gainNode = audioContext.createGain();
                gainNode.gain.value = 0.1; // ä½éŸ³é‡
                
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);
                source.start(0);
                
                return true;
            } catch (error) {
                return false;
            }
        }
        
        // åˆ†æç»“æœ
        function analyzeResults() {
            analysisLog('', '');
            analysisLog('ğŸ“ˆ æ™ºèƒ½æ’­æ”¾åˆ†æç»“æœ:', 'warning');
            analysisLog(`æ€»éŸ³é¢‘å—æ•°: ${audioChunks.length}`, 'info');
            analysisLog(`æˆåŠŸæ’­æ”¾: ${smartPlaySuccessCount}`, 'success');
            analysisLog(`æ’­æ”¾å¤±è´¥: ${playFailCount}`, 'error');
            analysisLog(`æˆåŠŸç‡: ${((smartPlaySuccessCount / audioChunks.length) * 100).toFixed(1)}%`, 'info');
            
            if (headerChunkIndex >= 0) {
                analysisLog(`ğŸ¯ å‘ç°å¤´ä¿¡æ¯å—: ç¬¬ ${headerChunkIndex + 1} å—`, 'success');
            } else {
                analysisLog(`âš ï¸ æœªå‘ç°ç‹¬ç«‹å¯æ’­æ”¾çš„å¤´ä¿¡æ¯å—`, 'warning');
            }
            
            analysisLog('', '');
            analysisLog('ğŸ” æˆåŠŸæ’­æ”¾æ¨¡å¼åˆ†æ:', 'info');
            const patternCounts = {};
            successfulPatterns.forEach(pattern => {
                patternCounts[pattern.type] = (patternCounts[pattern.type] || 0) + 1;
            });
            
            Object.entries(patternCounts).forEach(([type, count]) => {
                const typeNames = {
                    'header_merge': 'ä¸å¤´ä¿¡æ¯å—åˆå¹¶',
                    'sequential_merge': 'ä¸å‰ä¸€å—åˆå¹¶',
                    'multi_merge': 'å¤šå—åˆå¹¶'
                };
                analysisLog(`${typeNames[type] || type}: ${count} æ¬¡`, 'success');
            });
            
            // æ¨èç­–ç•¥
            analysisLog('', '');
            analysisLog('ğŸ’¡ æ¨èçš„å®æ—¶æ’­æ”¾ç­–ç•¥:', 'warning');
            if (headerChunkIndex >= 0) {
                analysisLog('1. ç¼“å­˜ç¬¬ä¸€ä¸ªæˆåŠŸæ’­æ”¾çš„å—ä½œä¸ºå¤´ä¿¡æ¯', 'info');
                analysisLog('2. åç»­å—ä¸å¤´ä¿¡æ¯å—åˆå¹¶æ’­æ”¾', 'info');
            } else {
                analysisLog('1. ç¼“å†²2-3ä¸ªéŸ³é¢‘å—ååˆå¹¶æ’­æ”¾', 'info');
                analysisLog('2. ä½¿ç”¨æ»‘åŠ¨çª—å£ç­–ç•¥', 'info');
            }
            analysisLog('3. ä¼˜å…ˆä½¿ç”¨ç›´æ¥æ’­æ”¾æ–¹æ³•', 'info');
            analysisLog('4. æ’­æ”¾å¤±è´¥æ—¶æ˜¾ç¤ºæ¥æ”¶æŒ‡ç¤ºå™¨', 'info');
        }
        
        // æµ‹è¯•æ™ºèƒ½æ’­æ”¾
        async function testSmartPlayback() {
            if (audioChunks.length === 0) {
                log('æ²¡æœ‰éŸ³é¢‘å—å¯æµ‹è¯•', 'warning');
                return;
            }
            
            log('å¼€å§‹æµ‹è¯•æ™ºèƒ½æ’­æ”¾ç­–ç•¥', 'warning');
            
            // é‡ç½®è®¡æ•°å™¨
            smartPlaySuccessCount = 0;
            playFailCount = 0;
            
            // é‡æ–°æµ‹è¯•æ‰€æœ‰å—
            for (let i = 0; i < audioChunks.length; i++) {
                await smartPlayTest(audioChunks[i], i);
                await new Promise(resolve => setTimeout(resolve, 100)); // çŸ­æš‚å»¶è¿Ÿ
            }
            
            updateStats();
            analyzeResults();
        }
        
        // æ¸…ç©ºæ‰€æœ‰
        function clearAll() {
            audioChunks = [];
            smartPlaySuccessCount = 0;
            playFailCount = 0;
            headerChunkIndex = -1;
            successfulPatterns = [];
            updateStats();
            clearLog();
            log('å·²æ¸…ç©ºæ‰€æœ‰æ•°æ®', 'warning');
        }
        
        // äº‹ä»¶ç›‘å¬å™¨
        startRecordBtn.addEventListener('click', startRecording);
        stopRecordBtn.addEventListener('click', stopRecording);
        testSmartBtn.addEventListener('click', testSmartPlayback);
        clearAllBtn.addEventListener('click', clearAll);
        
        // åˆå§‹åŒ–
        updateStats();
        log('æ™ºèƒ½éŸ³é¢‘æ’­æ”¾å™¨å·²åŠ è½½', 'success');
        analysisLog('ğŸš€ å‡†å¤‡å¼€å§‹æ™ºèƒ½æ’­æ”¾æµ‹è¯•', 'info');
    </script>
</body>
</html>