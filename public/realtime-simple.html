<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>简化实时音频聊天</title>
    <script src="https://unpkg.com/openpgp@6.2.0/dist/openpgp.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background: #f0f0f0;
        }
        .container {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            height: 80vh;
        }
        .panel {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .messages {
            height: 400px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            margin: 10px 0;
            background: #fafafa;
        }
        .message {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            background: #e3f2fd;
        }
        .message.system {
            background: #fff3e0;
            font-style: italic;
        }
        button {
            padding: 10px 15px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            background: #007bff;
            color: white;
            cursor: pointer;
        }
        button:hover { background: #0056b3; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        button.recording { background: #dc3545; animation: pulse 1s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        input, textarea {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            background: #d4edda;
            color: #155724;
        }
        .status.error { background: #f8d7da; color: #721c24; }
        .status.warning { background: #fff3cd; color: #856404; }
        .audio-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(39, 174, 96, 0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 1000;
            display: none;
        }
        .audio-indicator.show { display: block; }
    </style>
</head>
<body>
    <h1>简化实时音频聊天</h1>
    
    <div class="container">
        <div class="panel">
            <h3>用户列表</h3>
            <div class="status" id="connectionStatus">未连接</div>
            <div id="userList"></div>
            
            <h3>音频控制</h3>
            <button id="generateKeys">生成密钥</button>
            <button id="startLiveVoice">开始实时语音</button>
            <button id="testAudio">测试音频</button>
            
            <div>
                <label>房间ID:</label>
                <input type="text" id="roomInput" placeholder="输入房间ID或留空自动生成">
                <button id="connectBtn">连接</button>
            </div>
        </div>
        
        <div class="panel">
            <h3>消息</h3>
            <div class="messages" id="messages"></div>
            <textarea id="messageInput" placeholder="输入消息..." rows="3"></textarea>
            <button id="sendMessage">发送消息</button>
        </div>
    </div>
    
    <div class="audio-indicator" id="audioIndicator">🔊 接收音频</div>

    <script>
        // 全局变量
        let websocket = null;
        let privateKey = null;
        let publicKey = null;
        let userId = '';
        let userName = '';
        let roomId = '';
        let users = new Map();
        
        // 音频相关
        let mediaRecorder = null;
        let audioStream = null;
        let isRecording = false;
        
        // DOM元素
        const connectionStatusEl = document.getElementById('connectionStatus');
        const userListEl = document.getElementById('userList');
        const messagesEl = document.getElementById('messages');
        const messageInputEl = document.getElementById('messageInput');
        const roomInputEl = document.getElementById('roomInput');
        const connectBtnEl = document.getElementById('connectBtn');
        const generateKeysBtn = document.getElementById('generateKeys');
        const startLiveVoiceBtn = document.getElementById('startLiveVoice');
        const testAudioBtn = document.getElementById('testAudio');
        const sendMessageBtn = document.getElementById('sendMessage');
        const audioIndicatorEl = document.getElementById('audioIndicator');
        
        // 添加消息到界面
        function addMessage(content, type = 'normal') {
            const messageEl = document.createElement('div');
            messageEl.className = `message ${type}`;
            messageEl.textContent = `[${new Date().toLocaleTimeString()}] ${content}`;
            messagesEl.appendChild(messageEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }
        
        // 更新连接状态
        function updateConnectionStatus(status, type = 'normal') {
            connectionStatusEl.textContent = status;
            connectionStatusEl.className = `status ${type}`;
        }
        
        // 生成密钥对
        async function generateKeys() {
            try {
                addMessage('正在生成密钥对...', 'system');
                
                const { privateKey: privKey, publicKey: pubKey } = await openpgp.generateKey({
                    type: 'ecc',
                    curve: 'curve25519',
                    userIDs: [{ name: `User_${Date.now()}`, email: `user${Date.now()}@example.com` }],
                    passphrase: '',
                    format: 'armored'
                });
                
                privateKey = privKey;
                publicKey = pubKey;
                
                // 提取用户信息
                const key = await openpgp.readKey({ armoredKey: publicKey });
                const primaryUser = await key.getPrimaryUser();
                userId = key.getFingerprint().toUpperCase();
                userName = primaryUser.user.userID?.name || `User_${userId.slice(-8)}`;
                
                addMessage(`密钥生成成功，用户ID: ${userId.slice(-8)}`, 'system');
                generateKeysBtn.textContent = '密钥已生成';
                generateKeysBtn.disabled = true;
                
            } catch (error) {
                addMessage(`密钥生成失败: ${error.message}`, 'system');
            }
        }
        
        // 连接到房间
        async function connectToRoom() {
            if (!privateKey || !publicKey) {
                addMessage('请先生成密钥', 'system');
                return;
            }
            
            try {
                // 获取或生成房间ID
                roomId = roomInputEl.value.trim();
                if (!roomId) {
                    const response = await fetch('/api/room', { method: 'POST' });
                    roomId = await response.text();
                    roomInputEl.value = roomId;
                }
                
                // 建立WebSocket连接
                const wsUrl = `${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.host}/api/room/${roomId}/websocket`;
                websocket = new WebSocket(wsUrl);
                
                websocket.onopen = () => {
                    updateConnectionStatus('已连接', 'normal');
                    addMessage('WebSocket连接成功', 'system');
                    
                    // 注册用户
                    websocket.send(JSON.stringify({
                        type: 'register',
                        publicKey: publicKey
                    }));
                };
                
                websocket.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        handleMessage(message);
                    } catch (error) {
                        addMessage(`消息解析错误: ${error.message}`, 'system');
                    }
                };
                
                websocket.onclose = () => {
                    updateConnectionStatus('连接断开', 'error');
                    addMessage('WebSocket连接断开', 'system');
                };
                
                websocket.onerror = (error) => {
                    updateConnectionStatus('连接错误', 'error');
                    addMessage('WebSocket连接错误', 'system');
                };
                
                connectBtnEl.textContent = '连接中...';
                connectBtnEl.disabled = true;
                
            } catch (error) {
                addMessage(`连接失败: ${error.message}`, 'system');
                updateConnectionStatus('连接失败', 'error');
            }
        }
        
        // 处理接收到的消息
        async function handleMessage(message) {
            switch (message.type) {
                case 'registered':
                    addMessage(`注册成功: ${message.profile.name}`, 'system');
                    connectBtnEl.textContent = '已连接';
                    break;
                    
                case 'userList':
                    updateUserList(message.users);
                    break;
                    
                case 'liveAudioNotification':
                    await handleLiveAudio(message);
                    break;
                    
                case 'encryptedMessage':
                    await handleEncryptedMessage(message);
                    break;
                    
                case 'error':
                    addMessage(`错误: ${message.message}`, 'system');
                    break;
            }
        }
        
        // 更新用户列表
        function updateUserList(userList) {
            users.clear();
            userListEl.innerHTML = '';
            
            userList.forEach(user => {
                users.set(user.id, user);
                const userEl = document.createElement('div');
                userEl.textContent = `${user.name} (${user.id.slice(-8)})`;
                userEl.style.padding = '5px';
                userEl.style.margin = '2px 0';
                userEl.style.background = user.id === userId ? '#e3f2fd' : '#f5f5f5';
                userEl.style.borderRadius = '3px';
                userListEl.appendChild(userEl);
            });
            
            addMessage(`在线用户: ${userList.length}`, 'system');
        }
        
        // 处理实时音频
        async function handleLiveAudio(message) {
            if (!privateKey) return;
            
            try {
                // 解密音频数据
                const decryptedMessage = await openpgp.decrypt({
                    message: await openpgp.readMessage({ armoredMessage: message.encryptedAudioData }),
                    decryptionKeys: await openpgp.readPrivateKey({ armoredKey: privateKey })
                });
                
                const audioData = new Uint8Array(decryptedMessage.data);
                console.log(`接收音频: ${audioData.length} 字节`);
                
                // 使用改进的音频播放（带缓冲）
                await playAudioSimple(audioData, message.senderId);
                showAudioIndicator();
                
            } catch (error) {
                console.error('处理实时音频失败:', error);
                showAudioIndicator(); // 即使播放失败也显示接收指示器
            }
        }
        
        // 改进的音频播放 - 使用缓冲策略
        let userAudioBuffers = new Map();
        
        async function playAudioSimple(audioData, senderId = 'default') {
            try {
                // 初始化用户缓冲区
                if (!userAudioBuffers.has(senderId)) {
                    userAudioBuffers.set(senderId, {
                        chunks: [],
                        totalSize: 0,
                        isProcessing: false,
                        lastUpdate: Date.now()
                    });
                }
                
                const buffer = userAudioBuffers.get(senderId);
                buffer.chunks.push(audioData);
                buffer.totalSize += audioData.length;
                buffer.lastUpdate = Date.now();
                
                console.log(`缓冲音频: ${audioData.length} 字节，总计: ${buffer.totalSize} 字节`);
                
                // 如果不在处理中，开始处理
                if (!buffer.isProcessing) {
                    buffer.isProcessing = true;
                    await processUserAudioBuffer(senderId);
                }
                
            } catch (error) {
                console.error('音频播放失败:', error);
            }
        }
        
        // 处理用户音频缓冲区
        async function processUserAudioBuffer(senderId) {
            const buffer = userAudioBuffers.get(senderId);
            if (!buffer || buffer.chunks.length === 0) {
                if (buffer) buffer.isProcessing = false;
                return;
            }
            
            try {
                // 如果有足够的数据或等待时间够长，尝试播放
                const waitTime = Date.now() - buffer.lastUpdate;
                const shouldPlay = buffer.totalSize >= 2000 || buffer.chunks.length >= 2 || waitTime > 300;
                
                if (shouldPlay) {
                    // 取出一些块进行播放
                    const chunksToPlay = buffer.chunks.splice(0, Math.min(2, buffer.chunks.length));
                    const playSize = chunksToPlay.reduce((sum, chunk) => sum + chunk.length, 0);
                    buffer.totalSize -= playSize;
                    
                    // 合并音频数据
                    const mergedAudio = new Uint8Array(playSize);
                    let offset = 0;
                    for (const chunk of chunksToPlay) {
                        mergedAudio.set(chunk, offset);
                        offset += chunk.length;
                    }
                    
                    console.log(`尝试播放合并音频: ${playSize} 字节`);
                    
                    // 尝试播放
                    if (await tryPlayAudio(mergedAudio)) {
                        console.log('音频播放成功');
                    } else {
                        console.log('音频播放失败，显示指示器');
                        showAudioIndicator();
                    }
                }
                
                // 继续处理剩余数据
                if (buffer.chunks.length > 0) {
                    setTimeout(() => processUserAudioBuffer(senderId), 100);
                } else {
                    buffer.isProcessing = false;
                }
                
            } catch (error) {
                console.error('处理音频缓冲区失败:', error);
                buffer.isProcessing = false;
            }
        }
        
        // 尝试播放音频
        async function tryPlayAudio(audioData) {
            // 方法1: Web Audio API
            if (await tryWebAudioPlayback(audioData)) {
                return true;
            }
            
            // 方法2: 直接播放
            if (await tryDirectPlayback(audioData)) {
                return true;
            }
            
            return false;
        }
        
        // Web Audio API 播放
        async function tryWebAudioPlayback(audioData) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const audioBuffer = await audioContext.decodeAudioData(audioData.buffer.slice());
                
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(audioContext.destination);
                source.start(0);
                
                return true;
            } catch (error) {
                console.log('Web Audio 播放失败:', error.message);
                return false;
            }
        }
        
        // 直接播放
        async function tryDirectPlayback(audioData) {
            try {
                const formats = ['audio/webm;codecs=opus', 'audio/webm', 'audio/ogg;codecs=opus'];
                
                for (const format of formats) {
                    try {
                        const audioBlob = new Blob([audioData], { type: format });
                        const audioUrl = URL.createObjectURL(audioBlob);
                        const audio = new Audio();
                        
                        audio.src = audioUrl;
                        audio.volume = 0.8;
                        
                        const success = await new Promise((resolve) => {
                            let resolved = false;
                            
                            const cleanup = () => {
                                if (!resolved) {
                                    resolved = true;
                                    URL.revokeObjectURL(audioUrl);
                                }
                            };
                            
                            audio.oncanplaythrough = () => {
                                audio.play().then(() => {
                                    cleanup();
                                    resolve(true);
                                }).catch(() => {
                                    cleanup();
                                    resolve(false);
                                });
                            };
                            
                            audio.onerror = () => {
                                cleanup();
                                resolve(false);
                            };
                            
                            setTimeout(() => {
                                cleanup();
                                resolve(false);
                            }, 800);
                        });
                        
                        if (success) {
                            console.log(`播放成功: ${format}`);
                            return true;
                        }
                        
                    } catch (error) {
                        console.log(`格式 ${format} 播放失败:`, error.message);
                    }
                }
                
                return false;
                
            } catch (error) {
                console.log('直接播放失败:', error.message);
                return false;
            }
        }
        
        // 显示音频接收指示器
        function showAudioIndicator() {
            audioIndicatorEl.classList.add('show');
            setTimeout(() => {
                audioIndicatorEl.classList.remove('show');
            }, 1000);
        }
        
        // 开始/停止实时语音
        async function toggleLiveVoice() {
            if (!isRecording) {
                await startLiveVoice();
            } else {
                stopLiveVoice();
            }
        }
        
        // 开始实时语音
        async function startLiveVoice() {
            try {
                audioStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: 16000
                    }
                });
                
                // 检查支持的格式
                const formats = ['audio/webm;codecs=opus', 'audio/webm', 'audio/ogg;codecs=opus'];
                let selectedFormat = null;
                
                for (const format of formats) {
                    if (MediaRecorder.isTypeSupported(format)) {
                        selectedFormat = format;
                        break;
                    }
                }
                
                if (!selectedFormat) {
                    throw new Error('浏览器不支持音频录制');
                }
                
                mediaRecorder = new MediaRecorder(audioStream, {
                    mimeType: selectedFormat,
                    audioBitsPerSecond: 32000 // 降低码率，减少数据量
                });
                
                mediaRecorder.ondataavailable = async (event) => {
                    if (event.data.size > 0 && websocket && websocket.readyState === WebSocket.OPEN) {
                        await sendAudioChunk(event.data);
                    }
                };
                
                mediaRecorder.start(300); // 每300ms一个块，平衡延迟和质量
                isRecording = true;
                
                startLiveVoiceBtn.textContent = '停止语音';
                startLiveVoiceBtn.classList.add('recording');
                addMessage('实时语音已开启', 'system');
                
            } catch (error) {
                addMessage(`启动实时语音失败: ${error.message}`, 'system');
            }
        }
        
        // 停止实时语音
        function stopLiveVoice() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            
            if (audioStream) {
                audioStream.getTracks().forEach(track => track.stop());
                audioStream = null;
            }
            
            isRecording = false;
            startLiveVoiceBtn.textContent = '开始实时语音';
            startLiveVoiceBtn.classList.remove('recording');
            addMessage('实时语音已停止', 'system');
        }
        
        // 发送音频块
        async function sendAudioChunk(audioBlob) {
            try {
                const arrayBuffer = await audioBlob.arrayBuffer();
                const audioData = new Uint8Array(arrayBuffer);
                
                // 加密音频数据
                const encryptedData = await encryptForAllUsers(audioData);
                
                const message = {
                    type: 'liveAudio',
                    encryptedAudioData: encryptedData,
                    timestamp: Date.now()
                };
                
                websocket.send(JSON.stringify(message));
                console.log(`发送音频: ${audioData.length} 字节`);
                
            } catch (error) {
                console.error('发送音频失败:', error);
            }
        }
        
        // 为所有用户加密数据
        async function encryptForAllUsers(data) {
            const publicKeys = Array.from(users.values()).map(user => user.publicKey);
            
            if (publicKeys.length === 0) {
                return '';
            }
            
            const keys = await Promise.all(
                publicKeys.map(key => openpgp.readKey({ armoredKey: key }))
            );
            
            const encrypted = await openpgp.encrypt({
                message: await openpgp.createMessage({ binary: data }),
                encryptionKeys: keys,
                format: 'armored'
            });
            
            return encrypted;
        }
        
        // 处理加密消息
        async function handleEncryptedMessage(message) {
            try {
                const decryptedMessage = await openpgp.decrypt({
                    message: await openpgp.readMessage({ armoredMessage: message.encryptedData }),
                    decryptionKeys: await openpgp.readPrivateKey({ armoredKey: privateKey })
                });
                
                const senderName = users.get(message.senderId)?.name || message.senderId.slice(-8);
                addMessage(`${senderName}: ${decryptedMessage.data}`);
                
            } catch (error) {
                addMessage(`解密消息失败: ${error.message}`, 'system');
            }
        }
        
        // 发送文本消息
        async function sendTextMessage() {
            const text = messageInputEl.value.trim();
            if (!text || !websocket || websocket.readyState !== WebSocket.OPEN) {
                return;
            }
            
            try {
                const encryptedData = await encryptForAllUsers(new TextEncoder().encode(text));
                
                const message = {
                    type: 'message',
                    encryptedData: encryptedData
                };
                
                websocket.send(JSON.stringify(message));
                messageInputEl.value = '';
                addMessage(`我: ${text}`);
                
            } catch (error) {
                addMessage(`发送消息失败: ${error.message}`, 'system');
            }
        }
        
        // 测试音频功能
        async function testAudio() {
            try {
                addMessage('开始音频测试...', 'system');
                
                // 测试麦克风
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                addMessage('✓ 麦克风访问正常', 'system');
                
                // 测试录制
                const recorder = new MediaRecorder(stream);
                const chunks = [];
                
                recorder.ondataavailable = (event) => {
                    chunks.push(event.data);
                };
                
                recorder.onstop = async () => {
                    const blob = new Blob(chunks, { type: 'audio/webm' });
                    addMessage(`✓ 录制测试完成: ${blob.size} 字节`, 'system');
                    
                    // 测试播放
                    try {
                        const audioUrl = URL.createObjectURL(blob);
                        const audio = new Audio(audioUrl);
                        await audio.play();
                        addMessage('✓ 播放测试成功', 'system');
                        setTimeout(() => URL.revokeObjectURL(audioUrl), 1000);
                    } catch (error) {
                        addMessage(`✗ 播放测试失败: ${error.message}`, 'system');
                    }
                };
                
                recorder.start();
                setTimeout(() => {
                    recorder.stop();
                    stream.getTracks().forEach(track => track.stop());
                }, 1000);
                
            } catch (error) {
                addMessage(`音频测试失败: ${error.message}`, 'system');
            }
        }
        
        // 事件监听器
        generateKeysBtn.addEventListener('click', generateKeys);
        connectBtnEl.addEventListener('click', connectToRoom);
        startLiveVoiceBtn.addEventListener('click', toggleLiveVoice);
        testAudioBtn.addEventListener('click', testAudio);
        sendMessageBtn.addEventListener('click', sendTextMessage);
        
        messageInputEl.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendTextMessage();
            }
        });
        
        // 初始化
        addMessage('简化实时音频聊天已加载', 'system');
        addMessage('请先生成密钥，然后连接到房间', 'system');
    </script>
</body>
</html>