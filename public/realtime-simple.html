<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç®€åŒ–å®æ—¶éŸ³é¢‘èŠå¤©</title>
    <script src="https://unpkg.com/openpgp@6.2.0/dist/openpgp.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background: #f0f0f0;
        }
        .container {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            height: 80vh;
        }
        .panel {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .messages {
            height: 400px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            margin: 10px 0;
            background: #fafafa;
        }
        .message {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            background: #e3f2fd;
        }
        .message.system {
            background: #fff3e0;
            font-style: italic;
        }
        button {
            padding: 10px 15px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            background: #007bff;
            color: white;
            cursor: pointer;
        }
        button:hover { background: #0056b3; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        button.recording { background: #dc3545; animation: pulse 1s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        input, textarea {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            background: #d4edda;
            color: #155724;
        }
        .status.error { background: #f8d7da; color: #721c24; }
        .status.warning { background: #fff3cd; color: #856404; }
        .audio-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(39, 174, 96, 0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 1000;
            display: none;
        }
        .audio-indicator.show { display: block; }
    </style>
</head>
<body>
    <h1>ç®€åŒ–å®æ—¶éŸ³é¢‘èŠå¤©</h1>
    
    <div class="container">
        <div class="panel">
            <h3>ç”¨æˆ·åˆ—è¡¨</h3>
            <div class="status" id="connectionStatus">æœªè¿æ¥</div>
            <div id="userList"></div>
            
            <h3>éŸ³é¢‘æ§åˆ¶</h3>
            <button id="generateKeys">ç”Ÿæˆå¯†é’¥</button>
            <button id="startLiveVoice">å¼€å§‹å®æ—¶è¯­éŸ³</button>
            <button id="testAudio">æµ‹è¯•éŸ³é¢‘</button>
            
            <div>
                <label>æˆ¿é—´ID:</label>
                <input type="text" id="roomInput" placeholder="è¾“å…¥æˆ¿é—´IDæˆ–ç•™ç©ºè‡ªåŠ¨ç”Ÿæˆ">
                <button id="connectBtn">è¿æ¥</button>
            </div>
        </div>
        
        <div class="panel">
            <h3>æ¶ˆæ¯</h3>
            <div class="messages" id="messages"></div>
            <textarea id="messageInput" placeholder="è¾“å…¥æ¶ˆæ¯..." rows="3"></textarea>
            <button id="sendMessage">å‘é€æ¶ˆæ¯</button>
        </div>
    </div>
    
    <div class="audio-indicator" id="audioIndicator">ğŸ”Š æ¥æ”¶éŸ³é¢‘</div>

    <script>
        // å…¨å±€å˜é‡
        let websocket = null;
        let privateKey = null;
        let publicKey = null;
        let userId = '';
        let userName = '';
        let roomId = '';
        let users = new Map();
        
        // éŸ³é¢‘ç›¸å…³
        let mediaRecorder = null;
        let audioStream = null;
        let isRecording = false;
        
        // DOMå…ƒç´ 
        const connectionStatusEl = document.getElementById('connectionStatus');
        const userListEl = document.getElementById('userList');
        const messagesEl = document.getElementById('messages');
        const messageInputEl = document.getElementById('messageInput');
        const roomInputEl = document.getElementById('roomInput');
        const connectBtnEl = document.getElementById('connectBtn');
        const generateKeysBtn = document.getElementById('generateKeys');
        const startLiveVoiceBtn = document.getElementById('startLiveVoice');
        const testAudioBtn = document.getElementById('testAudio');
        const sendMessageBtn = document.getElementById('sendMessage');
        const audioIndicatorEl = document.getElementById('audioIndicator');
        
        // æ·»åŠ æ¶ˆæ¯åˆ°ç•Œé¢
        function addMessage(content, type = 'normal') {
            const messageEl = document.createElement('div');
            messageEl.className = `message ${type}`;
            messageEl.textContent = `[${new Date().toLocaleTimeString()}] ${content}`;
            messagesEl.appendChild(messageEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }
        
        // æ›´æ–°è¿æ¥çŠ¶æ€
        function updateConnectionStatus(status, type = 'normal') {
            connectionStatusEl.textContent = status;
            connectionStatusEl.className = `status ${type}`;
        }
        
        // ç”Ÿæˆå¯†é’¥å¯¹
        async function generateKeys() {
            try {
                addMessage('æ­£åœ¨ç”Ÿæˆå¯†é’¥å¯¹...', 'system');
                
                const { privateKey: privKey, publicKey: pubKey } = await openpgp.generateKey({
                    type: 'ecc',
                    curve: 'curve25519',
                    userIDs: [{ name: `User_${Date.now()}`, email: `user${Date.now()}@example.com` }],
                    passphrase: '',
                    format: 'armored'
                });
                
                privateKey = privKey;
                publicKey = pubKey;
                
                // æå–ç”¨æˆ·ä¿¡æ¯
                const key = await openpgp.readKey({ armoredKey: publicKey });
                const primaryUser = await key.getPrimaryUser();
                userId = key.getFingerprint().toUpperCase();
                userName = primaryUser.user.userID?.name || `User_${userId.slice(-8)}`;
                
                addMessage(`å¯†é’¥ç”ŸæˆæˆåŠŸï¼Œç”¨æˆ·ID: ${userId.slice(-8)}`, 'system');
                generateKeysBtn.textContent = 'å¯†é’¥å·²ç”Ÿæˆ';
                generateKeysBtn.disabled = true;
                
            } catch (error) {
                addMessage(`å¯†é’¥ç”Ÿæˆå¤±è´¥: ${error.message}`, 'system');
            }
        }
        
        // è¿æ¥åˆ°æˆ¿é—´
        async function connectToRoom() {
            if (!privateKey || !publicKey) {
                addMessage('è¯·å…ˆç”Ÿæˆå¯†é’¥', 'system');
                return;
            }
            
            try {
                // è·å–æˆ–ç”Ÿæˆæˆ¿é—´ID
                roomId = roomInputEl.value.trim();
                if (!roomId) {
                    const response = await fetch('/api/room', { method: 'POST' });
                    roomId = await response.text();
                    roomInputEl.value = roomId;
                }
                
                // å»ºç«‹WebSocketè¿æ¥
                const wsUrl = `${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.host}/api/room/${roomId}/websocket`;
                websocket = new WebSocket(wsUrl);
                
                websocket.onopen = () => {
                    updateConnectionStatus('å·²è¿æ¥', 'normal');
                    addMessage('WebSocketè¿æ¥æˆåŠŸ', 'system');
                    
                    // æ³¨å†Œç”¨æˆ·
                    websocket.send(JSON.stringify({
                        type: 'register',
                        publicKey: publicKey
                    }));
                };
                
                websocket.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        handleMessage(message);
                    } catch (error) {
                        addMessage(`æ¶ˆæ¯è§£æé”™è¯¯: ${error.message}`, 'system');
                    }
                };
                
                websocket.onclose = () => {
                    updateConnectionStatus('è¿æ¥æ–­å¼€', 'error');
                    addMessage('WebSocketè¿æ¥æ–­å¼€', 'system');
                };
                
                websocket.onerror = (error) => {
                    updateConnectionStatus('è¿æ¥é”™è¯¯', 'error');
                    addMessage('WebSocketè¿æ¥é”™è¯¯', 'system');
                };
                
                connectBtnEl.textContent = 'è¿æ¥ä¸­...';
                connectBtnEl.disabled = true;
                
            } catch (error) {
                addMessage(`è¿æ¥å¤±è´¥: ${error.message}`, 'system');
                updateConnectionStatus('è¿æ¥å¤±è´¥', 'error');
            }
        }
        
        // å¤„ç†æ¥æ”¶åˆ°çš„æ¶ˆæ¯
        async function handleMessage(message) {
            switch (message.type) {
                case 'registered':
                    addMessage(`æ³¨å†ŒæˆåŠŸ: ${message.profile.name}`, 'system');
                    connectBtnEl.textContent = 'å·²è¿æ¥';
                    break;
                    
                case 'userList':
                    updateUserList(message.users);
                    break;
                    
                case 'liveAudioNotification':
                    await handleLiveAudio(message);
                    break;
                    
                case 'encryptedMessage':
                    await handleEncryptedMessage(message);
                    break;
                    
                case 'error':
                    addMessage(`é”™è¯¯: ${message.message}`, 'system');
                    break;
            }
        }
        
        // æ›´æ–°ç”¨æˆ·åˆ—è¡¨
        function updateUserList(userList) {
            users.clear();
            userListEl.innerHTML = '';
            
            userList.forEach(user => {
                users.set(user.id, user);
                const userEl = document.createElement('div');
                userEl.textContent = `${user.name} (${user.id.slice(-8)})`;
                userEl.style.padding = '5px';
                userEl.style.margin = '2px 0';
                userEl.style.background = user.id === userId ? '#e3f2fd' : '#f5f5f5';
                userEl.style.borderRadius = '3px';
                userListEl.appendChild(userEl);
            });
            
            addMessage(`åœ¨çº¿ç”¨æˆ·: ${userList.length}`, 'system');
        }
        
        // å¤„ç†å®æ—¶éŸ³é¢‘
        async function handleLiveAudio(message) {
            if (!privateKey) return;
            
            try {
                // è§£å¯†éŸ³é¢‘æ•°æ®
                const decryptedMessage = await openpgp.decrypt({
                    message: await openpgp.readMessage({ armoredMessage: message.encryptedAudioData }),
                    decryptionKeys: await openpgp.readPrivateKey({ armoredKey: privateKey })
                });
                
                const audioData = new Uint8Array(decryptedMessage.data);
                console.log(`æ¥æ”¶éŸ³é¢‘: ${audioData.length} å­—èŠ‚`);
                
                // ä½¿ç”¨æ”¹è¿›çš„éŸ³é¢‘æ’­æ”¾ï¼ˆå¸¦ç¼“å†²ï¼‰
                await playAudioSimple(audioData, message.senderId);
                showAudioIndicator();
                
            } catch (error) {
                console.error('å¤„ç†å®æ—¶éŸ³é¢‘å¤±è´¥:', error);
                showAudioIndicator(); // å³ä½¿æ’­æ”¾å¤±è´¥ä¹Ÿæ˜¾ç¤ºæ¥æ”¶æŒ‡ç¤ºå™¨
            }
        }
        
        // æ”¹è¿›çš„éŸ³é¢‘æ’­æ”¾ - ä½¿ç”¨ç¼“å†²ç­–ç•¥
        let userAudioBuffers = new Map();
        
        async function playAudioSimple(audioData, senderId = 'default') {
            try {
                // åˆå§‹åŒ–ç”¨æˆ·ç¼“å†²åŒº
                if (!userAudioBuffers.has(senderId)) {
                    userAudioBuffers.set(senderId, {
                        chunks: [],
                        totalSize: 0,
                        isProcessing: false,
                        lastUpdate: Date.now()
                    });
                }
                
                const buffer = userAudioBuffers.get(senderId);
                buffer.chunks.push(audioData);
                buffer.totalSize += audioData.length;
                buffer.lastUpdate = Date.now();
                
                console.log(`ç¼“å†²éŸ³é¢‘: ${audioData.length} å­—èŠ‚ï¼Œæ€»è®¡: ${buffer.totalSize} å­—èŠ‚`);
                
                // å¦‚æœä¸åœ¨å¤„ç†ä¸­ï¼Œå¼€å§‹å¤„ç†
                if (!buffer.isProcessing) {
                    buffer.isProcessing = true;
                    await processUserAudioBuffer(senderId);
                }
                
            } catch (error) {
                console.error('éŸ³é¢‘æ’­æ”¾å¤±è´¥:', error);
            }
        }
        
        // å¤„ç†ç”¨æˆ·éŸ³é¢‘ç¼“å†²åŒº
        async function processUserAudioBuffer(senderId) {
            const buffer = userAudioBuffers.get(senderId);
            if (!buffer || buffer.chunks.length === 0) {
                if (buffer) buffer.isProcessing = false;
                return;
            }
            
            try {
                // å¦‚æœæœ‰è¶³å¤Ÿçš„æ•°æ®æˆ–ç­‰å¾…æ—¶é—´å¤Ÿé•¿ï¼Œå°è¯•æ’­æ”¾
                const waitTime = Date.now() - buffer.lastUpdate;
                const shouldPlay = buffer.totalSize >= 2000 || buffer.chunks.length >= 2 || waitTime > 300;
                
                if (shouldPlay) {
                    // å–å‡ºä¸€äº›å—è¿›è¡Œæ’­æ”¾
                    const chunksToPlay = buffer.chunks.splice(0, Math.min(2, buffer.chunks.length));
                    const playSize = chunksToPlay.reduce((sum, chunk) => sum + chunk.length, 0);
                    buffer.totalSize -= playSize;
                    
                    // åˆå¹¶éŸ³é¢‘æ•°æ®
                    const mergedAudio = new Uint8Array(playSize);
                    let offset = 0;
                    for (const chunk of chunksToPlay) {
                        mergedAudio.set(chunk, offset);
                        offset += chunk.length;
                    }
                    
                    console.log(`å°è¯•æ’­æ”¾åˆå¹¶éŸ³é¢‘: ${playSize} å­—èŠ‚`);
                    
                    // å°è¯•æ’­æ”¾
                    if (await tryPlayAudio(mergedAudio)) {
                        console.log('éŸ³é¢‘æ’­æ”¾æˆåŠŸ');
                    } else {
                        console.log('éŸ³é¢‘æ’­æ”¾å¤±è´¥ï¼Œæ˜¾ç¤ºæŒ‡ç¤ºå™¨');
                        showAudioIndicator();
                    }
                }
                
                // ç»§ç»­å¤„ç†å‰©ä½™æ•°æ®
                if (buffer.chunks.length > 0) {
                    setTimeout(() => processUserAudioBuffer(senderId), 100);
                } else {
                    buffer.isProcessing = false;
                }
                
            } catch (error) {
                console.error('å¤„ç†éŸ³é¢‘ç¼“å†²åŒºå¤±è´¥:', error);
                buffer.isProcessing = false;
            }
        }
        
        // å°è¯•æ’­æ”¾éŸ³é¢‘
        async function tryPlayAudio(audioData) {
            // æ–¹æ³•1: Web Audio API
            if (await tryWebAudioPlayback(audioData)) {
                return true;
            }
            
            // æ–¹æ³•2: ç›´æ¥æ’­æ”¾
            if (await tryDirectPlayback(audioData)) {
                return true;
            }
            
            return false;
        }
        
        // Web Audio API æ’­æ”¾
        async function tryWebAudioPlayback(audioData) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const audioBuffer = await audioContext.decodeAudioData(audioData.buffer.slice());
                
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(audioContext.destination);
                source.start(0);
                
                return true;
            } catch (error) {
                console.log('Web Audio æ’­æ”¾å¤±è´¥:', error.message);
                return false;
            }
        }
        
        // ç›´æ¥æ’­æ”¾
        async function tryDirectPlayback(audioData) {
            try {
                const formats = ['audio/webm;codecs=opus', 'audio/webm', 'audio/ogg;codecs=opus'];
                
                for (const format of formats) {
                    try {
                        const audioBlob = new Blob([audioData], { type: format });
                        const audioUrl = URL.createObjectURL(audioBlob);
                        const audio = new Audio();
                        
                        audio.src = audioUrl;
                        audio.volume = 0.8;
                        
                        const success = await new Promise((resolve) => {
                            let resolved = false;
                            
                            const cleanup = () => {
                                if (!resolved) {
                                    resolved = true;
                                    URL.revokeObjectURL(audioUrl);
                                }
                            };
                            
                            audio.oncanplaythrough = () => {
                                audio.play().then(() => {
                                    cleanup();
                                    resolve(true);
                                }).catch(() => {
                                    cleanup();
                                    resolve(false);
                                });
                            };
                            
                            audio.onerror = () => {
                                cleanup();
                                resolve(false);
                            };
                            
                            setTimeout(() => {
                                cleanup();
                                resolve(false);
                            }, 800);
                        });
                        
                        if (success) {
                            console.log(`æ’­æ”¾æˆåŠŸ: ${format}`);
                            return true;
                        }
                        
                    } catch (error) {
                        console.log(`æ ¼å¼ ${format} æ’­æ”¾å¤±è´¥:`, error.message);
                    }
                }
                
                return false;
                
            } catch (error) {
                console.log('ç›´æ¥æ’­æ”¾å¤±è´¥:', error.message);
                return false;
            }
        }
        
        // æ˜¾ç¤ºéŸ³é¢‘æ¥æ”¶æŒ‡ç¤ºå™¨
        function showAudioIndicator() {
            audioIndicatorEl.classList.add('show');
            setTimeout(() => {
                audioIndicatorEl.classList.remove('show');
            }, 1000);
        }
        
        // å¼€å§‹/åœæ­¢å®æ—¶è¯­éŸ³
        async function toggleLiveVoice() {
            if (!isRecording) {
                await startLiveVoice();
            } else {
                stopLiveVoice();
            }
        }
        
        // å¼€å§‹å®æ—¶è¯­éŸ³
        async function startLiveVoice() {
            try {
                audioStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: 16000
                    }
                });
                
                // æ£€æŸ¥æ”¯æŒçš„æ ¼å¼
                const formats = ['audio/webm;codecs=opus', 'audio/webm', 'audio/ogg;codecs=opus'];
                let selectedFormat = null;
                
                for (const format of formats) {
                    if (MediaRecorder.isTypeSupported(format)) {
                        selectedFormat = format;
                        break;
                    }
                }
                
                if (!selectedFormat) {
                    throw new Error('æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘å½•åˆ¶');
                }
                
                mediaRecorder = new MediaRecorder(audioStream, {
                    mimeType: selectedFormat,
                    audioBitsPerSecond: 32000 // é™ä½ç ç‡ï¼Œå‡å°‘æ•°æ®é‡
                });
                
                mediaRecorder.ondataavailable = async (event) => {
                    if (event.data.size > 0 && websocket && websocket.readyState === WebSocket.OPEN) {
                        await sendAudioChunk(event.data);
                    }
                };
                
                mediaRecorder.start(300); // æ¯300msä¸€ä¸ªå—ï¼Œå¹³è¡¡å»¶è¿Ÿå’Œè´¨é‡
                isRecording = true;
                
                startLiveVoiceBtn.textContent = 'åœæ­¢è¯­éŸ³';
                startLiveVoiceBtn.classList.add('recording');
                addMessage('å®æ—¶è¯­éŸ³å·²å¼€å¯', 'system');
                
            } catch (error) {
                addMessage(`å¯åŠ¨å®æ—¶è¯­éŸ³å¤±è´¥: ${error.message}`, 'system');
            }
        }
        
        // åœæ­¢å®æ—¶è¯­éŸ³
        function stopLiveVoice() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            
            if (audioStream) {
                audioStream.getTracks().forEach(track => track.stop());
                audioStream = null;
            }
            
            isRecording = false;
            startLiveVoiceBtn.textContent = 'å¼€å§‹å®æ—¶è¯­éŸ³';
            startLiveVoiceBtn.classList.remove('recording');
            addMessage('å®æ—¶è¯­éŸ³å·²åœæ­¢', 'system');
        }
        
        // å‘é€éŸ³é¢‘å—
        async function sendAudioChunk(audioBlob) {
            try {
                const arrayBuffer = await audioBlob.arrayBuffer();
                const audioData = new Uint8Array(arrayBuffer);
                
                // åŠ å¯†éŸ³é¢‘æ•°æ®
                const encryptedData = await encryptForAllUsers(audioData);
                
                const message = {
                    type: 'liveAudio',
                    encryptedAudioData: encryptedData,
                    timestamp: Date.now()
                };
                
                websocket.send(JSON.stringify(message));
                console.log(`å‘é€éŸ³é¢‘: ${audioData.length} å­—èŠ‚`);
                
            } catch (error) {
                console.error('å‘é€éŸ³é¢‘å¤±è´¥:', error);
            }
        }
        
        // ä¸ºæ‰€æœ‰ç”¨æˆ·åŠ å¯†æ•°æ®
        async function encryptForAllUsers(data) {
            const publicKeys = Array.from(users.values()).map(user => user.publicKey);
            
            if (publicKeys.length === 0) {
                return '';
            }
            
            const keys = await Promise.all(
                publicKeys.map(key => openpgp.readKey({ armoredKey: key }))
            );
            
            const encrypted = await openpgp.encrypt({
                message: await openpgp.createMessage({ binary: data }),
                encryptionKeys: keys,
                format: 'armored'
            });
            
            return encrypted;
        }
        
        // å¤„ç†åŠ å¯†æ¶ˆæ¯
        async function handleEncryptedMessage(message) {
            try {
                const decryptedMessage = await openpgp.decrypt({
                    message: await openpgp.readMessage({ armoredMessage: message.encryptedData }),
                    decryptionKeys: await openpgp.readPrivateKey({ armoredKey: privateKey })
                });
                
                const senderName = users.get(message.senderId)?.name || message.senderId.slice(-8);
                addMessage(`${senderName}: ${decryptedMessage.data}`);
                
            } catch (error) {
                addMessage(`è§£å¯†æ¶ˆæ¯å¤±è´¥: ${error.message}`, 'system');
            }
        }
        
        // å‘é€æ–‡æœ¬æ¶ˆæ¯
        async function sendTextMessage() {
            const text = messageInputEl.value.trim();
            if (!text || !websocket || websocket.readyState !== WebSocket.OPEN) {
                return;
            }
            
            try {
                const encryptedData = await encryptForAllUsers(new TextEncoder().encode(text));
                
                const message = {
                    type: 'message',
                    encryptedData: encryptedData
                };
                
                websocket.send(JSON.stringify(message));
                messageInputEl.value = '';
                addMessage(`æˆ‘: ${text}`);
                
            } catch (error) {
                addMessage(`å‘é€æ¶ˆæ¯å¤±è´¥: ${error.message}`, 'system');
            }
        }
        
        // æµ‹è¯•éŸ³é¢‘åŠŸèƒ½
        async function testAudio() {
            try {
                addMessage('å¼€å§‹éŸ³é¢‘æµ‹è¯•...', 'system');
                
                // æµ‹è¯•éº¦å…‹é£
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                addMessage('âœ“ éº¦å…‹é£è®¿é—®æ­£å¸¸', 'system');
                
                // æµ‹è¯•å½•åˆ¶
                const recorder = new MediaRecorder(stream);
                const chunks = [];
                
                recorder.ondataavailable = (event) => {
                    chunks.push(event.data);
                };
                
                recorder.onstop = async () => {
                    const blob = new Blob(chunks, { type: 'audio/webm' });
                    addMessage(`âœ“ å½•åˆ¶æµ‹è¯•å®Œæˆ: ${blob.size} å­—èŠ‚`, 'system');
                    
                    // æµ‹è¯•æ’­æ”¾
                    try {
                        const audioUrl = URL.createObjectURL(blob);
                        const audio = new Audio(audioUrl);
                        await audio.play();
                        addMessage('âœ“ æ’­æ”¾æµ‹è¯•æˆåŠŸ', 'system');
                        setTimeout(() => URL.revokeObjectURL(audioUrl), 1000);
                    } catch (error) {
                        addMessage(`âœ— æ’­æ”¾æµ‹è¯•å¤±è´¥: ${error.message}`, 'system');
                    }
                };
                
                recorder.start();
                setTimeout(() => {
                    recorder.stop();
                    stream.getTracks().forEach(track => track.stop());
                }, 1000);
                
            } catch (error) {
                addMessage(`éŸ³é¢‘æµ‹è¯•å¤±è´¥: ${error.message}`, 'system');
            }
        }
        
        // äº‹ä»¶ç›‘å¬å™¨
        generateKeysBtn.addEventListener('click', generateKeys);
        connectBtnEl.addEventListener('click', connectToRoom);
        startLiveVoiceBtn.addEventListener('click', toggleLiveVoice);
        testAudioBtn.addEventListener('click', testAudio);
        sendMessageBtn.addEventListener('click', sendTextMessage);
        
        messageInputEl.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendTextMessage();
            }
        });
        
        // åˆå§‹åŒ–
        addMessage('ç®€åŒ–å®æ—¶éŸ³é¢‘èŠå¤©å·²åŠ è½½', 'system');
        addMessage('è¯·å…ˆç”Ÿæˆå¯†é’¥ï¼Œç„¶åè¿æ¥åˆ°æˆ¿é—´', 'system');
    </script>
</body>
</html>