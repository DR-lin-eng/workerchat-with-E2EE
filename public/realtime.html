<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>实时文件传输聊天室</title>
    <script src="https://unpkg.com/openpgp@6.2.0/dist/openpgp.min.js"></script>
    <style>
        :root {
            --primary: #4a6fa5;
            --secondary: #6b8cbc;
            --light: #f0f4f8;
            --dark: #2c3e50;
            --success: #27ae60;
            --warning: #f39c12;
            --danger: #e74c3c;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
            color: var(--light);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            height: calc(100vh - 40px);
        }
        
        .panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.18);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .header {
            padding-bottom: 15px;
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        h1, h2, h3 {
            color: white;
            margin-bottom: 15px;
        }
        
        .connection-status {
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.85em;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .status-connected { background: var(--success); }
        .status-connecting { background: var(--warning); }
        .status-disconnected { background: var(--danger); }
        
        .user-list {
            flex: 1;
            overflow-y: auto;
        }
        
        .user-item {
            padding: 9px;
            margin-bottom: 10px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .user-item:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateX(5px);
        }
        
        .user-item.self {
            background: rgba(74, 111, 165, 0.3);
        }
        
        .user-name {
            font-weight: bold;
            margin-bottom: 2px;
        }
        
        .user-id {
            font-size: 0.75em;
            color: #bbb;
            word-break: break-all;
            font-family: monospace;
        }
        
        .file-transfer-btn {
            margin-top: 5px;
            padding: 4px 8px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8em;
            width: 100%;
        }
        
        .file-transfer-btn:hover {
            background: var(--secondary);
        }
        
        .file-transfer-btn:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .chat-area {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .messages {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            margin-bottom: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }
        
        .message {
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 10px;
            max-width: 80%;
            word-wrap: break-word;
        }
        
        .message.sent {
            background: var(--primary);
            align-self: flex-end;
            margin-left: 20%;
        }
        
        .message.received {
            background: var(--dark);
            align-self: flex-start;
            margin-right: 20%;
        }
        
        .message.file {
            background: rgba(106, 90, 205, 0.3);
            border: 1px solid #6a5acd;
        }
        
        .message.system {
            background: rgba(255, 165, 0, 0.3);
            border: 1px solid #ffa500;
            text-align: center;
            margin: 10px auto;
            max-width: 60%;
        }
        
        .sender-info {
            font-weight: bold;
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
            font-size: 0.85em;
        }
        
        .sender-name {
            color: #4ec9b0;
        }
        
        .message-time {
            font-size: 0.75em;
            opacity: 0.7;
        }
        
        .file-message {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .file-icon {
            font-size: 2em;
        }
        
        .file-info {
            flex: 1;
        }
        
        .file-name {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .file-size {
            font-size: 0.8em;
            color: #ccc;
        }
        
        .file-hash {
            font-size: 0.7em;
            color: #999;
            font-family: monospace;
            margin-top: 2px;
        }
        
        .file-progress {
            margin-top: 5px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .file-progress-bar {
            height: 100%;
            background: var(--success);
            transition: width 0.3s ease;
        }
        
        .download-btn {
            padding: 5px 10px;
            background: var(--success);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.8em;
        }
        
        .cancel-btn {
            padding: 5px 10px;
            background: var(--danger);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.8em;
            margin-left: 5px;
        }
        
        .input-area {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }
        
        .input-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .input-tools {
            display: flex;
            gap: 5px;
            align-items: center;
        }
        
        .tool-btn {
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background 0.3s;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .tool-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .tool-btn.recording {
            background: var(--danger);
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.6; }
            100% { opacity: 1; }
        }
        
        .message.voice {
            background: rgba(255, 165, 0, 0.3);
            border: 1px solid #ffa500;
        }
        
        .voice-message {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .voice-icon {
            font-size: 1.5em;
            color: #ffa500;
        }
        
        .voice-duration {
            font-size: 0.9em;
            color: #ccc;
        }
        
        .play-btn {
            padding: 8px 12px;
            background: #ffa500;
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1em;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .play-btn:hover {
            background: #ff8c00;
        }
        
        .voice-waveform {
            flex: 1;
            height: 30px;
            background: rgba(255, 165, 0, 0.2);
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8em;
        }
        
        textarea {
            flex: 1;
            padding: 12px;
            border-radius: 8px;
            border: none;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            resize: none;
            min-height: 60px;
        }
        
        .send-button {
            padding: 12px 20px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s;
            height: fit-content;
        }
        
        .send-button:hover {
            background: var(--secondary);
        }
        
        .send-button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 25px;
            border-radius: 8px;
            background: var(--success);
            color: white;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            transform: translateX(120%);
            transition: transform 0.3s ease;
            max-width: 300px;
        }
        
        .notification.show {
            transform: translateX(0);
        }
        
        .notification.error {
            background: var(--danger);
        }
        
        .notification.warning {
            background: var(--warning);
        }
        
        #fileInput, #imageInput, #videoInput {
            display: none;
        }
        
        .media-preview {
            max-width: 300px;
            max-height: 200px;
            border-radius: 8px;
            margin: 8px 0;
        }
        
        .video-preview {
            max-width: 300px;
            max-height: 200px;
            border-radius: 8px;
            margin: 8px 0;
        }
        
        .live-voice-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            padding: 10px;
            background: rgba(255, 165, 0, 0.2);
            border-radius: 8px;
            margin: 10px 0;
        }
        
        .live-voice-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--success);
            animation: pulse 1s infinite;
        }
        
        .live-voice-indicator.speaking {
            background: var(--danger);
        }
        
        .volume-meter {
            width: 100px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .volume-bar {
            height: 100%;
            background: var(--success);
            transition: width 0.1s ease;
        }
        
        .key-management {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .key-info {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 0.9em;
        }
        
        .key-id {
            word-break: break-all;
            font-family: monospace;
            font-size: 0.8em;
            color: #4ec9b0;
        }
        
        .key-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 10px;
        }
        
        .key-buttons button {
            padding: 8px 12px;
            font-size: 0.85em;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .key-buttons button:hover {
            background: var(--secondary);
        }
        
        .room-url {
            background: rgba(0, 0, 0, 0.3);
            padding: 8px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 0.8em;
            margin-bottom: 10px;
            word-break: break-all;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        
        .room-url:hover {
            background: rgba(0, 0, 0, 0.4);
        }
        
        .transfer-status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            min-width: 300px;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }
        
        .transfer-status.show {
            display: block;
        }
        
        .transfer-item {
            padding: 8px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            font-size: 0.9em;
        }
        
        .transfer-item:last-child {
            margin-bottom: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="panel manage-area">
            <div class="header">
                <h2>在线用户</h2>
                <div id="connectionStatus" class="connection-status status-disconnected">
                    未连接
                </div>
            </div>
            <div class="user-list" id="userList">
                <div style="text-align: center; color: #999; padding: 20px;">
                    等待连接...
                </div>
            </div>
            <div class="key-management">
                <h3>密钥管理</h3>
                <div class="key-info">
                    <div>你的密钥ID:</div>
                    <div id="keyId" class="key-id">未注册</div>
                </div>
                <div class="key-buttons">
                    <button id="importPublicKey">导入公钥</button>
                    <button id="importPrivateKey">导入私钥</button>
                    <button id="copyPublicKey">复制公钥</button>
                    <button id="generateKeys">生成密钥</button>
                </div>
            </div>
        </div>

        <div class="panel chat-area">
            <div class="header">
                <h2 id="roomName">实时文件传输聊天室</h2>
                <div class="room-url" id="roomUrl"></div>
                <div style="font-size: 0.8em; color: #ccc;">
                    支持 WebSocket 实时文件传输，文件完整性 MD5 验证
                </div>
            </div>
            
            <div class="messages" id="messages"></div>
            
            <div class="input-area">
                <div class="input-container">
                    <div class="input-tools">
                        <button class="tool-btn" id="fileBtn" title="发送文件">
                            📎 文件
                        </button>
                        <button class="tool-btn" id="imageBtn" title="发送图片">
                            🖼️ 图片
                        </button>
                        <button class="tool-btn" id="videoBtn" title="发送视频">
                            🎥 视频
                        </button>
                        <button class="tool-btn" id="voiceBtn" title="语音消息">
                            🎤 语音
                        </button>
                        <button class="tool-btn" id="liveVoiceBtn" title="实时语音">
                            📞 实时语音
                        </button>
                        <span id="voiceStatus" style="font-size: 0.8em; color: #ccc;"></span>
                    </div>
                    <textarea id="messageInput" placeholder="输入消息..." disabled></textarea>
                </div>
                <button class="send-button" id="sendButton" disabled>发送</button>
            </div>
            
            <input type="file" id="fileInput" multiple>
            <input type="file" id="imageInput" accept="image/*" multiple>
            <input type="file" id="videoInput" accept="video/*" multiple>
        </div>
    </div>
    
    <div class="notification" id="notification"></div>
    <div class="transfer-status" id="transferStatus">
        <h4>传输状态</h4>
        <div id="transferList"></div>
    </div>

    <script>
        // 全局变量
        let privateKey = '';
        let publicKey = '';
        let userId = '';
        let userName = '';
        let websocket = null;
        let roomId = '';
        let users = new Map();
        let fileTransferManager = null;
        let activeTransfers = new Map(); // transferId -> transfer info
        
        // 语音录制相关
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;
        let recordingStartTime = 0;
        
        // 实时语音相关
        let liveAudioStream = null;
        let liveAudioContext = null;
        let liveMediaRecorder = null;
        let isLiveVoiceActive = false;
        let volumeMeter = null;
        let liveVoiceInterval = null;
        
        // 音频播放相关
        let playbackAudioContext = null;
        let audioStreamBuffer = new Map(); // 按用户ID存储音频流
        let audioPlaybackQueue = new Map(); // 播放队列
        let isProcessingAudio = new Map(); // 处理状态
        let audioPlaybackTimers = new Map(); // 播放定时器
        
        // DOM元素
        const userListEl = document.getElementById('userList');
        const messagesEl = document.getElementById('messages');
        const messageInputEl = document.getElementById('messageInput');
        const sendButtonEl = document.getElementById('sendButton');
        const generateKeysBtn = document.getElementById('generateKeys');
        const importPublicKeyBtn = document.getElementById('importPublicKey');
        const importPrivateKeyBtn = document.getElementById('importPrivateKey');
        const copyPublicKeyBtn = document.getElementById('copyPublicKey');
        const keyIdEl = document.getElementById('keyId');
        const notificationEl = document.getElementById('notification');
        const connectionStatusEl = document.getElementById('connectionStatus');
        const fileInputEl = document.getElementById('fileInput');
        const imageInputEl = document.getElementById('imageInput');
        const videoInputEl = document.getElementById('videoInput');
        const fileBtnEl = document.getElementById('fileBtn');
        const imageBtnEl = document.getElementById('imageBtn');
        const videoBtnEl = document.getElementById('videoBtn');
        const voiceBtnEl = document.getElementById('voiceBtn');
        const liveVoiceBtnEl = document.getElementById('liveVoiceBtn');
        const voiceStatusEl = document.getElementById('voiceStatus');
        const transferStatusEl = document.getElementById('transferStatus');
        const transferListEl = document.getElementById('transferList');
        const roomUrlEl = document.getElementById('roomUrl');
        
        // WebSocket 文件传输管理器
        class FileTransferManager {
            constructor(websocket) {
                this.websocket = websocket;
                this.chunkSize = 64 * 1024; // 64KB chunks
                this.pendingTransfers = new Map(); // 存储待处理的传输请求
            }
            
            async initiateFileTransfer(targetUserId, file) {
                const transferId = this.generateTransferId();
                const fileHash = await this.calculateMD5(file);
                const totalChunks = Math.ceil(file.size / this.chunkSize);

                // 存储传输信息
                activeTransfers.set(transferId, {
                    type: 'send',
                    file: file,
                    targetUserId: targetUserId,
                    fileHash: fileHash,
                    totalChunks: totalChunks,
                    progress: 0,
                    status: 'requesting'
                });

                // 发送传输请求
                const transferRequest = {
                    type: 'fileTransferRequest',
                    transferId,
                    targetUserId,
                    metadata: {
                        fileName: file.name,
                        fileSize: file.size,
                        fileType: file.type,
                        fileHash,
                        totalChunks,
                        chunkSize: this.chunkSize
                    }
                };

                this.websocket.send(JSON.stringify(transferRequest));
                this.updateTransferStatus();
                
                displaySystemMessage(`正在请求向 ${getUserName(targetUserId)} 发送文件: ${file.name}`);
                return transferId;
            }
            
            handleTransferRequest(message) {
                const { transferId, senderId, metadata } = message;
                
                // 临时存储 metadata，用于后续创建接收会话
                this.pendingTransfers = this.pendingTransfers || new Map();
                this.pendingTransfers.set(transferId, { senderId, metadata });
                
                // 显示接收请求
                displayFileTransferRequest(senderId, transferId, metadata);
            }
            
            acceptTransfer(transferId, senderId) {
                // 获取待处理的传输信息
                const pendingTransfer = this.pendingTransfers?.get(transferId);
                if (!pendingTransfer) {
                    console.error('Pending transfer not found:', transferId);
                    return;
                }

                // 发送接受响应
                const response = {
                    type: 'fileTransferResponse',
                    transferId,
                    senderId,
                    accepted: true
                };

                this.websocket.send(JSON.stringify(response));
                
                // 创建接收会话，包含 metadata
                activeTransfers.set(transferId, {
                    type: 'receive',
                    senderId: senderId,
                    metadata: pendingTransfer.metadata,
                    receivedChunks: new Map(),
                    progress: 0,
                    status: 'receiving'
                });
                
                // 清理待处理的传输信息
                this.pendingTransfers.delete(transferId);
                
                this.updateTransferStatus();
                displaySystemMessage(`已接受来自 ${getUserName(senderId)} 的文件传输`);
            }
            
            rejectTransfer(transferId, senderId) {
                const response = {
                    type: 'fileTransferResponse',
                    transferId,
                    senderId,
                    accepted: false
                };

                this.websocket.send(JSON.stringify(response));
                
                // 清理待处理的传输信息
                if (this.pendingTransfers) {
                    this.pendingTransfers.delete(transferId);
                }
                
                displaySystemMessage(`已拒绝来自 ${getUserName(senderId)} 的文件传输`);
            }
            
            handleTransferResponse(message) {
                const transfer = activeTransfers.get(message.transferId);
                if (!transfer) return;

                if (message.accepted) {
                    transfer.status = 'sending';
                    this.startFileSending(transfer, message.transferId);
                    displaySystemMessage(`${getUserName(message.targetUserId)} 接受了文件传输`);
                } else {
                    activeTransfers.delete(message.transferId);
                    displaySystemMessage(`${getUserName(message.targetUserId)} 拒绝了文件传输`);
                }
                
                this.updateTransferStatus();
            }
            
            async startFileSending(transfer, transferId) {
                const file = transfer.file;
                const reader = new FileReader();
                let chunkIndex = 0;

                const sendNextChunk = () => {
                    if (chunkIndex >= transfer.totalChunks) {
                        transfer.status = 'completed';
                        transfer.progress = 100;
                        this.updateTransferStatus();
                        displaySystemMessage(`文件 "${file.name}" 发送完成`);
                        setTimeout(() => activeTransfers.delete(transferId), 5000);
                        return;
                    }

                    const start = chunkIndex * this.chunkSize;
                    const end = Math.min(start + this.chunkSize, file.size);
                    const chunk = file.slice(start, end);

                    reader.onload = (e) => {
                        if (e.target?.result) {
                            const chunkData = Array.from(new Uint8Array(e.target.result));
                            
                            const chunkMessage = {
                                type: 'realtimeFileChunk',
                                transferId: transferId,
                                targetUserId: transfer.targetUserId,
                                chunkIndex,
                                chunkData,
                                isLast: chunkIndex === transfer.totalChunks - 1
                            };

                            this.websocket.send(JSON.stringify(chunkMessage));
                            
                            chunkIndex++;
                            transfer.progress = (chunkIndex / transfer.totalChunks) * 100;
                            this.updateTransferStatus();
                            
                            setTimeout(sendNextChunk, 50);
                        }
                    };

                    reader.readAsArrayBuffer(chunk);
                };

                sendNextChunk();
            }
            
            handleFileChunk(message) {
                const transfer = activeTransfers.get(message.transferId);
                if (!transfer || transfer.type !== 'receive') return;

                const { chunkIndex, chunkData, isLast } = message;
                
                // 存储分片
                transfer.receivedChunks.set(chunkIndex, chunkData);
                transfer.progress = (transfer.receivedChunks.size / transfer.metadata.totalChunks) * 100;
                
                this.updateTransferStatus();

                // 检查是否接收完成
                if (transfer.receivedChunks.size === transfer.metadata.totalChunks) {
                    this.assembleReceivedFile(transfer, message.transferId);
                }
            }
            
            async assembleReceivedFile(transfer, transferId) {
                try {
                    const chunks = [];
                    
                    // 按顺序组装分片
                    for (let i = 0; i < transfer.metadata.totalChunks; i++) {
                        const chunkData = transfer.receivedChunks.get(i);
                        if (!chunkData) {
                            throw new Error(`Missing chunk ${i}`);
                        }
                        chunks.push(new Uint8Array(chunkData));
                    }

                    // 合并所有分片
                    const totalSize = chunks.reduce((size, chunk) => size + chunk.length, 0);
                    const fileData = new Uint8Array(totalSize);
                    let offset = 0;

                    for (const chunk of chunks) {
                        fileData.set(chunk, offset);
                        offset += chunk.length;
                    }

                    // 验证文件完整性
                    const receivedHash = await this.calculateMD5FromBuffer(fileData.buffer);
                    if (receivedHash !== transfer.metadata.fileHash) {
                        throw new Error('File integrity check failed');
                    }

                    // 创建文件对象
                    const blob = new Blob([fileData], { type: transfer.metadata.fileType });
                    const file = new File([blob], transfer.metadata.fileName, { 
                        type: transfer.metadata.fileType 
                    });

                    // 自动下载文件
                    this.downloadFile(file);
                    
                    transfer.status = 'completed';
                    transfer.progress = 100;
                    this.updateTransferStatus();
                    
                    displaySystemMessage(`文件 "${file.name}" 接收完成并已下载`);
                    displayFileMessage(transfer.senderId, file, 'received', transfer.metadata.fileHash);
                    
                    setTimeout(() => activeTransfers.delete(transferId), 5000);
                    
                } catch (error) {
                    console.error('File assembly failed:', error);
                    transfer.status = 'failed';
                    this.updateTransferStatus();
                    displaySystemMessage(`文件接收失败: ${error.message}`);
                }
            }
            
            downloadFile(file) {
                const url = URL.createObjectURL(file);
                const a = document.createElement('a');
                a.href = url;
                a.download = file.name;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
            
            cancelTransfer(transferId) {
                const transfer = activeTransfers.get(transferId);
                if (!transfer) return;

                const cancelMessage = {
                    type: 'fileTransferCancel',
                    transferId,
                    targetUserId: transfer.targetUserId || transfer.senderId
                };

                this.websocket.send(JSON.stringify(cancelMessage));
                activeTransfers.delete(transferId);
                this.updateTransferStatus();
                
                displaySystemMessage('文件传输已取消');
            }
            
            handleTransferCancel(message) {
                const transfer = activeTransfers.get(message.transferId);
                if (transfer) {
                    activeTransfers.delete(message.transferId);
                    this.updateTransferStatus();
                    displaySystemMessage(`${getUserName(message.senderId)} 取消了文件传输`);
                }
                
                // 清理待处理的传输信息
                if (this.pendingTransfers) {
                    this.pendingTransfers.delete(message.transferId);
                }
            }
            
            updateTransferStatus() {
                if (activeTransfers.size === 0) {
                    transferStatusEl.classList.remove('show');
                    return;
                }
                
                transferStatusEl.classList.add('show');
                transferListEl.innerHTML = '';
                
                activeTransfers.forEach((transfer, transferId) => {
                    const transferEl = document.createElement('div');
                    transferEl.className = 'transfer-item';
                    
                    const fileName = transfer.file ? transfer.file.name : transfer.metadata?.fileName || 'Unknown';
                    const peerName = getUserName(transfer.targetUserId || transfer.senderId);
                    const statusText = this.getStatusText(transfer.status);
                    
                    transferEl.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="font-weight: bold;">${fileName}</div>
                                <div style="font-size: 0.8em; color: #ccc;">
                                    ${transfer.type === 'send' ? '发送给' : '接收自'} ${peerName} - ${statusText}
                                </div>
                            </div>
                            ${transfer.status === 'requesting' || transfer.status === 'sending' || transfer.status === 'receiving' ? 
                                `<button onclick="fileTransferManager.cancelTransfer('${transferId}')" class="cancel-btn">取消</button>` : ''}
                        </div>
                        <div class="file-progress" style="margin-top: 5px;">
                            <div class="file-progress-bar" style="width: ${transfer.progress}%"></div>
                        </div>
                    `;
                    
                    transferListEl.appendChild(transferEl);
                });
            }
            
            getStatusText(status) {
                const statusMap = {
                    'requesting': '请求中',
                    'sending': '发送中',
                    'receiving': '接收中',
                    'completed': '已完成',
                    'failed': '失败'
                };
                return statusMap[status] || status;
            }
            
            async calculateMD5(file) {
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        if (e.target?.result) {
                            const hash = await this.calculateMD5FromBuffer(e.target.result);
                            resolve(hash);
                        }
                    };
                    reader.readAsArrayBuffer(file);
                });
            }
            
            async calculateMD5FromBuffer(buffer) {
                const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            }
            
            generateTransferId() {
                return Date.now().toString(36) + Math.random().toString(36).substr(2);
            }
        }
        
        // 初始化
        async function init() {
            roomId = getRoomIdFromUrl();
            
            // 从本地存储加载密钥
            loadKeysFromStorage();
            
            // 连接 WebSocket
            connectWebSocket();
            
            // 初始化语音功能
            initVoiceSupport();
            
            // 初始化音频播放上下文（需要用户交互）
            initAudioContextOnUserInteraction();
            
            // 绑定事件
            bindEvents();
            
            // 显示房间链接
            displayRoomUrl();
        }
        
        function bindEvents() {
            sendButtonEl.addEventListener('click', sendMessage);
            messageInputEl.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });
            
            generateKeysBtn.addEventListener('click', generateKeys);
            importPublicKeyBtn.addEventListener('click', importPublicKey);
            importPrivateKeyBtn.addEventListener('click', importPrivateKey);
            copyPublicKeyBtn.addEventListener('click', copyPublicKey);
            
            fileBtnEl.addEventListener('click', () => fileInputEl.click());
            imageBtnEl.addEventListener('click', () => imageInputEl.click());
            videoBtnEl.addEventListener('click', () => videoInputEl.click());
            fileInputEl.addEventListener('change', handleFileSelect);
            imageInputEl.addEventListener('change', handleImageSelect);
            videoInputEl.addEventListener('change', handleVideoSelect);
            voiceBtnEl.addEventListener('click', toggleVoiceRecording);
            liveVoiceBtnEl.addEventListener('click', toggleLiveVoice);
        }
        
        function getRoomIdFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('room') || generateRoomId();
        }
        
        function generateRoomId() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            let result = '';
            for (let i = 0; i < 64; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }
        
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/api/room/${roomId}/websocket`;
            
            websocket = new WebSocket(wsUrl);
            
            websocket.onopen = () => {
                connectionStatusEl.textContent = '已连接';
                connectionStatusEl.className = 'connection-status status-connected';
                
                // 初始化文件传输管理器
                fileTransferManager = new FileTransferManager(websocket);
                
                if (publicKey) {
                    registerUser();
                }
            };
            
            websocket.onmessage = (event) => {
                const message = JSON.parse(event.data);
                handleWebSocketMessage(message);
            };
            
            websocket.onclose = () => {
                connectionStatusEl.textContent = '连接断开';
                connectionStatusEl.className = 'connection-status status-disconnected';
                
                // 尝试重连
                setTimeout(connectWebSocket, 3000);
            };
            
            websocket.onerror = (error) => {
                console.error('WebSocket error:', error);
                showNotification('连接错误', 'error');
            };
        }
        
        function handleWebSocketMessage(message) {
            switch (message.type) {
                case 'registered':
                    handleRegistered(message);
                    break;
                case 'userList':
                    handleUserList(message);
                    break;
                case 'encryptedMessage':
                    handleEncryptedMessage(message);
                    break;
                case 'fileTransferRequestNotification':
                    fileTransferManager.handleTransferRequest(message);
                    break;
                case 'fileTransferResponseNotification':
                    fileTransferManager.handleTransferResponse(message);
                    break;
                case 'realtimeFileChunkNotification':
                    fileTransferManager.handleFileChunk(message);
                    break;
                case 'fileTransferCancelNotification':
                    fileTransferManager.handleTransferCancel(message);
                    break;
                case 'voiceNotification':
                    handleVoiceMessage(message);
                    break;
                case 'liveAudioNotification':
                    handleLiveAudio(message);
                    break;
                case 'error':
                    showNotification(message.message, 'error');
                    break;
            }
        }
        
        function handleRegistered(message) {
            userId = message.profile.id;
            userName = message.profile.name;
            
            messageInputEl.disabled = false;
            sendButtonEl.disabled = false;
            
            showNotification('注册成功');
            
            // 请求用户列表
            websocket.send(JSON.stringify({ type: 'getUsers' }));
        }
        
        function handleUserList(message) {
            users.clear();
            message.users.forEach(user => {
                users.set(user.id, user);
            });
            updateUserList();
        }
        
        function updateUserList() {
            userListEl.innerHTML = '';
            
            users.forEach((user, id) => {
                const userEl = document.createElement('div');
                userEl.className = `user-item ${id === userId ? 'self' : ''}`;
                
                userEl.innerHTML = `
                    <div class="user-name">${user.name}</div>
                    <div class="user-id">${user.id}</div>
                    ${id !== userId ? `
                        <button class="file-transfer-btn" onclick="selectFileForUser('${id}')">
                            发送文件
                        </button>
                    ` : ''}
                `;
                
                userListEl.appendChild(userEl);
            });
        }
        
        function selectFileForUser(peerId) {
            const input = document.createElement('input');
            input.type = 'file';
            input.multiple = true;
            input.onchange = (e) => {
                const files = Array.from(e.target.files);
                files.forEach(file => sendFileToUser(peerId, file));
            };
            input.click();
        }
        
        async function sendFileToUser(peerId, file) {
            if (!fileTransferManager) {
                showNotification('文件传输管理器未初始化', 'error');
                return;
            }
            
            try {
                await fileTransferManager.initiateFileTransfer(peerId, file);
            } catch (error) {
                console.error('Failed to send file:', error);
                showNotification(`文件发送失败: ${error.message}`, 'error');
            }
        }
        
        function handleFileSelect(event) {
            const files = Array.from(event.target.files);
            if (files.length === 0) return;
            
            // 如果只有一个在线用户（除了自己），直接发送
            const otherUsers = Array.from(users.keys()).filter(id => id !== userId);
            if (otherUsers.length === 1) {
                files.forEach(file => sendFileToUser(otherUsers[0], file));
            } else if (otherUsers.length > 1) {
                // 让用户选择发送给谁
                const userNames = otherUsers.map(id => `${id}: ${getUserName(id)}`).join('\n');
                const selectedUserId = prompt(`选择发送给哪个用户:\n${userNames}\n\n请输入用户ID:`);
                if (selectedUserId && users.has(selectedUserId)) {
                    files.forEach(file => sendFileToUser(selectedUserId, file));
                }
            } else {
                showNotification('没有其他在线用户', 'warning');
            }
            
            // 清空文件输入
            event.target.value = '';
        }
        
        function handleImageSelect(event) {
            const files = Array.from(event.target.files);
            if (files.length === 0) return;
            
            files.forEach(file => {
                if (file.type.startsWith('image/')) {
                    sendMediaFile(file, 'image');
                } else {
                    showNotification('请选择图片文件', 'error');
                }
            });
            
            event.target.value = '';
        }
        
        function handleVideoSelect(event) {
            const files = Array.from(event.target.files);
            if (files.length === 0) return;
            
            files.forEach(file => {
                if (file.type.startsWith('video/')) {
                    sendMediaFile(file, 'video');
                } else {
                    showNotification('请选择视频文件', 'error');
                }
            });
            
            event.target.value = '';
        }
        
        function sendMediaFile(file, mediaType) {
            // 如果只有一个在线用户（除了自己），直接发送
            const otherUsers = Array.from(users.keys()).filter(id => id !== userId);
            if (otherUsers.length === 1) {
                sendFileToUser(otherUsers[0], file);
                displayMediaMessage(userId, file, mediaType, 'sent');
            } else if (otherUsers.length > 1) {
                // 让用户选择发送给谁
                const userNames = otherUsers.map(id => `${id}: ${getUserName(id)}`).join('\n');
                const selectedUserId = prompt(`选择发送给哪个用户:\n${userNames}\n\n请输入用户ID:`);
                if (selectedUserId && users.has(selectedUserId)) {
                    sendFileToUser(selectedUserId, file);
                    displayMediaMessage(userId, file, mediaType, 'sent');
                }
            } else {
                showNotification('没有其他在线用户', 'warning');
            }
        }
        
        function displayMediaMessage(senderId, file, mediaType, direction) {
            const messageEl = document.createElement('div');
            messageEl.className = `message ${direction}`;
            
            const senderInfo = users.get(senderId) || { name: senderId.slice(24, 40) };
            const timestamp = new Date().toLocaleTimeString();
            
            let mediaContent = '';
            const fileUrl = URL.createObjectURL(file);
            
            if (mediaType === 'image') {
                mediaContent = `
                    <img src="${fileUrl}" alt="${file.name}" class="media-preview" onclick="openMediaFullscreen('${fileUrl}', 'image')">
                    <div style="font-size: 0.8em; margin-top: 5px;">${file.name} (${formatFileSize(file.size)})</div>
                `;
            } else if (mediaType === 'video') {
                mediaContent = `
                    <video controls class="video-preview" onclick="openMediaFullscreen('${fileUrl}', 'video')">
                        <source src="${fileUrl}" type="${file.type}">
                        您的浏览器不支持视频播放
                    </video>
                    <div style="font-size: 0.8em; margin-top: 5px;">${file.name} (${formatFileSize(file.size)})</div>
                `;
            }
            
            messageEl.innerHTML = `
                <div class="sender-info">
                    <span class="sender-name">${senderInfo.name}</span>
                    <span class="message-time">${timestamp}</span>
                </div>
                ${mediaContent}
            `;
            
            messagesEl.appendChild(messageEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }
        
        function openMediaFullscreen(url, type) {
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.9);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
                cursor: pointer;
            `;
            
            let mediaElement;
            if (type === 'image') {
                mediaElement = document.createElement('img');
                mediaElement.src = url;
                mediaElement.style.cssText = 'max-width: 90%; max-height: 90%; object-fit: contain;';
            } else if (type === 'video') {
                mediaElement = document.createElement('video');
                mediaElement.src = url;
                mediaElement.controls = true;
                mediaElement.style.cssText = 'max-width: 90%; max-height: 90%;';
            }
            
            overlay.appendChild(mediaElement);
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    document.body.removeChild(overlay);
                    URL.revokeObjectURL(url);
                }
            });
            
            document.body.appendChild(overlay);
        }
        
        function displayFileTransferRequest(senderId, transferId, metadata) {
            const messageEl = document.createElement('div');
            messageEl.className = 'message system';
            
            messageEl.innerHTML = `
                <div style="margin-bottom: 10px;">
                    <strong>${getUserName(senderId)}</strong> 想要发送文件:
                </div>
                <div class="file-message">
                    <div class="file-icon">📄</div>
                    <div class="file-info">
                        <div class="file-name">${metadata.fileName}</div>
                        <div class="file-size">${formatFileSize(metadata.fileSize)}</div>
                        <div class="file-hash">MD5: ${metadata.fileHash.substring(0, 16)}...</div>
                    </div>
                    <div>
                        <button class="download-btn" onclick="fileTransferManager.acceptTransfer('${transferId}', '${senderId}')">
                            接受
                        </button>
                        <button class="cancel-btn" onclick="fileTransferManager.rejectTransfer('${transferId}', '${senderId}')">
                            拒绝
                        </button>
                    </div>
                </div>
            `;
            
            messagesEl.appendChild(messageEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }
        
        function displayFileMessage(senderId, file, type, fileHash) {
            const messageEl = document.createElement('div');
            messageEl.className = `message ${type} file`;
            
            const senderName = getUserName(senderId);
            
            messageEl.innerHTML = `
                <div class="sender-info">
                    <span class="sender-name">${senderName}</span>
                    <span class="message-time">${new Date().toLocaleTimeString()}</span>
                </div>
                <div class="file-message">
                    <div class="file-icon">📄</div>
                    <div class="file-info">
                        <div class="file-name">${file.name}</div>
                        <div class="file-size">${formatFileSize(file.size)}</div>
                        ${fileHash ? `<div class="file-hash">MD5: ${fileHash.substring(0, 16)}...</div>` : ''}
                    </div>
                    ${type === 'received' ? '<div style="color: var(--success);">✓ 已下载</div>' : ''}
                </div>
            `;
            
            messagesEl.appendChild(messageEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }
        
        function displaySystemMessage(text) {
            const messageEl = document.createElement('div');
            messageEl.className = 'message system';
            messageEl.innerHTML = `
                <div>${text}</div>
                <div class="message-time">${new Date().toLocaleTimeString()}</div>
            `;
            
            messagesEl.appendChild(messageEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }
        
        function getUserName(userId) {
            const user = users.get(userId);
            return user ? user.name : userId;
        }
        
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        // 其他必要的函数（密钥管理、消息发送等）
        function loadKeysFromStorage() {
            privateKey = localStorage.getItem('privateKey') || '';
            publicKey = localStorage.getItem('publicKey') || '';
            
            if (publicKey) {
                extractUserProfile(publicKey).then(profile => {
                    userId = profile.id;
                    userName = profile.name;
                    keyIdEl.textContent = userId;
                    
                    if (websocket && websocket.readyState === WebSocket.OPEN) {
                        registerUser();
                    }
                });
            }
        }
        
        function registerUser() {
            if (!publicKey) return;
            
            const registerMessage = {
                type: 'register',
                publicKey: publicKey
            };
            
            websocket.send(JSON.stringify(registerMessage));
        }
        
        async function generateKeys() {
            try {
                const name = prompt('请输入您的姓名:') || 'Anonymous';
                
                const { privateKey: privKey, publicKey: pubKey } = await openpgp.generateKey({
                    type: 'ecc',
                    curve: 'curve25519',
                    userIDs: [{ name: name }],
                    passphrase: '',
                    format: 'armored'
                });
                
                privateKey = privKey;
                publicKey = pubKey;
                
                localStorage.setItem('privateKey', privateKey);
                localStorage.setItem('publicKey', publicKey);
                
                const profile = await extractUserProfile(publicKey);
                userId = profile.id;
                userName = profile.name;
                keyIdEl.textContent = userId;
                
                showNotification('密钥生成成功');
                
                if (websocket && websocket.readyState === WebSocket.OPEN) {
                    registerUser();
                }
            } catch (error) {
                showNotification('密钥生成失败: ' + error.message, 'error');
            }
        }
        
        async function extractUserProfile(publicKeyArmored) {
            try {
                const publicKeyObj = await openpgp.readKey({ armoredKey: publicKeyArmored });
                const primaryUser = await publicKeyObj.getPrimaryUser();
                const userID = primaryUser.user.userID;
                
                let name = '';
                let email = '';
                let id = '';
                
                if (userID) {
                    const userIdString = userID.userID || '';
                    const match = userIdString.match(/^(.+?)\s*<([^>]+)>$/);
                    
                    if (match) {
                        name = match[1].trim();
                        email = match[2].trim();
                    } else {
                        if (userIdString.includes('@')) {
                            email = userIdString.trim();
                            name = email.split('@')[0];
                        } else {
                            name = userIdString.trim();
                        }
                    }
                }
                
                id = publicKeyObj.getFingerprint().toUpperCase();
                
                if (!name) {
                    name = `User_${Math.random().toString(36).substr(2, 8)}`;
                }
                if (!email) {
                    email = `${name.toLowerCase().replace(/\s+/g, '')}@example.com`;
                }
                
                return { id, name, email };
                
            } catch (error) {
                console.error('解析公钥时出错:', error);
                return {
                    id: Math.random().toString(36).substr(2, 8),
                    name: 'Unknown User',
                    email: 'unknown@example.com'
                };
            }
        }
        
        function importPublicKey() {
            const key = prompt('请粘贴公钥:');
            if (key && key.includes('-----BEGIN PGP PUBLIC KEY BLOCK-----')) {
                publicKey = key;
                localStorage.setItem('publicKey', publicKey);
                
                extractUserProfile(publicKey).then(profile => {
                    userId = profile.id;
                    userName = profile.name;
                    keyIdEl.textContent = userId;
                    
                    showNotification('公钥导入成功');
                    
                    if (websocket && websocket.readyState === WebSocket.OPEN) {
                        registerUser();
                    }
                });
            } else {
                showNotification('无效的公钥格式', 'error');
            }
        }
        
        function importPrivateKey() {
            const key = prompt('请粘贴私钥:');
            if (key && key.includes('-----BEGIN PGP PRIVATE KEY BLOCK-----')) {
                privateKey = key;
                localStorage.setItem('privateKey', privateKey);
                showNotification('私钥导入成功');
            } else {
                showNotification('无效的私钥格式', 'error');
            }
        }
        
        function copyPublicKey() {
            if (publicKey) {
                navigator.clipboard.writeText(publicKey).then(() => {
                    showNotification('公钥已复制到剪贴板');
                });
            } else {
                showNotification('没有可复制的公钥', 'warning');
            }
        }
        
        async function sendMessage() {
            const text = messageInputEl.value.trim();
            if (!text || !publicKey) return;
            
            try {
                const encryptedData = await encryptForAllUsers(text);
                
                const message = {
                    type: 'message',
                    encryptedData: encryptedData
                };
                
                websocket.send(JSON.stringify(message));
                messageInputEl.value = '';
                
            } catch (error) {
                showNotification('消息发送失败: ' + error.message, 'error');
            }
        }
        
        async function encryptForAllUsers(data) {
            const publicKeys = Array.from(users.values()).map(user => user.publicKey);
            
            if (publicKeys.length === 0) {
                throw new Error('没有可用的公钥');
            }
            
            const keys = await Promise.all(
                publicKeys.map(key => openpgp.readKey({ armoredKey: key }))
            );
            
            let message;
            if (typeof data === 'string') {
                message = await openpgp.createMessage({ text: data });
            } else {
                // 处理二进制数据（如语音）
                message = await openpgp.createMessage({ binary: data });
            }
            
            const encrypted = await openpgp.encrypt({
                message: message,
                encryptionKeys: keys,
                format: 'armored'
            });
            
            return encrypted;
        }
        
        async function decryptMessage(encryptedData) {
            if (!privateKey) {
                throw new Error('私钥未设置');
            }
            
            try {
                const encryptedMessage = await openpgp.readMessage({
                    armoredMessage: encryptedData
                });
                
                const privKey = await openpgp.readPrivateKey({
                    armoredKey: privateKey
                });
                
                const { data: decrypted } = await openpgp.decrypt({
                    message: encryptedMessage,
                    decryptionKeys: privKey,
                    format: 'binary'
                });
                
                return decrypted;
                
            } catch (error) {
                console.error('解密失败:', error);
                throw error;
            }
        }
        
        async function handleEncryptedMessage(message) {
            if (!privateKey) {
                displayEncryptedMessage(message);
                return;
            }
            
            try {
                const encryptedMessage = await openpgp.readMessage({
                    armoredMessage: message.encryptedData
                });
                
                const privKey = await openpgp.readPrivateKey({
                    armoredKey: privateKey
                });
                
                const { data: decrypted } = await openpgp.decrypt({
                    message: encryptedMessage,
                    decryptionKeys: privKey
                });
                
                displayMessage(message.senderId, decrypted, message.timestamp);
                
            } catch (error) {
                console.error('解密失败:', error);
                displayEncryptedMessage(message);
            }
        }
        
        function displayMessage(senderId, text, timestamp) {
            const messageEl = document.createElement('div');
            messageEl.className = `message ${senderId === userId ? 'sent' : 'received'}`;
            
            const senderName = getUserName(senderId);
            const time = new Date(timestamp).toLocaleTimeString();
            
            messageEl.innerHTML = `
                <div class="sender-info">
                    <span class="sender-name">${senderName}</span>
                    <span class="message-time">${time}</span>
                </div>
                <div class="message-text">${text}</div>
            `;
            
            messagesEl.appendChild(messageEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }
        
        function displayEncryptedMessage(message) {
            const messageEl = document.createElement('div');
            messageEl.className = 'message received encrypted';
            
            const senderName = getUserName(message.senderId);
            const time = new Date(message.timestamp).toLocaleTimeString();
            
            messageEl.innerHTML = `
                <div class="sender-info">
                    <span class="sender-name">${senderName}</span>
                    <span class="message-time">${time}</span>
                </div>
                <div class="message-text">🔒 加密消息 (需要私钥解密)</div>
            `;
            
            messagesEl.appendChild(messageEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }
        
        function showNotification(message, type = 'success') {
            notificationEl.textContent = message;
            notificationEl.className = `notification ${type}`;
            notificationEl.classList.add('show');
            
            setTimeout(() => {
                notificationEl.classList.remove('show');
            }, 3000);
        }
        
        // 显示房间链接
        function displayRoomUrl() {
            // 构建包含房间ID的完整URL
            const baseUrl = window.location.origin + window.location.pathname;
            const roomUrl = `${baseUrl}?room=${roomId}`;
            
            roomUrlEl.textContent = roomUrl;
            roomUrlEl.title = '点击复制房间链接';
            roomUrlEl.addEventListener('click', () => {
                navigator.clipboard.writeText(roomUrl).then(() => {
                    showNotification('房间链接已复制到剪贴板');
                }).catch(err => {
                    showNotification('复制失败: ' + err.message, 'error');
                });
            });
        }
        
        // 初始化语音功能
        async function initVoiceSupport() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                
                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'audio/webm;codecs=opus'
                });
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    await sendVoiceMessage(audioBlob);
                    audioChunks = [];
                };
                
                voiceBtnEl.disabled = false;
                console.log('语音功能初始化完成');
                
            } catch (error) {
                console.log(`语音功能初始化失败: ${error.message}`);
                voiceBtnEl.disabled = true;
                voiceStatusEl.textContent = '麦克风权限被拒绝';
            }
        }
        
        // 开始/停止录音
        function toggleVoiceRecording() {
            if (!mediaRecorder) {
                showNotification('语音功能未初始化', 'error');
                return;
            }
            
            if (!publicKey) {
                showNotification('请先导入或生成密钥', 'warning');
                return;
            }
            
            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        }
        
        function startRecording() {
            if (mediaRecorder && mediaRecorder.state === 'inactive') {
                audioChunks = [];
                mediaRecorder.start();
                isRecording = true;
                recordingStartTime = Date.now();
                
                voiceBtnEl.classList.add('recording');
                voiceBtnEl.textContent = '🔴 停止';
                voiceStatusEl.textContent = '正在录音...';
                
                showNotification('开始录音，再次点击停止');
            }
        }
        
        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                isRecording = false;
                
                voiceBtnEl.classList.remove('recording');
                voiceBtnEl.textContent = '🎤 语音';
                voiceStatusEl.textContent = '处理中...';
            }
        }
        
        async function sendVoiceMessage(audioBlob) {
            try {
                const duration = Math.round((Date.now() - recordingStartTime) / 1000);
                const voiceId = generateId();
                
                // 读取音频数据
                const arrayBuffer = await audioBlob.arrayBuffer();
                const audioData = new Uint8Array(arrayBuffer);
                
                // 加密语音数据
                const encryptedVoiceData = await encryptForAllUsers(audioData);
                
                const voiceMetadata = {
                    voiceId: voiceId,
                    duration: duration,
                    sampleRate: 48000,
                    format: 'webm'
                };
                
                const voiceMessage = {
                    type: 'voice',
                    metadata: voiceMetadata,
                    encryptedVoiceData: encryptedVoiceData
                };
                
                if (websocket && websocket.readyState === WebSocket.OPEN) {
                    websocket.send(JSON.stringify(voiceMessage));
                }
                
                voiceStatusEl.textContent = '';
                showNotification(`语音消息发送成功 (${duration}秒)`);
                
            } catch (error) {
                console.error('语音消息发送失败:', error);
                voiceStatusEl.textContent = '';
                showNotification('语音消息发送失败: ' + error.message, 'error');
            }
        }
        
        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        }
        
        async function handleVoiceMessage(message) {
            if (!privateKey) {
                displayEncryptedVoiceMessage(message);
                return;
            }
            
            try {
                // 解密语音数据
                const encryptedMessage = await openpgp.readMessage({
                    armoredMessage: message.encryptedVoiceData
                });
                
                const privKey = await openpgp.readPrivateKey({
                    armoredKey: privateKey
                });
                
                const { data: decrypted } = await openpgp.decrypt({
                    message: encryptedMessage,
                    decryptionKeys: privKey,
                    format: 'binary'
                });
                
                // 创建音频 Blob
                const audioBlob = new Blob([decrypted], { type: 'audio/webm' });
                const audioUrl = URL.createObjectURL(audioBlob);
                
                displayVoiceMessage(message.senderId, message.metadata, audioUrl, message.timestamp);
                
            } catch (error) {
                console.error('语音消息解密失败:', error);
                displayEncryptedVoiceMessage(message);
            }
        }
        
        function displayVoiceMessage(senderId, metadata, audioUrl, timestamp) {
            const messageEl = document.createElement('div');
            messageEl.className = `message ${senderId === userId ? 'sent' : 'received'} voice`;
            
            const senderName = getUserName(senderId);
            const time = new Date(timestamp).toLocaleTimeString();
            
            messageEl.innerHTML = `
                <div class="sender-info">
                    <span class="sender-name">${senderName}</span>
                    <span class="message-time">${time}</span>
                </div>
                <div class="voice-message">
                    <div class="voice-icon">🎵</div>
                    <div class="voice-waveform">
                        语音消息 ${metadata.duration}秒
                    </div>
                    <button class="play-btn" onclick="playVoiceMessage('${audioUrl}')">
                        ▶️
                    </button>
                </div>
            `;
            
            messagesEl.appendChild(messageEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }
        
        function displayEncryptedVoiceMessage(message) {
            const messageEl = document.createElement('div');
            messageEl.className = 'message received voice';
            
            const senderName = getUserName(message.senderId);
            const time = new Date(message.timestamp).toLocaleTimeString();
            
            messageEl.innerHTML = `
                <div class="sender-info">
                    <span class="sender-name">${senderName}</span>
                    <span class="message-time">${time}</span>
                </div>
                <div class="voice-message">
                    <div class="voice-icon">🔒</div>
                    <div class="voice-waveform">
                        加密语音消息 (需要私钥解密)
                    </div>
                </div>
            `;
            
            messagesEl.appendChild(messageEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }
        
        function playVoiceMessage(audioUrl) {
            const audio = new Audio(audioUrl);
            audio.play().catch(error => {
                console.error('播放语音失败:', error);
                showNotification('播放语音失败', 'error');
            });
        }
        
        // 实时语音功能
        async function toggleLiveVoice() {
            if (isLiveVoiceActive) {
                stopLiveVoice();
            } else {
                await startLiveVoice();
            }
        }
        
        async function startLiveVoice() {
            try {
                liveAudioStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: 16000
                    } 
                });
                
                liveAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = liveAudioContext.createMediaStreamSource(liveAudioStream);
                
                // 创建音量检测器
                const analyser = liveAudioContext.createAnalyser();
                analyser.fftSize = 256;
                source.connect(analyser);
                
                // 创建媒体录制器用于实时传输
                liveMediaRecorder = new MediaRecorder(liveAudioStream, {
                    mimeType: 'audio/webm;codecs=opus'
                });
                
                liveMediaRecorder.ondataavailable = async (event) => {
                    if (event.data.size > 0) {
                        // 立即发送每个音频块，减少延迟
                        await sendLiveAudioChunk(event.data);
                    }
                };
                
                // 开始录制，每200ms产生一个数据块，减少延迟
                liveMediaRecorder.start(200);
                
                isLiveVoiceActive = true;
                liveVoiceBtnEl.textContent = '📞 停止实时语音';
                liveVoiceBtnEl.style.background = 'var(--danger)';
                
                // 显示实时语音控制界面
                showLiveVoiceControls();
                
                // 开始音量监测
                startVolumeMonitoring(analyser);
                
                showNotification('实时语音已开启');
                
            } catch (error) {
                console.error('启动实时语音失败:', error);
                showNotification('启动实时语音失败: ' + error.message, 'error');
            }
        }
        
        function stopLiveVoice() {
            if (liveAudioStream) {
                liveAudioStream.getTracks().forEach(track => track.stop());
                liveAudioStream = null;
            }
            
            if (liveAudioContext) {
                liveAudioContext.close();
                liveAudioContext = null;
            }
            
            if (liveMediaRecorder && liveMediaRecorder.state !== 'inactive') {
                liveMediaRecorder.stop();
                liveMediaRecorder = null;
            }
            
            if (liveVoiceInterval) {
                clearInterval(liveVoiceInterval);
                liveVoiceInterval = null;
            }
            
            isLiveVoiceActive = false;
            liveVoiceBtnEl.textContent = '📞 实时语音';
            
            // 清理所有音频流
            cleanupAllAudioStreams();
            
            // 清理音频指示器
            if (audioIndicatorElement && audioIndicatorElement.parentNode) {
                audioIndicatorElement.parentNode.removeChild(audioIndicatorElement);
                audioIndicatorElement = null;
            }
            if (audioIndicatorTimeout) {
                clearTimeout(audioIndicatorTimeout);
                audioIndicatorTimeout = null;
            }
            liveVoiceBtnEl.style.background = '';
            
            // 隐藏实时语音控制界面
            hideLiveVoiceControls();
            
            showNotification('实时语音已关闭');
        }
        
        async function sendLiveAudioChunk(audioBlob) {
            try {
                const arrayBuffer = await audioBlob.arrayBuffer();
                const audioData = new Uint8Array(arrayBuffer);
                
                // 加密音频数据
                const encryptedAudioData = await encryptForAllUsers(audioData);
                
                const liveAudioMessage = {
                    type: 'liveAudio',
                    encryptedAudioData: encryptedAudioData,
                    timestamp: Date.now()
                };
                
                if (websocket && websocket.readyState === WebSocket.OPEN) {
                    websocket.send(JSON.stringify(liveAudioMessage));
                }
                
            } catch (error) {
                console.error('发送实时音频失败:', error);
            }
        }
        
        function showLiveVoiceControls() {
            const controlsEl = document.createElement('div');
            controlsEl.id = 'liveVoiceControls';
            controlsEl.className = 'live-voice-controls';
            controlsEl.innerHTML = `
                <div class="live-voice-indicator" id="liveVoiceIndicator"></div>
                <span>实时语音通话中</span>
                <div class="volume-meter">
                    <div class="volume-bar" id="volumeBar"></div>
                </div>
            `;
            
            // 插入到输入区域上方
            const inputArea = document.querySelector('.input-area');
            inputArea.parentNode.insertBefore(controlsEl, inputArea);
        }
        
        function hideLiveVoiceControls() {
            const controlsEl = document.getElementById('liveVoiceControls');
            if (controlsEl) {
                controlsEl.remove();
            }
        }
        
        function startVolumeMonitoring(analyser) {
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            
            liveVoiceInterval = setInterval(() => {
                analyser.getByteFrequencyData(dataArray);
                
                // 计算平均音量
                let sum = 0;
                for (let i = 0; i < bufferLength; i++) {
                    sum += dataArray[i];
                }
                const average = sum / bufferLength;
                const volume = (average / 255) * 100;
                
                // 更新音量条
                const volumeBar = document.getElementById('volumeBar');
                const indicator = document.getElementById('liveVoiceIndicator');
                
                if (volumeBar) {
                    volumeBar.style.width = volume + '%';
                }
                
                if (indicator) {
                    if (volume > 10) {
                        indicator.classList.add('speaking');
                    } else {
                        indicator.classList.remove('speaking');
                    }
                }
                
            }, 100);
        }
        
        // 初始化音频播放上下文
        async function initPlaybackAudioContext() {
            if (!playbackAudioContext) {
                playbackAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // 如果上下文被暂停，尝试恢复
                if (playbackAudioContext.state === 'suspended') {
                    await playbackAudioContext.resume();
                }
            }
            return playbackAudioContext;
        }
        
        // 在用户交互时初始化音频上下文
        function initAudioContextOnUserInteraction() {
            const initOnClick = async () => {
                try {
                    await initPlaybackAudioContext();
                    console.log('音频上下文已初始化');
                    
                    // 移除事件监听器，只需要初始化一次
                    document.removeEventListener('click', initOnClick);
                    document.removeEventListener('keydown', initOnClick);
                    document.removeEventListener('touchstart', initOnClick);
                } catch (error) {
                    console.error('音频上下文初始化失败:', error);
                }
            };
            
            // 监听用户交互事件
            document.addEventListener('click', initOnClick);
            document.addEventListener('keydown', initOnClick);
            document.addEventListener('touchstart', initOnClick);
        }
        
        // 处理接收到的实时音频
        async function handleLiveAudio(message) {
            if (!privateKey) {
                return;
            }
            
            try {
                // 解密音频数据
                const decryptedData = await decryptMessage(message.encryptedAudioData);
                const audioData = new Uint8Array(decryptedData);
                
                console.log(`接收到音频数据: ${audioData.length} 字节`);
                
                // 处理实际音频播放 - 不等待播放完成，避免阻塞后续音频
                processRealAudioPlayback(message.senderId, audioData).catch(error => {
                    console.error('音频播放异步处理失败:', error);
                });
                
                // 显示音频接收指示器
                showAudioReceiveIndicator();
                
            } catch (error) {
                console.error('处理实时音频失败:', error);
            }
        }
        
        // 处理实际音频播放
        async function processRealAudioPlayback(senderId, audioData) {
            try {
                // 使用智能缓冲播放策略
                await smartBufferedPlayback(senderId, audioData);
                
            } catch (error) {
                console.error('处理音频播放失败:', error);
            }
        }
        
        // 智能缓冲播放
        async function smartBufferedPlayback(senderId, audioData) {
            try {
                // 初始化用户的音频缓冲区
                if (!audioStreamBuffer.has(senderId)) {
                    audioStreamBuffer.set(senderId, {
                        chunks: [],
                        totalSize: 0,
                        lastChunkTime: Date.now(),
                        isPlaying: false,
                        playbackStarted: false
                    });
                }
                
                const buffer = audioStreamBuffer.get(senderId);
                buffer.chunks.push(audioData);
                buffer.totalSize += audioData.length;
                buffer.lastChunkTime = Date.now();
                
                console.log(`缓冲音频: ${audioData.length} 字节，总计 ${buffer.totalSize} 字节，${buffer.chunks.length} 块`);
                
                // 策略：累积足够的数据后开始播放，或者等待超时
                const minBufferSize = 12000; // 最小12KB，确保有足够的音频数据
                const maxWaitTime = 500; // 最大等待500ms
                const timeSinceLastChunk = Date.now() - buffer.lastChunkTime;
                
                if (!buffer.isPlaying && !buffer.playbackStarted) {
                    if (buffer.totalSize >= minBufferSize || timeSinceLastChunk > maxWaitTime) {
                        buffer.isPlaying = true;
                        buffer.playbackStarted = true;
                        attemptBufferedPlayback(senderId);
                    } else {
                        // 设置超时播放
                        setTimeout(() => {
                            if (audioStreamBuffer.has(senderId)) {
                                const currentBuffer = audioStreamBuffer.get(senderId);
                                if (!currentBuffer.isPlaying && currentBuffer.chunks.length > 0) {
                                    currentBuffer.isPlaying = true;
                                    currentBuffer.playbackStarted = true;
                                    attemptBufferedPlayback(senderId);
                                }
                            }
                        }, maxWaitTime);
                    }
                }
                
            } catch (error) {
                console.error('智能缓冲播放失败:', error);
            }
        }
        
        // 尝试播放缓冲的音频数据
        async function attemptBufferedPlayback(senderId) {
            const buffer = audioStreamBuffer.get(senderId);
            if (!buffer || buffer.chunks.length === 0) {
                if (buffer) {
                    buffer.isPlaying = false;
                    buffer.playbackStarted = false;
                }
                // 清理该用户的定时器
                if (audioPlaybackTimers.has(senderId)) {
                    clearTimeout(audioPlaybackTimers.get(senderId));
                    audioPlaybackTimers.delete(senderId);
                }
                return;
            }
            
            try {
                // 合并多个小块为一个较大的音频块
                let chunksToMerge = Math.min(5, buffer.chunks.length); // 最多合并5个块
                
                // 确保合并后的大小足够大
                let previewSize = 0;
                for (let i = 0; i < chunksToMerge; i++) {
                    previewSize += buffer.chunks[i].length;
                    if (previewSize >= 10000) { // 至少10KB
                        chunksToMerge = i + 1;
                        break;
                    }
                }
                
                const mergedChunks = buffer.chunks.splice(0, chunksToMerge);
                
                // 计算总大小
                const totalSize = mergedChunks.reduce((sum, chunk) => sum + chunk.length, 0);
                buffer.totalSize -= totalSize;
                
                // 合并音频数据
                const mergedAudio = new Uint8Array(totalSize);
                let offset = 0;
                for (const chunk of mergedChunks) {
                    mergedAudio.set(chunk, offset);
                    offset += chunk.length;
                }
                
                console.log(`播放合并音频块: ${totalSize} 字节 (合并了 ${chunksToMerge} 个块)，剩余 ${buffer.chunks.length} 块`);
                
                // 尝试播放合并后的音频块
                await tryMultiplePlaybackMethods(mergedAudio, senderId);
                
                // 继续播放下一批块
                if (buffer.chunks.length > 0) {
                    // 清理之前的定时器
                    if (audioPlaybackTimers.has(senderId)) {
                        clearTimeout(audioPlaybackTimers.get(senderId));
                    }
                    
                    // 设置新的定时器，延迟后播放下一批块
                    const timer = setTimeout(() => {
                        audioPlaybackTimers.delete(senderId);
                        attemptBufferedPlayback(senderId);
                    }, 200); // 给音频播放留出时间
                    
                    audioPlaybackTimers.set(senderId, timer);
                } else {
                    buffer.isPlaying = false;
                    buffer.playbackStarted = false;
                }
                
            } catch (error) {
                console.error('缓冲播放失败:', error);
                if (buffer) {
                    buffer.isPlaying = false;
                    buffer.playbackStarted = false;
                }
                // 清理定时器
                if (audioPlaybackTimers.has(senderId)) {
                    clearTimeout(audioPlaybackTimers.get(senderId));
                    audioPlaybackTimers.delete(senderId);
                }
            }
        }
        
        // 验证音频数据
        function validateAudioData(audioData) {
            if (audioData.length < 1000) {
                return { valid: false, reason: '数据太小' };
            }
            
            // 检查WebM文件头 (简单检查)
            const header = new Uint8Array(audioData.slice(0, 4));
            const headerStr = Array.from(header).map(b => b.toString(16).padStart(2, '0')).join('');
            
            // WebM文件通常以 1A 45 DF A3 开头，但实时流可能不同
            console.log(`音频数据头: ${headerStr}, 大小: ${audioData.length} 字节`);
            
            return { valid: true, reason: 'OK' };
        }
        
        // 尝试多种播放方法
        async function tryMultiplePlaybackMethods(audioData, senderId) {
            // 验证音频数据
            const validation = validateAudioData(audioData);
            if (!validation.valid) {
                console.log(`音频数据无效: ${validation.reason} (${audioData.length} 字节)`);
                return;
            }
            
            const methods = [
                () => playWithAudioElement(audioData, 'audio/webm;codecs=opus'),
                () => playWithAudioElement(audioData, 'audio/webm'),
                () => playWithWebAudioAPI(audioData),
                () => playWithAudioElement(audioData, 'audio/ogg;codecs=opus'),
                () => playWithAudioElement(audioData, 'audio/ogg')
            ];
            
            for (let i = 0; i < methods.length; i++) {
                try {
                    await methods[i]();
                    console.log(`播放方法 ${i + 1} 成功 (${audioData.length} 字节)`);
                    return;
                } catch (error) {
                    console.log(`播放方法 ${i + 1} 失败:`, error.message);
                    if (i === methods.length - 1) {
                        // 所有方法都失败，仅记录日志
                        console.log(`所有播放方法都失败 (${audioData.length} 字节)`);
                    }
                }
            }
        }
        
        // 使用Web Audio API播放
        async function playWithWebAudioAPI(audioData) {
            const audioContext = await initPlaybackAudioContext();
            const audioBlob = new Blob([audioData], { type: 'audio/webm;codecs=opus' });
            const arrayBuffer = await audioBlob.arrayBuffer();
            
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            const source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            
            const gainNode = audioContext.createGain();
            gainNode.gain.value = 0.8;
            
            source.connect(gainNode);
            gainNode.connect(audioContext.destination);
            source.start(0);
            
            return new Promise((resolve) => {
                source.onended = resolve;
            });
        }
        
        // 使用Audio元素播放
        async function playWithAudioElement(audioData, mimeType) {
            const audioBlob = new Blob([audioData], { type: mimeType });
            const audioUrl = URL.createObjectURL(audioBlob);
            const audio = new Audio(audioUrl);
            
            audio.volume = 0.8;
            audio.preload = 'auto';
            
            return new Promise((resolve, reject) => {
                const cleanup = () => {
                    URL.revokeObjectURL(audioUrl);
                    audio.removeEventListener('ended', onEnded);
                    audio.removeEventListener('error', onError);
                };
                
                const onEnded = () => {
                    cleanup();
                    resolve();
                };
                
                const onError = (e) => {
                    cleanup();
                    reject(new Error(`Audio playback failed: ${e.message || 'Unknown error'}`));
                };
                
                audio.addEventListener('ended', onEnded);
                audio.addEventListener('error', onError);
                
                audio.play().catch(reject);
            });
        }
        

        

        
        // 清理所有音频流
        function cleanupAllAudioStreams() {
            // 清理所有定时器
            audioPlaybackTimers.forEach(timer => clearTimeout(timer));
            audioPlaybackTimers.clear();
            
            // 清理所有缓冲区和状态
            audioStreamBuffer.clear();
            audioPlaybackQueue.clear();
            isProcessingAudio.clear();
            
            console.log('已清理所有音频流');
        }
        

        
        // 使用音频流播放
        async function playAudioStream(audioData) {
            try {
                // 创建一个临时的audio元素用于播放
                const audioBlob = new Blob([audioData], { type: 'audio/webm;codecs=opus' });
                const audioUrl = URL.createObjectURL(audioBlob);
                
                // 创建新的Audio对象
                const audio = new Audio();
                audio.src = audioUrl;
                audio.volume = 0.8;
                audio.preload = 'auto';
                
                // 设置播放完成后的清理
                const cleanup = () => {
                    URL.revokeObjectURL(audioUrl);
                    audio.removeEventListener('ended', cleanup);
                    audio.removeEventListener('error', cleanup);
                };
                
                audio.addEventListener('ended', cleanup);
                audio.addEventListener('error', cleanup);
                
                // 尝试播放
                await audio.play();
                console.log('音频流播放成功');
                
            } catch (error) {
                console.error('音频流播放失败:', error);
                // 显示音频接收指示器而不是播放
                showAudioReceiveIndicator();
                throw error;
            }
        }
        
        // 显示音频接收指示器
        let audioIndicatorTimeout = null;
        let audioIndicatorElement = null;
        let audioPacketCount = 0;
        
        function showAudioReceiveIndicator() {
            audioPacketCount++;
            
            // 如果已经有指示器，更新内容
            if (audioIndicatorElement) {
                clearTimeout(audioIndicatorTimeout);
                audioIndicatorElement.innerHTML = `
                    <div style="width: 8px; height: 8px; background: #27ae60; border-radius: 50%; animation: pulse 1s infinite;"></div>
                    🔊 实时音频 (${audioPacketCount} 包)
                `;
            } else {
                // 创建新的指示器
                audioIndicatorElement = document.createElement('div');
                audioIndicatorElement.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: rgba(39, 174, 96, 0.9);
                    color: white;
                    padding: 8px 15px;
                    border-radius: 15px;
                    font-size: 12px;
                    z-index: 1000;
                    pointer-events: none;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
                    transition: all 0.3s ease;
                `;
                audioIndicatorElement.innerHTML = `
                    <div style="width: 8px; height: 8px; background: #27ae60; border-radius: 50%; animation: pulse 1s infinite;"></div>
                    🔊 实时音频 (${audioPacketCount} 包)
                `;
                document.body.appendChild(audioIndicatorElement);
            }
            
            // 设置自动移除计时器
            audioIndicatorTimeout = setTimeout(() => {
                if (audioIndicatorElement && audioIndicatorElement.parentNode) {
                    audioIndicatorElement.parentNode.removeChild(audioIndicatorElement);
                    audioIndicatorElement = null;
                    audioPacketCount = 0; // 重置计数
                }
            }, 3000);
        }
        
        // 降级音频播放方法
        function fallbackAudioPlayback(audioData) {
            console.log('使用降级音频播放方法');
            
            // 尝试不同的音频格式
            const formats = [
                'audio/webm;codecs=opus',
                'audio/webm',
                'audio/ogg;codecs=opus',
                'audio/ogg'
            ];
            
            let playbackAttempted = false;
            
            for (const format of formats) {
                if (playbackAttempted) break;
                
                try {
                    const audioBlob = new Blob([audioData], { type: format });
                    const audioUrl = URL.createObjectURL(audioBlob);
                    const audio = new Audio(audioUrl);
                    
                    audio.volume = 0.8;
                    audio.preload = 'auto';
                    
                    const playPromise = audio.play();
                    
                    if (playPromise !== undefined) {
                        playPromise.then(() => {
                            console.log(`成功使用格式播放: ${format}`);
                            playbackAttempted = true;
                            
                            audio.addEventListener('ended', () => {
                                URL.revokeObjectURL(audioUrl);
                            });
                            
                        }).catch((error) => {
                            console.log(`格式 ${format} 播放失败:`, error);
                            URL.revokeObjectURL(audioUrl);
                        });
                    }
                    
                } catch (error) {
                    console.log(`格式 ${format} 创建失败:`, error);
                }
            }
            
            if (!playbackAttempted) {
                console.warn('所有音频播放方法都失败了');
                showNotification('音频播放失败，请检查浏览器兼容性', 'error');
            }
        }
        
        // 页面加载完成后初始化
        document.addEventListener('DOMContentLoaded', init);
        
        // 页面卸载时清理
        window.addEventListener('beforeunload', () => {
            if (fileTransferManager) {
                // 取消所有活跃的传输
                activeTransfers.forEach((transfer, transferId) => {
                    if (transfer.status === 'sending' || transfer.status === 'receiving') {
                        fileTransferManager.cancelTransfer(transferId);
                    }
                });
            }
        });
    </script>
</body>
</html>