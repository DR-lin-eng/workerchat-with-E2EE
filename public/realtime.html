<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å®æ—¶æ–‡ä»¶ä¼ è¾“èŠå¤©å®¤</title>
    <script src="https://unpkg.com/openpgp@6.2.0/dist/openpgp.min.js"></script>
    <style>
        :root {
            --primary: #4a6fa5;
            --secondary: #6b8cbc;
            --light: #f0f4f8;
            --dark: #2c3e50;
            --success: #27ae60;
            --warning: #f39c12;
            --danger: #e74c3c;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
            color: var(--light);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            height: calc(100vh - 40px);
        }

        .panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.18);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .header {
            padding-bottom: 15px;
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        h1,
        h2,
        h3 {
            color: white;
            margin-bottom: 15px;
        }

        .connection-status {
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.85em;
            margin-bottom: 15px;
            text-align: center;
        }

        .status-connected {
            background: var(--success);
        }

        .status-connecting {
            background: var(--warning);
        }

        .status-disconnected {
            background: var(--danger);
        }

        .user-list {
            flex: 1;
            overflow-y: auto;
        }

        .user-item {
            padding: 9px;
            margin-bottom: 10px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .user-item:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateX(5px);
        }

        .user-item.self {
            background: rgba(74, 111, 165, 0.3);
        }

        .user-name {
            font-weight: bold;
            margin-bottom: 2px;
        }

        .user-id {
            font-size: 0.75em;
            color: #bbb;
            word-break: break-all;
            font-family: monospace;
        }

        .file-transfer-btn {
            margin-top: 5px;
            padding: 4px 8px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8em;
            width: 100%;
        }

        .file-transfer-btn:hover {
            background: var(--secondary);
        }

        .file-transfer-btn:disabled {
            background: #666;
            cursor: not-allowed;
        }

        .chat-area {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .messages {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            margin-bottom: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }

        .message {
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 10px;
            max-width: 80%;
            word-wrap: break-word;
        }

        .message.sent {
            background: var(--primary);
            align-self: flex-end;
            margin-left: 20%;
        }

        .message.received {
            background: var(--dark);
            align-self: flex-start;
            margin-right: 20%;
        }

        .message.file {
            background: rgba(106, 90, 205, 0.3);
            border: 1px solid #6a5acd;
        }

        .message.system {
            background: rgba(255, 165, 0, 0.3);
            border: 1px solid #ffa500;
            text-align: center;
            margin: 10px auto;
            max-width: 60%;
        }

        .sender-info {
            font-weight: bold;
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
            font-size: 0.85em;
        }

        .sender-name {
            color: #4ec9b0;
        }

        .message-time {
            font-size: 0.75em;
            opacity: 0.7;
        }

        .file-message {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .file-icon {
            font-size: 2em;
        }

        .file-info {
            flex: 1;
        }

        .file-name {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .file-size {
            font-size: 0.8em;
            color: #ccc;
        }

        .file-hash {
            font-size: 0.7em;
            color: #999;
            font-family: monospace;
            margin-top: 2px;
        }

        .file-progress {
            margin-top: 5px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            overflow: hidden;
        }

        .file-progress-bar {
            height: 100%;
            background: var(--success);
            transition: width 0.3s ease;
        }

        .download-btn {
            padding: 5px 10px;
            background: var(--success);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.8em;
        }

        .cancel-btn {
            padding: 5px 10px;
            background: var(--danger);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.8em;
            margin-left: 5px;
        }

        .input-area {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .input-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .input-tools {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .tool-btn {
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background 0.3s;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .tool-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .tool-btn.recording {
            background: var(--danger);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.6;
            }

            100% {
                opacity: 1;
            }
        }

        .message.voice {
            background: rgba(255, 165, 0, 0.3);
            border: 1px solid #ffa500;
        }

        .voice-message {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .voice-icon {
            font-size: 1.5em;
            color: #ffa500;
        }

        .voice-duration {
            font-size: 0.9em;
            color: #ccc;
        }

        .play-btn {
            padding: 8px 12px;
            background: #ffa500;
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1em;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .play-btn:hover {
            background: #ff8c00;
        }

        .voice-waveform {
            flex: 1;
            height: 30px;
            background: rgba(255, 165, 0, 0.2);
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8em;
        }

        textarea {
            flex: 1;
            padding: 12px;
            border-radius: 8px;
            border: none;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            resize: none;
            min-height: 60px;
        }

        .send-button {
            padding: 12px 20px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s;
            height: fit-content;
        }

        .send-button:hover {
            background: var(--secondary);
        }

        .send-button:disabled {
            background: #666;
            cursor: not-allowed;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 25px;
            border-radius: 8px;
            background: var(--success);
            color: white;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            transform: translateX(120%);
            transition: transform 0.3s ease;
            max-width: 300px;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.error {
            background: var(--danger);
        }

        .notification.warning {
            background: var(--warning);
        }

        #fileInput,
        #imageInput,
        #videoInput {
            display: none;
        }

        .media-preview {
            max-width: 300px;
            max-height: 200px;
            border-radius: 8px;
            margin: 8px 0;
        }

        .video-preview {
            max-width: 300px;
            max-height: 200px;
            border-radius: 8px;
            margin: 8px 0;
        }

        .live-voice-controls {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px;
            border-radius: 12px;
            z-index: 1000;
            min-width: 300px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .voice-control-panel {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .voice-status {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: bold;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 8px;
        }

        .volume-section,
        .settings-section,
        .status-section {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
        }

        .volume-section label,
        .settings-section label {
            min-width: 80px;
            font-size: 0.8em;
            color: #ccc;
        }

        .status-section {
            justify-content: space-between;
            font-size: 0.8em;
            color: #aaa;
        }

        .live-voice-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--success);
            animation: pulse 1s infinite;
        }

        .live-voice-indicator.speaking {
            background: var(--danger);
        }

        .volume-meter {
            width: 100px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            overflow: hidden;
        }

        .volume-bar {
            height: 100%;
            background: var(--success);
            transition: width 0.1s ease;
        }

        .key-management {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }

        .key-info {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 0.9em;
        }

        .key-id {
            word-break: break-all;
            font-family: monospace;
            font-size: 0.8em;
            color: #4ec9b0;
        }

        .key-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 10px;
        }

        .key-buttons button {
            padding: 8px 12px;
            font-size: 0.85em;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .key-buttons button:hover {
            background: var(--secondary);
        }

        .room-url {
            background: rgba(0, 0, 0, 0.3);
            padding: 8px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 0.8em;
            margin-bottom: 10px;
            word-break: break-all;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .room-url:hover {
            background: rgba(0, 0, 0, 0.4);
        }

        .transfer-status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            min-width: 300px;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }

        .transfer-status.show {
            display: block;
        }

        .transfer-item {
            padding: 8px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            font-size: 0.9em;
        }

        .transfer-item:last-child {
            margin-bottom: 0;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="panel manage-area">
            <div class="header">
                <h2>åœ¨çº¿ç”¨æˆ·</h2>
                <div id="connectionStatus" class="connection-status status-disconnected">
                    æœªè¿æ¥
                </div>
            </div>
            <div class="user-list" id="userList">
                <div style="text-align: center; color: #999; padding: 20px;">
                    ç­‰å¾…è¿æ¥...
                </div>
            </div>
            <div class="key-management">
                <h3>å¯†é’¥ç®¡ç†</h3>
                <div class="key-info">
                    <div>ä½ çš„å¯†é’¥ID:</div>
                    <div id="keyId" class="key-id">æœªæ³¨å†Œ</div>
                </div>
                <div class="key-buttons">
                    <button id="importPublicKey">å¯¼å…¥å…¬é’¥</button>
                    <button id="importPrivateKey">å¯¼å…¥ç§é’¥</button>
                    <button id="copyPublicKey">å¤åˆ¶å…¬é’¥</button>
                    <button id="generateKeys">ç”Ÿæˆå¯†é’¥</button>
                </div>
            </div>
        </div>

        <div class="panel chat-area">
            <div class="header">
                <h2 id="roomName">å®æ—¶æ–‡ä»¶ä¼ è¾“èŠå¤©å®¤</h2>
                <div class="room-url" id="roomUrl"></div>
                <div style="font-size: 0.8em; color: #ccc;">
                    æ”¯æŒ WebSocket å®æ—¶æ–‡ä»¶ä¼ è¾“ï¼Œæ–‡ä»¶å®Œæ•´æ€§ MD5 éªŒè¯
                </div>
            </div>

            <div class="messages" id="messages"></div>

            <div class="input-area">
                <div class="input-container">
                    <div class="input-tools">
                        <button class="tool-btn" id="fileBtn" title="å‘é€æ–‡ä»¶">
                            ğŸ“ æ–‡ä»¶
                        </button>
                        <button class="tool-btn" id="imageBtn" title="å‘é€å›¾ç‰‡">
                            ğŸ–¼ï¸ å›¾ç‰‡
                        </button>
                        <button class="tool-btn" id="videoBtn" title="å‘é€è§†é¢‘">
                            ğŸ¥ è§†é¢‘
                        </button>
                        <button class="tool-btn" id="voiceBtn" title="è¯­éŸ³æ¶ˆæ¯">
                            ğŸ¤ è¯­éŸ³
                        </button>
                        <button class="tool-btn" id="liveVoiceBtn" title="å®æ—¶è¯­éŸ³">
                            ğŸ“ å®æ—¶è¯­éŸ³
                        </button>
                        <span id="voiceStatus" style="font-size: 0.8em; color: #ccc;"></span>
                        <div id="smartPlaybackStatus"
                            style="font-size: 0.75em; color: #4ec9b0; margin-top: 5px; display: none;">
                            ğŸ§  æ™ºèƒ½æ’­æ”¾: 0% æˆåŠŸç‡
                        </div>
                    </div>
                    <textarea id="messageInput" placeholder="è¾“å…¥æ¶ˆæ¯..." disabled></textarea>
                </div>
                <button class="send-button" id="sendButton" disabled>å‘é€</button>
            </div>

            <input type="file" id="fileInput" multiple>
            <input type="file" id="imageInput" accept="image/*" multiple>
            <input type="file" id="videoInput" accept="video/*" multiple>
        </div>
    </div>

    <div class="notification" id="notification"></div>
    <div class="transfer-status" id="transferStatus">
        <h4>ä¼ è¾“çŠ¶æ€</h4>
        <div id="transferList"></div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let privateKey = '';
        let publicKey = '';
        let userId = '';
        let userName = '';
        let websocket = null;
        let roomId = '';
        let users = new Map();
        let fileTransferManager = null;
        let activeTransfers = new Map(); // transferId -> transfer info

        // WebSocketè¿æ¥çŠ¶æ€ç›‘æ§
        let connectionRetryCount = 0;
        let maxRetryCount = 5;
        let retryDelay = 1000; // 1ç§’
        let connectionCheckInterval = null;

        // å¸¦å®½ç›‘æ§å’Œå¹¶å‘æ§åˆ¶
        let bandwidthMonitor = {
            startTime: 0,
            totalBytes: 0,
            lastSpeedCheck: 0,
            currentSpeed: 0, // KB/s
            speedHistory: [],
            maxHistorySize: 10
        };

        // å›ºå®šé«˜å¹¶å‘é…ç½® - å¤§å¹…æå‡ä¼ è¾“é€Ÿåº¦
        const FIXED_CONCURRENCY = 300;

        // å…¨å±€å®‰å…¨WebSocketå‘é€å‡½æ•°
        function safeSendMessage(message, errorMessage = 'å‘é€æ¶ˆæ¯å¤±è´¥') {
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                try {
                    const messageStr = JSON.stringify(message);
                    const messageSize = new Blob([messageStr]).size;

                    // æ£€æŸ¥æ¶ˆæ¯å¤§å°
                    if (messageSize > 10 * 1024) { // 10KBè­¦å‘Šé˜ˆå€¼
                        console.warn(`WebSocketæ¶ˆæ¯è¾ƒå¤§: ${messageSize} å­—èŠ‚`);
                    }

                    websocket.send(messageStr);
                    return true;
                } catch (error) {
                    console.error('WebSocketå‘é€é”™è¯¯:', error);
                    showNotification(`${errorMessage}: ${error.message}`, 'error');
                    return false;
                }
            } else {
                console.error('WebSocketè¿æ¥ä¸å¯ç”¨ï¼ŒçŠ¶æ€:', getWebSocketStateText());
                showNotification(`${errorMessage}: è¿æ¥æ–­å¼€`, 'error');

                // å°è¯•é‡è¿
                if (connectionRetryCount < maxRetryCount) {
                    attemptReconnection();
                }
                return false;
            }
        }

        // è·å–WebSocketçŠ¶æ€æ–‡æœ¬
        function getWebSocketStateText() {
            if (!websocket) return 'null';
            switch (websocket.readyState) {
                case WebSocket.CONNECTING: return 'CONNECTING';
                case WebSocket.OPEN: return 'OPEN';
                case WebSocket.CLOSING: return 'CLOSING';
                case WebSocket.CLOSED: return 'CLOSED';
                default: return 'UNKNOWN';
            }
        }

        // å°è¯•é‡è¿
        function attemptReconnection() {
            if (connectionRetryCount >= maxRetryCount) {
                showNotification('è¿æ¥å¤±è´¥ï¼Œå·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°', 'error');
                return;
            }

            connectionRetryCount++;
            const delay = retryDelay * connectionRetryCount;

            showNotification(`è¿æ¥æ–­å¼€ï¼Œ${delay / 1000}ç§’åå°è¯•é‡è¿ (${connectionRetryCount}/${maxRetryCount})`, 'warning');

            setTimeout(() => {
                console.log(`å°è¯•é‡è¿ ${connectionRetryCount}/${maxRetryCount}`);
                connectWebSocket();
            }, delay);
        }

        // é‡ç½®é‡è¿è®¡æ•°
        function resetConnectionRetry() {
            connectionRetryCount = 0;
        }

        // å¼€å§‹è¿æ¥çŠ¶æ€ç›‘æ§
        function startConnectionMonitoring() {
            if (connectionCheckInterval) {
                clearInterval(connectionCheckInterval);
            }

            connectionCheckInterval = setInterval(() => {
                if (websocket && websocket.readyState === WebSocket.CLOSED) {
                    console.log('æ£€æµ‹åˆ°WebSocketè¿æ¥æ–­å¼€ï¼Œå°è¯•é‡è¿');
                    attemptReconnection();
                }
            }, 5000); // æ¯5ç§’æ£€æŸ¥ä¸€æ¬¡
        }

        // åœæ­¢è¿æ¥çŠ¶æ€ç›‘æ§
        function stopConnectionMonitoring() {
            if (connectionCheckInterval) {
                clearInterval(connectionCheckInterval);
                connectionCheckInterval = null;
            }
        }

        // æ¢å¤æš‚åœçš„æ–‡ä»¶ä¼ è¾“
        function resumePausedTransfers() {
            let resumedCount = 0;

            for (const [transferId, transfer] of activeTransfers) {
                if (transfer.status === 'paused' && transfer.type === 'send' && transfer.resumeTransfer) {
                    console.log(`æ¢å¤ä¼ è¾“: ${transfer.file.name} (${transfer.sentChunks}/${transfer.totalChunks})`);
                    transfer.resumeTransfer();
                    resumedCount++;
                }
            }

            if (resumedCount > 0) {
                showNotification(`å·²æ¢å¤ ${resumedCount} ä¸ªæš‚åœçš„æ–‡ä»¶ä¼ è¾“`, 'info');
            }
        }

        // æš‚åœæ‰€æœ‰æ´»è·ƒçš„æ–‡ä»¶ä¼ è¾“
        function pauseActiveTransfers() {
            let pausedCount = 0;

            for (const [transferId, transfer] of activeTransfers) {
                if (transfer.status === 'sending' && transfer.type === 'send' && transfer.stopTransfer) {
                    console.log(`æš‚åœä¼ è¾“: ${transfer.file.name}`);
                    transfer.status = 'paused';
                    transfer.stopTransfer();
                    pausedCount++;
                }
            }

            if (pausedCount > 0) {
                console.log(`å·²æš‚åœ ${pausedCount} ä¸ªæ´»è·ƒçš„æ–‡ä»¶ä¼ è¾“`);
            }
        }

        // è¯­éŸ³å½•åˆ¶ç›¸å…³
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;
        let recordingStartTime = 0;

        // å®æ—¶è¯­éŸ³ç›¸å…³
        let liveAudioStream = null;
        let liveAudioContext = null;
        let liveMediaRecorder = null;
        let isLiveVoiceActive = false;
        let volumeMeter = null;
        let liveVoiceInterval = null;

        // ä¼˜åŒ–çš„éŸ³é¢‘å¤„ç†
        let audioBuffer = [];
        let lastSendTime = 0;
        let silenceThreshold = 0.01; // é™éŸ³æ£€æµ‹é˜ˆå€¼
        let volumeAnalyser = null;
        let audioWorkletNode = null;
        let sendInterval = 500; // å‘é€é—´éš” (ms)
        let minBufferSize = 3; // æœ€å°ç¼“å†²åŒºå¤§å°

        // éŸ³é¢‘æ’­æ”¾ç›¸å…³
        let playbackAudioContext = null;
        let audioStreamBuffer = new Map(); // æŒ‰ç”¨æˆ·IDå­˜å‚¨éŸ³é¢‘æµ
        let audioPlaybackQueue = new Map(); // æ’­æ”¾é˜Ÿåˆ—
        let isProcessingAudio = new Map(); // å¤„ç†çŠ¶æ€
        let audioPlaybackTimers = new Map(); // æ’­æ”¾å®šæ—¶å™¨

        // æ™ºèƒ½éŸ³é¢‘æ’­æ”¾ç›¸å…³
        let headerChunks = new Map(); // å­˜å‚¨æ¯ä¸ªç”¨æˆ·çš„å¤´ä¿¡æ¯å—
        let playbackStats = new Map(); // æ’­æ”¾ç»Ÿè®¡ {success: 0, total: 0}
        let smartPlaybackEnabled = true; // å¯ç”¨æ™ºèƒ½æ’­æ”¾

        // DOMå…ƒç´ 
        const userListEl = document.getElementById('userList');
        const messagesEl = document.getElementById('messages');
        const messageInputEl = document.getElementById('messageInput');
        const sendButtonEl = document.getElementById('sendButton');
        const generateKeysBtn = document.getElementById('generateKeys');
        const importPublicKeyBtn = document.getElementById('importPublicKey');
        const importPrivateKeyBtn = document.getElementById('importPrivateKey');
        const copyPublicKeyBtn = document.getElementById('copyPublicKey');
        const keyIdEl = document.getElementById('keyId');
        const notificationEl = document.getElementById('notification');
        const connectionStatusEl = document.getElementById('connectionStatus');
        const fileInputEl = document.getElementById('fileInput');
        const imageInputEl = document.getElementById('imageInput');
        const videoInputEl = document.getElementById('videoInput');
        const fileBtnEl = document.getElementById('fileBtn');
        const imageBtnEl = document.getElementById('imageBtn');
        const videoBtnEl = document.getElementById('videoBtn');
        const voiceBtnEl = document.getElementById('voiceBtn');
        const liveVoiceBtnEl = document.getElementById('liveVoiceBtn');
        const voiceStatusEl = document.getElementById('voiceStatus');
        const smartPlaybackStatusEl = document.getElementById('smartPlaybackStatus');
        const transferStatusEl = document.getElementById('transferStatus');
        const transferListEl = document.getElementById('transferList');
        const roomUrlEl = document.getElementById('roomUrl');

        // WebSocket æ–‡ä»¶ä¼ è¾“ç®¡ç†å™¨
        class FileTransferManager {
            constructor(websocket) {
                this.websocket = websocket;
                this.pendingTransfers = new Map(); // å­˜å‚¨å¾…å¤„ç†çš„ä¼ è¾“è¯·æ±‚
            }

            // å®‰å…¨çš„WebSocketå‘é€æ–¹æ³•
            safeSend(message, errorMessage = 'å‘é€æ¶ˆæ¯å¤±è´¥') {
                if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                    try {
                        const messageStr = JSON.stringify(message);
                        const messageSize = new Blob([messageStr]).size;

                        // æ£€æŸ¥æ¶ˆæ¯å¤§å°å¹¶è®°å½• - æé«˜é™åˆ¶ä»¥æ”¯æŒå¤§åˆ†ç‰‡
                        if (messageSize > 100 * 1024) { // 100KBè­¦å‘Šé˜ˆå€¼
                            console.warn(`WebSocketæ¶ˆæ¯è¾ƒå¤§: ${messageSize} å­—èŠ‚, ç±»å‹: ${message.type}`);
                        }

                        // å¦‚æœæ¶ˆæ¯è¿‡å¤§ï¼Œæ‹’ç»å‘é€ - Cloudflare Workeræ”¯æŒæœ€å¤§1MBæ¶ˆæ¯
                        if (messageSize > 800 * 1024) { // 800KBç¡¬é™åˆ¶ï¼Œç•™ä¸€äº›ä½™é‡
                            console.error(`WebSocketæ¶ˆæ¯è¿‡å¤§: ${messageSize} å­—èŠ‚ï¼Œè¶…è¿‡800KBé™åˆ¶`);
                            displaySystemMessage(`${errorMessage}: æ¶ˆæ¯è¿‡å¤§ (${messageSize} å­—èŠ‚)`, 'error');
                            return false;
                        }

                        this.websocket.send(messageStr);
                        return true;
                    } catch (error) {
                        console.error('WebSocketå‘é€é”™è¯¯:', error);
                        displaySystemMessage(`${errorMessage}: ${error.message}`, 'error');
                        return false;
                    }
                } else {
                    console.error('WebSocketè¿æ¥ä¸å¯ç”¨ï¼ŒçŠ¶æ€:', this.websocket?.readyState);
                    displaySystemMessage(`${errorMessage}: è¿æ¥æ–­å¼€`, 'error');
                    return false;
                }
            }

            // è®¡ç®—æœ€ä¼˜åˆ†ç‰‡å¤§å° - ç²¾ç¡®è®¡ç®—Base64ç¼–ç åçš„å¤§å°
            calculateOptimalChunkSize(fileSize) {
                // Base64ç¼–ç ç²¾ç¡®è®¡ç®—ï¼šåŸå§‹æ•°æ® * 4/3ï¼Œå‘ä¸Šå–æ•´åˆ°4çš„å€æ•°
                // åŠ ä¸ŠJSONå¼€é”€ï¼ˆå­—æ®µåã€å¼•å·ã€é€—å·ç­‰ï¼‰çº¦20-30%
                // ç›®æ ‡ï¼šç¡®ä¿æœ€ç»ˆæ¶ˆæ¯ < 750KBï¼Œç•™50KBå®‰å…¨ä½™é‡
                
                const maxSafeMessageSize = 750 * 1024; // 750KBå®‰å…¨é™åˆ¶
                const jsonOverhead = 1.25; // JSONå¼€é”€25%
                const base64Overhead = 4/3; // Base64ç¼–ç å¼€é”€33.33%
                
                // åæ¨æœ€å¤§åŸå§‹æ•°æ®å¤§å°
                const maxRawSize = Math.floor(maxSafeMessageSize / (base64Overhead * jsonOverhead));
                
                if (fileSize < 1024 * 1024) { // < 1MB
                    return Math.min(128 * 1024, maxRawSize); // æœ€å¤š128KB
                } else if (fileSize < 10 * 1024 * 1024) { // < 10MB
                    return Math.min(256 * 1024, maxRawSize); // æœ€å¤š256KB
                } else if (fileSize < 100 * 1024 * 1024) { // < 100MB
                    return Math.min(384 * 1024, maxRawSize); // æœ€å¤š384KB
                } else { // >= 100MB
                    return Math.min(400 * 1024, maxRawSize); // æœ€å¤š400KBï¼Œæ›´å®‰å…¨çš„é™åˆ¶
                }
            }

            async initiateFileTransfer(targetUserId, file) {
                const transferId = this.generateTransferId();
                const fileHash = await this.calculateMD5(file);
                const chunkSize = this.calculateOptimalChunkSize(file.size);
                const totalChunks = Math.ceil(file.size / chunkSize);

                // å­˜å‚¨ä¼ è¾“ä¿¡æ¯
                activeTransfers.set(transferId, {
                    type: 'send',
                    file: file,
                    targetUserId: targetUserId,
                    fileHash: fileHash,
                    totalChunks: totalChunks,
                    chunkSize: chunkSize,
                    progress: 0,
                    status: 'requesting'
                });

                // å‘é€ä¼ è¾“è¯·æ±‚
                const transferRequest = {
                    type: 'fileTransferRequest',
                    transferId,
                    targetUserId,
                    metadata: {
                        fileName: file.name,
                        fileSize: file.size,
                        fileType: file.type,
                        fileHash,
                        totalChunks,
                        chunkSize: chunkSize
                    }
                };

                this.safeSend(transferRequest, 'å‘é€ä¼ è¾“è¯·æ±‚å¤±è´¥');
                this.updateTransferStatus();

                displaySystemMessage(`æ­£åœ¨è¯·æ±‚å‘ ${getUserName(targetUserId)} å‘é€æ–‡ä»¶: ${file.name}`);
                return transferId;
            }

            // æ£€æŸ¥æ˜¯å¦ä¸ºåª’ä½“æ–‡ä»¶ï¼ˆå›¾ç‰‡/è§†é¢‘ï¼‰
            isMediaFile(fileType) {
                return fileType.startsWith('image/') || fileType.startsWith('video/');
            }

            handleTransferRequest(message) {
                const { transferId, senderId, metadata } = message;

                console.log('Handling transfer request:', transferId, 'from:', senderId);

                // ä¸´æ—¶å­˜å‚¨ metadataï¼Œç”¨äºåç»­åˆ›å»ºæ¥æ”¶ä¼šè¯
                this.pendingTransfers = this.pendingTransfers || new Map();

                // æ£€æŸ¥æ˜¯å¦å·²ç»å­˜åœ¨ç›¸åŒçš„ä¼ è¾“è¯·æ±‚
                if (this.pendingTransfers.has(transferId)) {
                    console.warn('Transfer request already exists:', transferId);
                    return;
                }

                this.pendingTransfers.set(transferId, { senderId, metadata });
                console.log('Stored pending transfer:', transferId);

                // å¦‚æœæ˜¯å›¾ç‰‡æˆ–è§†é¢‘ï¼Œè‡ªåŠ¨æ¥å—å¹¶ç›´æ¥æ˜¾ç¤ºåœ¨èŠå¤©ä¸­
                if (this.isMediaFile(metadata.fileType)) {
                    console.log('Auto-accepting media file:', metadata.fileName);
                    this.acceptTransfer(transferId, senderId);
                    displaySystemMessage(`æ­£åœ¨æ¥æ”¶${metadata.fileType.startsWith('image/') ? 'å›¾ç‰‡' : 'è§†é¢‘'}: ${metadata.fileName}`);
                } else {
                    // æ™®é€šæ–‡ä»¶æ˜¾ç¤ºæ¥æ”¶è¯·æ±‚
                    displayFileTransferRequest(senderId, transferId, metadata);
                }
            }

            acceptTransfer(transferId, senderId) {
                console.log('Accepting transfer:', transferId, 'from:', senderId);

                // è·å–å¾…å¤„ç†çš„ä¼ è¾“ä¿¡æ¯
                const pendingTransfer = this.pendingTransfers?.get(transferId);
                if (!pendingTransfer) {
                    console.error('Pending transfer not found:', transferId);
                    console.log('Available pending transfers:', Array.from(this.pendingTransfers?.keys() || []));
                    console.log('Active transfers:', Array.from(activeTransfers.keys()));
                    displaySystemMessage(`é”™è¯¯: æ‰¾ä¸åˆ°ä¼ è¾“è¯·æ±‚ ${transferId}`);
                    return;
                }

                // æ£€æŸ¥æ˜¯å¦å·²ç»åœ¨å¤„ç†è¿™ä¸ªä¼ è¾“
                if (activeTransfers.has(transferId)) {
                    console.warn('Transfer already active:', transferId);
                    displaySystemMessage(`ä¼ è¾“ ${transferId} å·²ç»åœ¨è¿›è¡Œä¸­`);
                    return;
                }

                // å‘é€æ¥å—å“åº”
                const response = {
                    type: 'fileTransferResponse',
                    transferId,
                    senderId,
                    accepted: true
                };

                if (!this.safeSend(response, 'å‘é€æ¥å—å“åº”å¤±è´¥')) {
                    return;
                }

                // åˆ›å»ºæ¥æ”¶ä¼šè¯ï¼ŒåŒ…å« metadata
                activeTransfers.set(transferId, {
                    type: 'receive',
                    senderId: senderId,
                    metadata: pendingTransfer.metadata,
                    receivedChunks: new Map(),
                    progress: 0,
                    status: 'receiving'
                });

                // æ¸…ç†å¾…å¤„ç†çš„ä¼ è¾“ä¿¡æ¯
                this.pendingTransfers.delete(transferId);
                console.log('Cleaned up pending transfer:', transferId);

                this.updateTransferStatus();
                displaySystemMessage(`å·²æ¥å—æ¥è‡ª ${getUserName(senderId)} çš„æ–‡ä»¶: ${pendingTransfer.metadata.fileName}`);
            }

            rejectTransfer(transferId, senderId) {
                const response = {
                    type: 'fileTransferResponse',
                    transferId,
                    senderId,
                    accepted: false
                };

                this.safeSend(response, 'å‘é€æ‹’ç»å“åº”å¤±è´¥');

                // æ¸…ç†å¾…å¤„ç†çš„ä¼ è¾“ä¿¡æ¯
                if (this.pendingTransfers) {
                    this.pendingTransfers.delete(transferId);
                }

                displaySystemMessage(`å·²æ‹’ç»æ¥è‡ª ${getUserName(senderId)} çš„æ–‡ä»¶ä¼ è¾“`);
            }

            handleTransferResponse(message) {
                const transfer = activeTransfers.get(message.transferId);
                if (!transfer) return;

                if (message.accepted) {
                    transfer.status = 'sending';
                    this.startFileSending(transfer, message.transferId);
                    displaySystemMessage(`${getUserName(message.targetUserId)} æ¥å—äº†æ–‡ä»¶ä¼ è¾“`);
                } else {
                    activeTransfers.delete(message.transferId);
                    displaySystemMessage(`${getUserName(message.targetUserId)} æ‹’ç»äº†æ–‡ä»¶ä¼ è¾“`);
                }

                this.updateTransferStatus();
            }

            async startFileSending(transfer, transferId) {
                const file = transfer.file;
                let startChunkIndex = transfer.sentChunks || 0; // æ”¯æŒæ–­ç‚¹ç»­ä¼ 
                let isTransferActive = true; // ä¼ è¾“çŠ¶æ€æ ‡å¿—

                // è®¾ç½®ä¸ºå‡†å¤‡çŠ¶æ€ï¼Œè¿›åº¦ä¿æŒä¸º0ç›´åˆ°å®é™…å¼€å§‹ä¼ è¾“
                transfer.status = 'preparing';
                transfer.isActive = true;
                transfer.sentChunks = startChunkIndex;
                transfer.progress = 0; // å‡†å¤‡é˜¶æ®µè¿›åº¦ä¸º0
                transfer.sentChunkSet = new Set(); // ç”¨äºè·Ÿè¸ªå·²å‘é€çš„åˆ†ç‰‡ï¼Œé¿å…é‡å¤è®¡ç®—
                
                // åˆå§‹åŒ–ä¼ è¾“ç›‘æ§
                const transferMonitor = {
                    startTime: Date.now(),
                    firstChunkSent: false,
                    lastProgressUpdate: Date.now(),
                    actualTransferStartTime: 0 // å®é™…ä¼ è¾“å¼€å§‹æ—¶é—´
                };

                // å¹¶å‘ä¼ è¾“é…ç½®
                const maxConcurrentChunks = this.calculateConcurrency(transfer.totalChunks);
                const sendQueue = new Set(); // æ­£åœ¨å‘é€çš„åˆ†ç‰‡ç´¢å¼•
                const completedChunks = new Set(); // å·²å®Œæˆçš„åˆ†ç‰‡ç´¢å¼•
                let nextChunkIndex = startChunkIndex;

                console.log(`å¼€å§‹å¹¶å‘ä¼ è¾“: ${file.name}, æ€»åˆ†ç‰‡: ${transfer.totalChunks}, å¹¶å‘æ•°: ${maxConcurrentChunks}`);

                // å¹¶å‘å‘é€åˆ†ç‰‡
                const sendChunksConcurrently = async () => {
                    const promises = [];

                    // å¯åŠ¨å¤šä¸ªå¹¶å‘ä¼ è¾“çº¿ç¨‹
                    for (let i = 0; i < maxConcurrentChunks; i++) {
                        promises.push(this.sendChunkWorker(transfer, transferId, {
                            getNextChunkIndex: () => {
                                if (nextChunkIndex >= transfer.totalChunks) return null;
                                return nextChunkIndex++;
                            },
                            isActive: () => isTransferActive,
                            onChunkSent: (chunkIndex) => {
                                // ç¬¬ä¸€ä¸ªåˆ†ç‰‡å‘é€æˆåŠŸæ—¶ï¼Œæ›´æ–°çŠ¶æ€ä¸ºå‘é€ä¸­
                                if (!transferMonitor.firstChunkSent) {
                                    transferMonitor.firstChunkSent = true;
                                    transferMonitor.actualTransferStartTime = Date.now();
                                    transfer.status = 'sending';
                                    console.log(`å¼€å§‹å®é™…ä¼ è¾“: ${file.name}`);
                                }
                                
                                // ä½¿ç”¨Seté¿å…é‡å¤è®¡ç®—åŒä¸€ä¸ªåˆ†ç‰‡
                                if (!transfer.sentChunkSet.has(chunkIndex)) {
                                    transfer.sentChunkSet.add(chunkIndex);
                                    transfer.sentChunks = transfer.sentChunkSet.size + startChunkIndex;
                                    
                                    // åªæœ‰åœ¨å®é™…ä¼ è¾“å¼€å§‹åæ‰æ›´æ–°è¿›åº¦
                                    if (transferMonitor.firstChunkSent) {
                                        transfer.progress = Math.min((transfer.sentChunks / transfer.totalChunks) * 100, 100);
                                    }
                                    this.updateTransferStatus();
                                }
                            },
                            onError: (error) => {
                                console.error('åˆ†ç‰‡å‘é€é”™è¯¯:', error);
                                isTransferActive = false;
                                transfer.status = 'paused';
                                transfer.error = error;
                                this.updateTransferStatus();
                                displaySystemMessage(`æ–‡ä»¶ä¼ è¾“æš‚åœ: ${error}`, 'warning');
                            }
                        }));
                    }

                    // ç­‰å¾…æ‰€æœ‰å¹¶å‘ä¼ è¾“å®Œæˆ
                    await Promise.allSettled(promises);

                    // æ£€æŸ¥ä¼ è¾“æ˜¯å¦å®Œæˆ
                    if (completedChunks.size + startChunkIndex >= transfer.totalChunks && isTransferActive) {
                        console.log(`æ‰€æœ‰åˆ†ç‰‡å‘é€å®Œæˆ: ${file.name}, ç­‰å¾…æ¥æ”¶ç«¯ç¡®è®¤...`);

                        // ä¿®å¤ï¼šä¸ç«‹å³æ˜¾ç¤ºå®Œæˆï¼Œç­‰å¾…æ¥æ”¶ç«¯ç¡®è®¤
                        transfer.status = 'waiting_confirmation';
                        transfer.progress = 100;
                        transfer.isActive = false;
                        this.updateTransferStatus();
                        displaySystemMessage(`æ–‡ä»¶ "${file.name}" å‘é€å®Œæˆï¼Œç­‰å¾…å¯¹æ–¹ç¡®è®¤...`);
                    }
                };

                // å­˜å‚¨ä¼ è¾“æ§åˆ¶å‡½æ•°
                transfer.stopTransfer = () => {
                    isTransferActive = false;
                    transfer.isActive = false;
                    console.log(`åœæ­¢å¹¶å‘ä¼ è¾“: ${file.name}`);
                };

                transfer.resumeTransfer = () => {
                    if (transfer.status === 'paused' && this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                        isTransferActive = true;
                        transfer.isActive = true;
                        transfer.status = 'sending';
                        this.updateTransferStatus();
                        displaySystemMessage(`ç»§ç»­ä¼ è¾“æ–‡ä»¶: ${file.name}`, 'info');

                        // ç²¾ç¡®è®¡ç®—ä¸‹ä¸€ä¸ªè¦å‘é€çš„åˆ†ç‰‡ç´¢å¼•
                        // æ‰¾åˆ°æœ€å¤§çš„å·²å‘é€åˆ†ç‰‡ç´¢å¼•
                        let maxSentIndex = -1;
                        if (transfer.sentChunkSet && transfer.sentChunkSet.size > 0) {
                            for (const chunkIndex of transfer.sentChunkSet) {
                                maxSentIndex = Math.max(maxSentIndex, chunkIndex);
                            }
                            nextChunkIndex = maxSentIndex + 1;
                        } else {
                            nextChunkIndex = startChunkIndex;
                        }
                        
                        console.log(`æ–­ç‚¹ç»­ä¼ : ä»åˆ†ç‰‡ ${nextChunkIndex} å¼€å§‹ï¼Œå·²å®Œæˆ ${transfer.sentChunkSet?.size || 0}/${transfer.totalChunks}`);
                        sendChunksConcurrently();
                    }
                };

                // å¼€å§‹å¹¶å‘ä¼ è¾“
                sendChunksConcurrently();
            }

            // è®¡ç®—å¹¶å‘æ•° - å›ºå®š2å¹¶å‘
            calculateConcurrency(totalChunks) {
                // ç»Ÿä¸€ä½¿ç”¨2å¹¶å‘ï¼Œç¡®ä¿ç¨³å®šæ€§
                return Math.min(2, totalChunks);
            }

            // æ›´æ–°å¸¦å®½ç›‘æ§
            updateBandwidthMonitor(bytesTransferred) {
                const now = Date.now();

                if (bandwidthMonitor.startTime === 0) {
                    bandwidthMonitor.startTime = now;
                    bandwidthMonitor.lastSpeedCheck = now;
                }

                bandwidthMonitor.totalBytes += bytesTransferred;

                // æ¯ç§’è®¡ç®—ä¸€æ¬¡é€Ÿåº¦
                if (now - bandwidthMonitor.lastSpeedCheck >= 1000) {
                    const timeDiff = (now - bandwidthMonitor.lastSpeedCheck) / 1000;
                    const bytesDiff = bytesTransferred;
                    const speed = (bytesDiff / timeDiff) / 1024; // KB/s

                    bandwidthMonitor.currentSpeed = speed;
                    bandwidthMonitor.speedHistory.push(speed);

                    // ä¿æŒå†å²è®°å½•å¤§å°
                    if (bandwidthMonitor.speedHistory.length > bandwidthMonitor.maxHistorySize) {
                        bandwidthMonitor.speedHistory.shift();
                    }

                    bandwidthMonitor.lastSpeedCheck = now;

                    // æ›´æ–°UIæ˜¾ç¤º
                    this.updateSpeedDisplay(speed);
                }
            }

            // æ›´æ–°é€Ÿåº¦æ˜¾ç¤º
            updateSpeedDisplay(speed) {
                const speedEl = document.getElementById('transferSpeed');
                if (speedEl) {
                    speedEl.textContent = `${speed.toFixed(1)} KB/s`;
                }

                // åœ¨æ§åˆ¶å°æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
                if (speed > 0) {
                    console.log(`ä¼ è¾“é€Ÿåº¦: ${speed.toFixed(1)} KB/s, å¹¶å‘æ•°: 30`);
                }
            }

            // åŠ¨æ€è°ƒæ•´å¹¶å‘æ•° (å·²ç¦ç”¨ï¼Œä½¿ç”¨å›ºå®š30å¹¶å‘)
            adjustConcurrencyDynamically() {
                // ä¸å†åŠ¨æ€è°ƒæ•´ï¼Œä½¿ç”¨å›ºå®š30å¹¶å‘
                return;
            }

            // è·å–å¹³å‡é€Ÿåº¦
            getAverageSpeed() {
                if (bandwidthMonitor.speedHistory.length === 0) return 0;

                const sum = bandwidthMonitor.speedHistory.reduce((a, b) => a + b, 0);
                return sum / bandwidthMonitor.speedHistory.length;
            }

            // è®¡ç®—ä¼ è¾“å»¶è¿Ÿ - å¤§å¹…å‡å°‘å»¶è¿Ÿ
            calculateDelay() {
                const avgSpeed = this.getAverageSpeed();

                // å¤§å¹…å‡å°‘å»¶è¿Ÿä»¥æé«˜ä¼ è¾“é€Ÿåº¦
                if (avgSpeed > 1000) {
                    return 0; // é«˜é€Ÿç½‘ç»œï¼Œæ— å»¶è¿Ÿ
                } else if (avgSpeed > 500) {
                    return 1; // ä¸­é«˜é€Ÿç½‘ç»œï¼Œ1mså»¶è¿Ÿ
                } else if (avgSpeed > 200) {
                    return 2; // ä¸­é€Ÿç½‘ç»œï¼Œ2mså»¶è¿Ÿ
                } else if (avgSpeed > 100) {
                    return 5; // ä½é€Ÿç½‘ç»œï¼Œ5mså»¶è¿Ÿ
                } else {
                    return 10; // æ…¢é€Ÿç½‘ç»œï¼Œ10mså»¶è¿Ÿ
                }
            }

            // é‡ç½®å¸¦å®½ç›‘æ§
            resetBandwidthMonitor() {
                bandwidthMonitor.startTime = 0;
                bandwidthMonitor.totalBytes = 0;
                bandwidthMonitor.lastSpeedCheck = 0;
                bandwidthMonitor.currentSpeed = 0;
                bandwidthMonitor.speedHistory = [];
            }

            // é«˜é€Ÿæ‰¹é‡ä¼ è¾“å·¥ä½œçº¿ç¨‹ - æš´åŠ›å‘é€ + æ™ºèƒ½é‡ä¼ 
            async sendChunkWorker(transfer, transferId, config) {
                const file = transfer.file;
                
                // ä¼ è¾“æ¨¡å¼é…ç½® - ç¨³å®šä¼˜å…ˆ
                const isFastMode = true; // é»˜è®¤ä½¿ç”¨é«˜é€Ÿæ¨¡å¼
                const maxConcurrentChunks = 2; // 2å¹¶å‘ï¼Œç¡®ä¿ç¨³å®šæ€§
                const batchSize = 5; // æ‰¹é‡å‘é€å¤§å°è°ƒæ•´ä¸º5
                const retryDelay = 100; // é‡è¯•å»¶è¿Ÿ100ms
                
                // ä¼ è¾“çŠ¶æ€è·Ÿè¸ª
                const sentChunks = new Set(); // å·²å‘é€çš„åˆ†ç‰‡
                const failedChunks = new Set(); // å‘é€å¤±è´¥çš„åˆ†ç‰‡
                const retryChunks = new Map(); // éœ€è¦é‡è¯•çš„åˆ†ç‰‡ {chunkIndex: retryCount}
                let activeSends = 0; // å½“å‰æ´»è·ƒçš„å‘é€æ“ä½œ
                let nextChunkIndex = config.getNextChunkIndex();
                
                // æ–­ç‚¹ç»­ä¼ ï¼šåˆå§‹åŒ–å·²å‘é€åˆ†ç‰‡é›†åˆ
                if (transfer.sentChunkSet && transfer.sentChunkSet.size > 0) {
                    for (const chunkIndex of transfer.sentChunkSet) {
                        sentChunks.add(chunkIndex);
                    }
                    console.log(`æ–­ç‚¹ç»­ä¼ åˆå§‹åŒ–: å·²å‘é€ ${sentChunks.size} ä¸ªåˆ†ç‰‡`);
                }
                
                console.log(`å¯åŠ¨ç¨³å®šä¼ è¾“æ¨¡å¼ï¼Œå¹¶å‘æ•°: ${maxConcurrentChunks}`);

                // é€Ÿåº¦æ§åˆ¶ - æ¯ç§’10ä¸ªåˆ†ç‰‡
                const targetChunksPerSecond = 10;
                const chunkInterval = 1000 / targetChunksPerSecond; // 100msé—´éš”
                let lastChunkTime = 0;
                let chunksSentInCurrentSecond = 0;
                let currentSecondStart = Date.now();

                // ç½‘ç»œçŠ¶æ€ç›‘æ§
                let networkHealthy = true;
                let consecutiveFailures = 0;
                const maxConsecutiveFailures = 20; // å¢åŠ å®¹å¿åº¦ï¼Œé¿å…è¿‡æ—©åˆ¤æ–­ç½‘ç»œä¸ä½³

                // è®¾ç½®åˆ†ç‰‡ç¡®è®¤å¤„ç†å™¨ï¼ˆä»…ç”¨äºé‡ä¼ æ¨¡å¼ï¼‰
                transfer.handleChunkAck = (chunkIndex, success, error) => {
                    if (success) {
                        retryChunks.delete(chunkIndex);
                        console.log(`é‡ä¼ åˆ†ç‰‡ ${chunkIndex} ç¡®è®¤æˆåŠŸ`);
                    } else {
                        const retryCount = retryChunks.get(chunkIndex) || 0;
                        if (retryCount < 3) {
                            retryChunks.set(chunkIndex, retryCount + 1);
                            console.warn(`é‡ä¼ åˆ†ç‰‡ ${chunkIndex} å¤±è´¥ï¼Œå‡†å¤‡é‡è¯• (${retryCount + 1}/3)`);
                        } else {
                            retryChunks.delete(chunkIndex);
                            failedChunks.add(chunkIndex);
                            console.error(`åˆ†ç‰‡ ${chunkIndex} é‡è¯•å¤±è´¥ï¼Œæ”¾å¼ƒ`);
                        }
                    }
                };

                // æ‰¹é‡å‘é€åˆ†ç‰‡ - é«˜é€Ÿæ¨¡å¼ä¸ç­‰å¾…ç¡®è®¤
                const sendChunkBatch = async (chunkIndexes) => {
                    const promises = chunkIndexes.map(async (chunkIndex) => {
                        try {
                            activeSends++;
                            
                            // æ£€æŸ¥WebSocketè¿æ¥çŠ¶æ€
                            if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) {
                                throw new Error('WebSocketè¿æ¥æ–­å¼€');
                            }

                            // è¯»å–åˆ†ç‰‡æ•°æ®
                            const start = chunkIndex * transfer.chunkSize;
                            const end = Math.min(start + transfer.chunkSize, file.size);
                            const chunk = file.slice(start, end);
                            const chunkData = await this.readChunkAsArray(chunk);

                            const chunkMessage = {
                                type: 'realtimeFileChunk',
                                transferId: transferId,
                                targetUserId: transfer.targetUserId,
                                chunkIndex,
                                chunkData,
                                isLast: chunkIndex === transfer.totalChunks - 1,
                                requireAck: false // é«˜é€Ÿæ¨¡å¼ä¸è¦æ±‚ç¡®è®¤
                            };

                            // æ£€æŸ¥ç¼“å†²åŒºçŠ¶æ€
                            if (this.websocket.bufferedAmount > 2 * 1024 * 1024) { // 2MBç¼“å†²åŒºé™åˆ¶
                                console.warn(`WebSocketç¼“å†²åŒºè¿‡å¤§ï¼Œç­‰å¾…æ¸…ç©º...`);
                                await waitForBufferClear();
                            }

                            // å‘é€åˆ†ç‰‡
                            if (this.safeSend(chunkMessage, `å‘é€åˆ†ç‰‡ ${chunkIndex} å¤±è´¥`)) {
                                sentChunks.add(chunkIndex);
                                consecutiveFailures = 0; // é‡ç½®è¿ç»­å¤±è´¥è®¡æ•°
                                
                                // æ›´æ–°è¿›åº¦
                                config.onChunkSent(chunkIndex);
                                
                                // é€Ÿåº¦æ§åˆ¶ - æ¯ç§’10ä¸ªåˆ†ç‰‡
                                const now = Date.now();
                                
                                // æ£€æŸ¥æ˜¯å¦è¿›å…¥æ–°çš„ä¸€ç§’
                                if (now - currentSecondStart >= 1000) {
                                    currentSecondStart = now;
                                    chunksSentInCurrentSecond = 0;
                                }
                                
                                chunksSentInCurrentSecond++;
                                
                                // å¦‚æœå½“å‰ç§’å†…å·²å‘é€10ä¸ªåˆ†ç‰‡ï¼Œç­‰å¾…åˆ°ä¸‹ä¸€ç§’
                                if (chunksSentInCurrentSecond >= targetChunksPerSecond) {
                                    const waitTime = 1000 - (now - currentSecondStart);
                                    if (waitTime > 0) {
                                        console.log(`å·²å‘é€${chunksSentInCurrentSecond}ä¸ªåˆ†ç‰‡ï¼Œç­‰å¾…${waitTime}msåˆ°ä¸‹ä¸€ç§’`);
                                        await new Promise(resolve => setTimeout(resolve, waitTime));
                                        currentSecondStart = Date.now();
                                        chunksSentInCurrentSecond = 0;
                                    }
                                } else {
                                    // åˆ†ç‰‡é—´éš”æ§åˆ¶
                                    const timeSinceLastChunk = now - lastChunkTime;
                                    if (timeSinceLastChunk < chunkInterval) {
                                        const waitTime = chunkInterval - timeSinceLastChunk;
                                        await new Promise(resolve => setTimeout(resolve, waitTime));
                                    }
                                }
                                
                                lastChunkTime = Date.now();
                                
                            } else {
                                throw new Error('WebSocketå‘é€å¤±è´¥');
                            }

                        } catch (error) {
                            consecutiveFailures++;
                            failedChunks.add(chunkIndex);
                            
                            // å¦‚æœè¿ç»­å¤±è´¥è¿‡å¤šï¼Œåˆ‡æ¢åˆ°æ…¢é€Ÿæ¨¡å¼
                            if (consecutiveFailures >= maxConsecutiveFailures) {
                                networkHealthy = false;
                                console.warn(`è¿ç»­å¤±è´¥${consecutiveFailures}æ¬¡ï¼Œç½‘ç»œçŠ¶å†µä¸ä½³ï¼Œé™ä½ä¼ è¾“é€Ÿåº¦`);
                            }
                            
                            console.error(`åˆ†ç‰‡ ${chunkIndex} å‘é€å¤±è´¥:`, error.message);
                            
                            // å‘é€å¤±è´¥æ—¶çŸ­æš‚å»¶è¿Ÿï¼Œé¿å…è¿‡åº¦é‡è¯•
                            await new Promise(resolve => setTimeout(resolve, 50));
                        } finally {
                            activeSends--;
                        }
                    });

                    await Promise.allSettled(promises);
                };

                // ç­‰å¾…ç¼“å†²åŒºæ¸…ç©º - ä¼˜åŒ–æ£€æŸ¥é¢‘ç‡
                const waitForBufferClear = () => {
                    return new Promise((resolve) => {
                        const checkBuffer = () => {
                            if (this.websocket.bufferedAmount < 1024 * 1024) { // ç­‰åˆ°å°äº1MB
                                resolve();
                            } else {
                                setTimeout(checkBuffer, 5); // å‡å°‘åˆ°5mså¿«é€Ÿæ£€æŸ¥
                            }
                        };
                        checkBuffer();
                    });
                };

                // ä¸»ä¼ è¾“å¾ªç¯ - æ‰¹é‡é«˜é€Ÿå‘é€
                try {
                    console.log(`å¼€å§‹æ‰¹é‡ä¼ è¾“ï¼Œæ€»åˆ†ç‰‡: ${transfer.totalChunks}`);
                    
                    // ç¬¬ä¸€é˜¶æ®µï¼šæ‰¹é‡é«˜é€Ÿå‘é€
                    while (config.isActive() && nextChunkIndex !== null && nextChunkIndex < transfer.totalChunks) {
                        // æ§åˆ¶å¹¶å‘æ•° - å›ºå®š2å¹¶å‘
                        while (activeSends >= maxConcurrentChunks && config.isActive()) {
                            await new Promise(resolve => setTimeout(resolve, 5)); // 5msæ£€æŸ¥é—´éš”
                        }
                        
                        if (!config.isActive()) break;
                        
                        // å‡†å¤‡æ‰¹é‡å‘é€çš„åˆ†ç‰‡ - è·³è¿‡å·²å‘é€çš„åˆ†ç‰‡
                        const batch = [];
                        for (let i = 0; i < batchSize && nextChunkIndex < transfer.totalChunks; i++) {
                            // æ£€æŸ¥åˆ†ç‰‡æ˜¯å¦å·²ç»å‘é€è¿‡ï¼ˆæ–­ç‚¹ç»­ä¼ ï¼‰
                            if (!sentChunks.has(nextChunkIndex)) {
                                batch.push(nextChunkIndex);
                            } else {
                                console.log(`è·³è¿‡å·²å‘é€çš„åˆ†ç‰‡ ${nextChunkIndex}`);
                            }
                            nextChunkIndex = config.getNextChunkIndex();
                        }
                        
                        if (batch.length > 0) {
                            // æ‰¹é‡å‘é€
                            await sendChunkBatch(batch);
                            
                            // å¦‚æœç½‘ç»œçŠ¶å†µä¸ä½³ï¼Œè½»å¾®å»¶è¿Ÿ
                            if (!networkHealthy) {
                                await new Promise(resolve => setTimeout(resolve, 10)); // å‡å°‘åˆ°10ms
                            }
                        }
                    }
                    
                    console.log(`æ‰¹é‡å‘é€å®Œæˆï¼Œå·²å‘é€: ${sentChunks.size}/${transfer.totalChunks}, å¤±è´¥: ${failedChunks.size}`);
                    
                    // ç¬¬äºŒé˜¶æ®µï¼šé‡ä¼ å¤±è´¥çš„åˆ†ç‰‡ï¼ˆä½¿ç”¨ç¡®è®¤æ¨¡å¼ï¼‰
                    if (failedChunks.size > 0) {
                        console.log(`å¼€å§‹é‡ä¼ å¤±è´¥çš„åˆ†ç‰‡: ${failedChunks.size} ä¸ª`);
                        
                        for (const chunkIndex of failedChunks) {
                            if (!config.isActive()) break;
                            
                            try {
                                // é‡ä¼ æ—¶ä½¿ç”¨ç¡®è®¤æ¨¡å¼
                                await this.sendChunkWithAck(chunkIndex, transfer, transferId);
                                retryChunks.set(chunkIndex, 1);
                                
                                // é‡ä¼ å»¶è¿Ÿ - å‡å°‘å»¶è¿Ÿ
                                await new Promise(resolve => setTimeout(resolve, 100)); // å‡å°‘åˆ°100ms
                                
                            } catch (error) {
                                console.error(`é‡ä¼ åˆ†ç‰‡ ${chunkIndex} å¤±è´¥:`, error);
                            }
                        }
                    }
                    
                    // ç­‰å¾…æ‰€æœ‰é‡ä¼ å®Œæˆ
                    const maxWaitTime = 30000; // æœ€å¤šç­‰å¾…30ç§’
                    const startWait = Date.now();
                    
                    while (retryChunks.size > 0 && Date.now() - startWait < maxWaitTime && config.isActive()) {
                        await new Promise(resolve => setTimeout(resolve, 100)); // å‡å°‘åˆ°100msæ£€æŸ¥
                    }
                    
                    const totalSent = sentChunks.size + (failedChunks.size - retryChunks.size);
                    console.log(`ä¼ è¾“å®Œæˆï¼ŒæˆåŠŸ: ${totalSent}/${transfer.totalChunks}, æœ€ç»ˆå¤±è´¥: ${retryChunks.size}`);
                    
                } catch (error) {
                    console.error('æ‰¹é‡ä¼ è¾“å¤±è´¥:', error);
                    config.onError(error.message);
                }
            }

            // å¸¦ç¡®è®¤çš„åˆ†ç‰‡å‘é€ï¼ˆä»…ç”¨äºé‡ä¼ ï¼‰
            async sendChunkWithAck(chunkIndex, transfer, transferId) {
                return new Promise(async (resolve, reject) => {
                    try {
                        const file = transfer.file;
                        
                        // è¯»å–åˆ†ç‰‡æ•°æ®
                        const start = chunkIndex * transfer.chunkSize;
                        const end = Math.min(start + transfer.chunkSize, file.size);
                        const chunk = file.slice(start, end);
                        const chunkData = await this.readChunkAsArray(chunk);

                        const chunkMessage = {
                            type: 'realtimeFileChunk',
                            transferId: transferId,
                            targetUserId: transfer.targetUserId,
                            chunkIndex,
                            chunkData,
                            isLast: chunkIndex === transfer.totalChunks - 1,
                            requireAck: true // é‡ä¼ æ—¶è¦æ±‚ç¡®è®¤
                        };

                        // è®¾ç½®è¶…æ—¶
                        const timeout = setTimeout(() => {
                            reject(new Error(`åˆ†ç‰‡ ${chunkIndex} é‡ä¼ è¶…æ—¶`));
                        }, 10000);

                        // ä¸´æ—¶ç¡®è®¤å¤„ç†å™¨
                        const originalHandler = transfer.handleChunkAck;
                        transfer.handleChunkAck = (ackChunkIndex, success, error) => {
                            if (ackChunkIndex === chunkIndex) {
                                clearTimeout(timeout);
                                transfer.handleChunkAck = originalHandler; // æ¢å¤åŸå¤„ç†å™¨
                                
                                if (success) {
                                    resolve();
                                } else {
                                    reject(new Error(`åˆ†ç‰‡ ${chunkIndex} é‡ä¼ å¤±è´¥: ${error}`));
                                }
                            } else if (originalHandler) {
                                originalHandler(ackChunkIndex, success, error);
                            }
                        };

                        // å‘é€åˆ†ç‰‡
                        if (!this.safeSend(chunkMessage, `é‡ä¼ åˆ†ç‰‡ ${chunkIndex} å¤±è´¥`)) {
                            clearTimeout(timeout);
                            transfer.handleChunkAck = originalHandler;
                            reject(new Error('WebSocketå‘é€å¤±è´¥'));
                        }

                    } catch (error) {
                        reject(error);
                    }
                });
            }

            // é«˜æ•ˆçš„ArrayBufferåˆ°Base64è½¬æ¢
            arrayBufferToBase64(uint8Array) {
                // ä½¿ç”¨æ›´å°çš„åˆ†å—é¿å…è°ƒç”¨æ ˆæº¢å‡º
                let binary = '';
                const chunkSize = 8192; // 8KB chunks to be safe
                
                for (let i = 0; i < uint8Array.length; i += chunkSize) {
                    const chunk = uint8Array.subarray(i, i + chunkSize);
                    // ä½¿ç”¨applyæ–¹æ³•æ›´å®‰å…¨
                    binary += String.fromCharCode.apply(null, Array.from(chunk));
                }
                
                return btoa(binary);
            }

            // é«˜æ•ˆçš„Base64åˆ°ArrayBufferè½¬æ¢
            base64ToArrayBuffer(base64) {
                const binaryString = atob(base64);
                const bytes = new Uint8Array(binaryString.length);
                
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                
                return bytes;
            }

            // å¼‚æ­¥è¯»å–åˆ†ç‰‡æ•°æ® - ä½¿ç”¨Base64ç¼–ç 
            readChunkAsArray(chunk) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        if (e.target?.result) {
                            // ä½¿ç”¨ç°ä»£çš„Base64ç¼–ç æ–¹æ³•
                            const uint8Array = new Uint8Array(e.target.result);
                            
                            // ä½¿ç”¨æ›´é«˜æ•ˆçš„æ–¹æ³•è½¬æ¢ä¸ºBase64
                            const base64Data = this.arrayBufferToBase64(uint8Array);
                            resolve(base64Data);
                        } else {
                            reject(new Error('è¯»å–åˆ†ç‰‡æ•°æ®å¤±è´¥'));
                        }
                    };
                    reader.onerror = () => reject(new Error('FileReaderé”™è¯¯'));
                    reader.readAsArrayBuffer(chunk);
                });
            }

            handleFileChunk(message) {
                console.log(`æ¥æ”¶åˆ°åˆ†ç‰‡æ¶ˆæ¯:`, message);
                const transfer = activeTransfers.get(message.transferId);
                if (!transfer || transfer.type !== 'receive') {
                    console.warn(`æœªæ‰¾åˆ°æ¥æ”¶ä¼ è¾“:`, message.transferId, transfer?.type);
                    return;
                }

                const { chunkIndex, chunkData, isLast, requireAck, senderId } = message;
                console.log(`å¤„ç†åˆ†ç‰‡ ${chunkIndex}, requireAck=${requireAck}, senderId=${senderId}`);

                try {
                    // éªŒè¯åˆ†ç‰‡æ•°æ®
                    if (!chunkData || typeof chunkData !== 'string') {
                        throw new Error('Invalid chunk data');
                    }

                    // å­˜å‚¨åˆ†ç‰‡ï¼ˆæ£€æŸ¥æ˜¯å¦é‡å¤ï¼‰
                    if (transfer.receivedChunks.has(chunkIndex)) {
                        console.warn(`æ”¶åˆ°é‡å¤åˆ†ç‰‡ ${chunkIndex}ï¼Œå¿½ç•¥`);
                        return; // å¿½ç•¥é‡å¤åˆ†ç‰‡
                    }
                    
                    transfer.receivedChunks.set(chunkIndex, chunkData);
                    transfer.progress = Math.min((transfer.receivedChunks.size / transfer.metadata.totalChunks) * 100, 100);

                    // å‘é€åˆ†ç‰‡ç¡®è®¤ï¼ˆä»…åœ¨é‡ä¼ æ¨¡å¼ä¸‹éœ€è¦ï¼‰
                    if (requireAck) {
                        const ackMessage = {
                            type: 'fileChunkAck',
                            transferId: message.transferId,
                            chunkIndex,
                            success: true,
                            senderId: senderId || message.senderId
                        };
                        
                        console.log(`å‘é€é‡ä¼ åˆ†ç‰‡ ${chunkIndex} ç¡®è®¤`);
                        this.safeSend(ackMessage, `å‘é€åˆ†ç‰‡ç¡®è®¤å¤±è´¥`);
                    }

                    this.updateTransferStatus();

                    // æ£€æŸ¥æ˜¯å¦æ¥æ”¶å®Œæˆ
                    if (transfer.receivedChunks.size === transfer.metadata.totalChunks) {
                        this.assembleReceivedFile(transfer, message.transferId);
                    }

                } catch (error) {
                    console.error(`å¤„ç†åˆ†ç‰‡ ${chunkIndex} å¤±è´¥:`, error);
                    
                    // å‘é€åˆ†ç‰‡å¤±è´¥ç¡®è®¤
                    if (requireAck) {
                        const ackMessage = {
                            type: 'fileChunkAck',
                            transferId: message.transferId,
                            chunkIndex,
                            success: false,
                            error: error.message,
                            senderId: senderId || message.senderId // ä½¿ç”¨è§£æ„çš„senderId
                        };
                        
                        this.safeSend(ackMessage, `å‘é€åˆ†ç‰‡å¤±è´¥ç¡®è®¤å¤±è´¥`);
                    }
                }
            }

            // æ£€æŸ¥æ˜¯å¦ä¸ºåª’ä½“æ–‡ä»¶ï¼ˆå›¾ç‰‡/è§†é¢‘ï¼‰
            isMediaFile(fileType) {
                return fileType.startsWith('image/') || fileType.startsWith('video/');
            }

            async assembleReceivedFile(transfer, transferId) {
                try {
                    const chunks = [];

                    // æŒ‰é¡ºåºç»„è£…åˆ†ç‰‡
                    for (let i = 0; i < transfer.metadata.totalChunks; i++) {
                        const base64Data = transfer.receivedChunks.get(i);
                        if (!base64Data) {
                            throw new Error(`Missing chunk ${i}`);
                        }
                        // ä½¿ç”¨é«˜æ•ˆçš„Base64è§£ç æ–¹æ³•
                        const chunkData = this.base64ToArrayBuffer(base64Data);
                        chunks.push(chunkData);
                    }

                    // åˆå¹¶æ‰€æœ‰åˆ†ç‰‡
                    const totalSize = chunks.reduce((size, chunk) => size + chunk.length, 0);
                    const fileData = new Uint8Array(totalSize);
                    let offset = 0;

                    for (const chunk of chunks) {
                        fileData.set(chunk, offset);
                        offset += chunk.length;
                    }

                    // éªŒè¯æ–‡ä»¶å®Œæ•´æ€§
                    const receivedHash = await this.calculateMD5FromBuffer(fileData.buffer);
                    if (receivedHash !== transfer.metadata.fileHash) {
                        throw new Error('File integrity check failed');
                    }

                    // åˆ›å»ºæ–‡ä»¶å¯¹è±¡
                    const blob = new Blob([fileData], { type: transfer.metadata.fileType });
                    const file = new File([blob], transfer.metadata.fileName, {
                        type: transfer.metadata.fileType
                    });

                    transfer.status = 'completed';
                    transfer.progress = 100;
                    this.updateTransferStatus();

                    // åŒºåˆ†å¤„ç†å›¾ç‰‡/è§†é¢‘å’Œæ™®é€šæ–‡ä»¶
                    // å‘é€æ¥æ”¶å®Œæˆç¡®è®¤ç»™å‘é€ç«¯
                    const confirmationMessage = {
                        type: 'fileTransferConfirmation',
                        transferId: transferId,
                        senderId: transfer.senderId,
                        success: true,
                        message: 'File received and verified successfully'
                    };
                    
                    this.safeSend(confirmationMessage, 'å‘é€æ¥æ”¶ç¡®è®¤å¤±è´¥');
                    console.log(`å‘é€æ¥æ”¶ç¡®è®¤ç»™å‘é€ç«¯: ${transferId}`);

                    if (this.isMediaFile(transfer.metadata.fileType)) {
                        // å›¾ç‰‡/è§†é¢‘ç›´æ¥æ˜¾ç¤ºåœ¨èŠå¤©ä¸­
                        const mediaUrl = URL.createObjectURL(blob);
                        displaySystemMessage(`${transfer.metadata.fileType.startsWith('image/') ? 'å›¾ç‰‡' : 'è§†é¢‘'} "${file.name}" æ¥æ”¶å®Œæˆ`);
                        displayMediaMessage(transfer.senderId, file, 'received', transfer.metadata.fileHash, mediaUrl);
                    } else {
                        // æ™®é€šæ–‡ä»¶è‡ªåŠ¨ä¸‹è½½
                        this.downloadFile(file);
                        displaySystemMessage(`æ–‡ä»¶ "${file.name}" æ¥æ”¶å®Œæˆå¹¶å·²ä¸‹è½½`);
                        displayFileMessage(transfer.senderId, file, 'received', transfer.metadata.fileHash);
                    }

                    setTimeout(() => activeTransfers.delete(transferId), 5000);

                } catch (error) {
                    console.error('File assembly failed:', error);
                    
                    // å‘é€æ¥æ”¶å¤±è´¥ç¡®è®¤ç»™å‘é€ç«¯
                    const confirmationMessage = {
                        type: 'fileTransferConfirmation',
                        transferId: transferId,
                        senderId: transfer.senderId,
                        success: false,
                        message: `File assembly failed: ${error.message}`
                    };
                    
                    this.safeSend(confirmationMessage, 'å‘é€æ¥æ”¶å¤±è´¥ç¡®è®¤å¤±è´¥');
                    
                    transfer.status = 'failed';
                    this.updateTransferStatus();
                    displaySystemMessage(`æ–‡ä»¶æ¥æ”¶å¤±è´¥: ${error.message}`);
                }
            }

            // å¤„ç†æ¥æ”¶ç«¯ç¡®è®¤æ¶ˆæ¯
            handleTransferConfirmation(message) {
                const transfer = activeTransfers.get(message.transferId);
                if (!transfer || transfer.type !== 'send') {
                    console.warn('Received confirmation for unknown or non-send transfer:', message.transferId);
                    return;
                }

                console.log(`æ”¶åˆ°æ¥æ”¶ç«¯ç¡®è®¤: ${message.transferId}, æˆåŠŸ: ${message.success}`);
                
                if (message.success) {
                    console.log(`ä¼ è¾“çœŸæ­£å®Œæˆ: ${transfer.file?.name}`);
                    transfer.status = 'completed';
                    this.updateTransferStatus();
                    displaySystemMessage(`æ–‡ä»¶ "${transfer.file.name}" ä¼ è¾“å®Œæˆå¹¶å·²è¢«å¯¹æ–¹æ¥æ”¶`);
                    setTimeout(() => activeTransfers.delete(message.transferId), 5000);
                } else {
                    console.error(`æ¥æ”¶ç«¯æŠ¥å‘Šå¤±è´¥: ${message.message}`);
                    transfer.status = 'failed';
                    transfer.error = message.message;
                    this.updateTransferStatus();
                    displaySystemMessage(`æ–‡ä»¶ä¼ è¾“å¤±è´¥: ${message.message}`, 'error');
                }
            }

            // å¤„ç†åˆ†ç‰‡ç¡®è®¤æ¶ˆæ¯
            handleFileChunkAck(message) {
                console.log(`æ”¶åˆ°åˆ†ç‰‡ç¡®è®¤:`, message);
                const transfer = activeTransfers.get(message.transferId);
                if (!transfer || transfer.type !== 'send') {
                    console.warn(`æœªæ‰¾åˆ°ä¼ è¾“æˆ–ç±»å‹ä¸åŒ¹é…:`, message.transferId, transfer?.type);
                    return;
                }

                // å¦‚æœä¼ è¾“æœ‰åˆ†ç‰‡ç¡®è®¤å¤„ç†å™¨ï¼Œè°ƒç”¨å®ƒ
                if (transfer.handleChunkAck) {
                    transfer.handleChunkAck(message.chunkIndex, message.success, message.error);
                } else {
                    console.warn(`ä¼ è¾“æ²¡æœ‰åˆ†ç‰‡ç¡®è®¤å¤„ç†å™¨:`, message.transferId);
                }
            }

            downloadFile(file) {
                const url = URL.createObjectURL(file);
                const a = document.createElement('a');
                a.href = url;
                a.download = file.name;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            cancelTransfer(transferId) {
                const transfer = activeTransfers.get(transferId);
                if (!transfer) return;

                const cancelMessage = {
                    type: 'fileTransferCancel',
                    transferId,
                    targetUserId: transfer.targetUserId || transfer.senderId
                };

                this.safeSend(cancelMessage, 'å‘é€å–æ¶ˆæ¶ˆæ¯å¤±è´¥');

                activeTransfers.delete(transferId);
                this.updateTransferStatus();

                displaySystemMessage('æ–‡ä»¶ä¼ è¾“å·²å–æ¶ˆ');
            }

            handleTransferCancel(message) {
                const transfer = activeTransfers.get(message.transferId);
                if (transfer) {
                    activeTransfers.delete(message.transferId);
                    this.updateTransferStatus();
                    displaySystemMessage(`${getUserName(message.senderId)} å–æ¶ˆäº†æ–‡ä»¶ä¼ è¾“`);
                }

                // æ¸…ç†å¾…å¤„ç†çš„ä¼ è¾“ä¿¡æ¯
                if (this.pendingTransfers) {
                    this.pendingTransfers.delete(message.transferId);
                }
            }

            // æ‰‹åŠ¨æ¢å¤ä¼ è¾“
            resumeTransfer(transferId) {
                const transfer = activeTransfers.get(transferId);
                if (transfer && transfer.status === 'paused' && transfer.resumeTransfer) {
                    transfer.resumeTransfer();
                } else {
                    displaySystemMessage('æ— æ³•æ¢å¤ä¼ è¾“ï¼šä¼ è¾“ä¸å­˜åœ¨æˆ–çŠ¶æ€ä¸æ­£ç¡®', 'error');
                }
            }

            // é‡è¯•å¤±è´¥çš„ä¼ è¾“
            retryTransfer(transferId) {
                const transfer = activeTransfers.get(transferId);
                if (transfer && transfer.status === 'failed' && transfer.type === 'send') {
                    // é‡ç½®ä¼ è¾“çŠ¶æ€
                    transfer.status = 'requesting';
                    transfer.sentChunks = 0;
                    transfer.progress = 0;
                    transfer.error = null;

                    // é‡æ–°å‘èµ·ä¼ è¾“è¯·æ±‚
                    const transferRequest = {
                        type: 'fileTransferRequest',
                        transferId: transferId,
                        targetUserId: transfer.targetUserId,
                        metadata: {
                            fileName: transfer.file.name,
                            fileSize: transfer.file.size,
                            fileType: transfer.file.type,
                            fileHash: transfer.fileHash,
                            totalChunks: transfer.totalChunks,
                            chunkSize: transfer.chunkSize
                        }
                    };

                    if (this.safeSend(transferRequest, 'é‡è¯•ä¼ è¾“è¯·æ±‚å¤±è´¥')) {
                        this.updateTransferStatus();
                        displaySystemMessage(`æ­£åœ¨é‡è¯•å‘é€æ–‡ä»¶: ${transfer.file.name}`, 'info');
                    }
                } else {
                    displaySystemMessage('æ— æ³•é‡è¯•ä¼ è¾“ï¼šä¼ è¾“ä¸å­˜åœ¨æˆ–çŠ¶æ€ä¸æ­£ç¡®', 'error');
                }
            }

            updateTransferStatus() {
                if (activeTransfers.size === 0) {
                    transferStatusEl.classList.remove('show');
                    return;
                }

                transferStatusEl.classList.add('show');
                transferListEl.innerHTML = '';

                activeTransfers.forEach((transfer, transferId) => {
                    const transferEl = document.createElement('div');
                    transferEl.className = 'transfer-item';

                    const fileName = transfer.file ? transfer.file.name : transfer.metadata?.fileName || 'Unknown';
                    const peerName = getUserName(transfer.targetUserId || transfer.senderId);
                    const statusText = this.getStatusText(transfer.status);

                    // æ„å»ºæ“ä½œæŒ‰é’®
                    let actionButtons = '';
                    if (transfer.status === 'paused' && transfer.type === 'send') {
                        actionButtons = `<button onclick="fileTransferManager.resumeTransfer('${transferId}')" class="download-btn">ç»§ç»­</button>`;
                    } else if (transfer.status === 'requesting' || transfer.status === 'sending' || transfer.status === 'receiving') {
                        actionButtons = `<button onclick="fileTransferManager.cancelTransfer('${transferId}')" class="cancel-btn">å–æ¶ˆ</button>`;
                    } else if (transfer.status === 'failed' && transfer.type === 'send') {
                        actionButtons = `<button onclick="fileTransferManager.retryTransfer('${transferId}')" class="download-btn">é‡è¯•</button>`;
                    }

                    // æ„å»ºè¯¦ç»†çŠ¶æ€ä¿¡æ¯
                    let statusInfo = `${transfer.type === 'send' ? 'å‘é€ç»™' : 'æ¥æ”¶è‡ª'} ${peerName} - ${statusText}`;
                    
                    // æ ¹æ®çŠ¶æ€æ˜¾ç¤ºä¸åŒä¿¡æ¯
                    if (transfer.status === 'preparing') {
                        statusInfo += ' - æ­£åœ¨è®¡ç®—æ–‡ä»¶å“ˆå¸Œå’Œåˆ†ç‰‡...';
                    } else if (transfer.status === 'waiting_confirmation') {
                        statusInfo += ' - ç­‰å¾…å¯¹æ–¹ç¡®è®¤æ¥æ”¶å®Œæˆ...';
                    } else if (transfer.status === 'sending' || transfer.status === 'receiving') {
                        if (transfer.sentChunks || (transfer.receivedChunks && transfer.receivedChunks.size)) {
                            let current, total;
                            
                            if (transfer.type === 'send') {
                                // å‘é€ç«¯ï¼šä½¿ç”¨sentChunkSetçš„å¤§å°ï¼Œç¡®ä¿ä¸è¶…è¿‡æ€»æ•°
                                current = Math.min(transfer.sentChunkSet?.size || transfer.sentChunks || 0, transfer.totalChunks || 0);
                                total = transfer.totalChunks || 0;
                            } else {
                                // æ¥æ”¶ç«¯ï¼šä½¿ç”¨receivedChunksçš„å¤§å°
                                current = transfer.receivedChunks?.size || 0;
                                total = transfer.metadata?.totalChunks || 0;
                            }
                            
                            statusInfo += ` (${current}/${total})`;
                            
                            // æ˜¾ç¤ºä¼ è¾“é€Ÿåº¦ï¼ˆåªåœ¨å®é™…ä¼ è¾“æ—¶æ˜¾ç¤ºï¼‰
                            if (bandwidthMonitor.currentSpeed > 0 && transfer.status !== 'preparing') {
                                statusInfo += ` - ${bandwidthMonitor.currentSpeed.toFixed(1)} KB/s`;
                            }
                        }
                    }

                    transferEl.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="font-weight: bold;">${fileName}</div>
                                <div style="font-size: 0.8em; color: #ccc;">
                                    ${statusInfo}
                                </div>
                            </div>
                            <div style="display: flex; gap: 5px;">
                                ${actionButtons}
                            </div>
                        </div>
                        <div class="file-progress" style="margin-top: 5px;">
                            <div class="file-progress-bar" style="width: ${transfer.progress}%"></div>
                        </div>
                    `;

                    transferListEl.appendChild(transferEl);
                });
            }

            getStatusText(status) {
                const statusMap = {
                    'requesting': 'è¯·æ±‚ä¸­',
                    'preparing': 'å‡†å¤‡å‘é€',
                    'sending': 'å‘é€ä¸­',
                    'receiving': 'æ¥æ”¶ä¸­',
                    'waiting_confirmation': 'ç­‰å¾…ç¡®è®¤',
                    'paused': 'å·²æš‚åœ',
                    'completed': 'å·²å®Œæˆ',
                    'failed': 'å¤±è´¥',
                    'cancelled': 'å·²å–æ¶ˆ'
                };
                return statusMap[status] || status;
            }

            async calculateMD5(file) {
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        if (e.target?.result) {
                            const hash = await this.calculateMD5FromBuffer(e.target.result);
                            resolve(hash);
                        }
                    };
                    reader.readAsArrayBuffer(file);
                });
            }

            async calculateMD5FromBuffer(buffer) {
                const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            }

            generateTransferId() {
                return Date.now().toString(36) + Math.random().toString(36).substr(2);
            }
        }

        // åˆå§‹åŒ–
        async function init() {
            roomId = getRoomIdFromUrl();

            // ä»æœ¬åœ°å­˜å‚¨åŠ è½½å¯†é’¥
            loadKeysFromStorage();

            // è¿æ¥ WebSocket
            connectWebSocket();

            // åˆå§‹åŒ–è¯­éŸ³åŠŸèƒ½
            initVoiceSupport();

            // åˆå§‹åŒ–éŸ³é¢‘æ’­æ”¾ä¸Šä¸‹æ–‡ï¼ˆéœ€è¦ç”¨æˆ·äº¤äº’ï¼‰
            initAudioContextOnUserInteraction();

            // æ˜¾ç¤ºæ™ºèƒ½æ’­æ”¾åŠŸèƒ½ä¿¡æ¯
            console.log('ğŸ§  æ™ºèƒ½éŸ³é¢‘æ’­æ”¾å·²å¯ç”¨');
            console.log('âœ¨ åŠŸèƒ½ç‰¹æ€§:');
            console.log('  - è‡ªåŠ¨æ£€æµ‹éŸ³é¢‘å¤´ä¿¡æ¯å—');
            console.log('  - æ™ºèƒ½åˆå¹¶æ’­æ”¾ç­–ç•¥');
            console.log('  - å®æ—¶æ’­æ”¾æˆåŠŸç‡ç›‘æ§');
            console.log('  - å¤šé‡æ’­æ”¾æ–¹æ³•fallback');

            // ç»‘å®šäº‹ä»¶
            bindEvents();

            // æ˜¾ç¤ºæˆ¿é—´é“¾æ¥
            displayRoomUrl();
        }

        function bindEvents() {
            sendButtonEl.addEventListener('click', sendMessage);
            messageInputEl.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });

            generateKeysBtn.addEventListener('click', generateKeys);
            importPublicKeyBtn.addEventListener('click', importPublicKey);
            importPrivateKeyBtn.addEventListener('click', importPrivateKey);
            copyPublicKeyBtn.addEventListener('click', copyPublicKey);

            fileBtnEl.addEventListener('click', () => fileInputEl.click());
            imageBtnEl.addEventListener('click', () => imageInputEl.click());
            videoBtnEl.addEventListener('click', () => videoInputEl.click());
            fileInputEl.addEventListener('change', handleFileSelect);
            imageInputEl.addEventListener('change', handleImageSelect);
            videoInputEl.addEventListener('change', handleVideoSelect);
            voiceBtnEl.addEventListener('click', toggleVoiceRecording);
            liveVoiceBtnEl.addEventListener('click', toggleLiveVoice);
        }

        function getRoomIdFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('room') || generateRoomId();
        }

        function generateRoomId() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            let result = '';
            for (let i = 0; i < 64; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/api/room/${roomId}/websocket`;

            websocket = new WebSocket(wsUrl);

            websocket.onopen = () => {
                connectionStatusEl.textContent = 'å·²è¿æ¥';
                connectionStatusEl.className = 'connection-status status-connected';

                // é‡ç½®é‡è¿è®¡æ•°
                resetConnectionRetry();

                // å¼€å§‹è¿æ¥ç›‘æ§
                startConnectionMonitoring();

                // åˆå§‹åŒ–æ–‡ä»¶ä¼ è¾“ç®¡ç†å™¨
                fileTransferManager = new FileTransferManager(websocket);

                if (publicKey) {
                    registerUser();
                }

                // æ¢å¤æš‚åœçš„æ–‡ä»¶ä¼ è¾“
                resumePausedTransfers();

                showNotification('è¿æ¥å·²å»ºç«‹', 'success');
            };

            websocket.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    handleWebSocketMessage(message);
                } catch (error) {
                    console.error('è§£æWebSocketæ¶ˆæ¯å¤±è´¥:', error);
                }
            };

            websocket.onclose = (event) => {
                connectionStatusEl.textContent = 'è¿æ¥æ–­å¼€';
                connectionStatusEl.className = 'connection-status status-disconnected';

                // åœæ­¢è¿æ¥ç›‘æ§
                stopConnectionMonitoring();

                // æš‚åœæ‰€æœ‰æ´»è·ƒçš„æ–‡ä»¶ä¼ è¾“
                pauseActiveTransfers();

                // æ¸…ç†æ™ºèƒ½æ’­æ”¾æ•°æ®
                clearSmartPlaybackData();

                console.log('WebSocketè¿æ¥å…³é—­:', event.code, event.reason);

                // å¦‚æœä¸æ˜¯ä¸»åŠ¨å…³é—­ï¼Œå°è¯•é‡è¿
                if (event.code !== 1000) { // 1000 = æ­£å¸¸å…³é—­
                    attemptReconnection();
                }
            };

            websocket.onerror = (error) => {
                console.error('WebSocket error:', error);
                showNotification('è¿æ¥é”™è¯¯: ' + (error.message || 'æœªçŸ¥é”™è¯¯'), 'error');
            };
        }

        function handleWebSocketMessage(message) {
            switch (message.type) {
                case 'registered':
                    handleRegistered(message);
                    break;
                case 'userList':
                    handleUserList(message);
                    break;
                case 'encryptedMessage':
                    handleEncryptedMessage(message);
                    break;
                case 'fileTransferRequestNotification':
                    fileTransferManager.handleTransferRequest(message);
                    break;
                case 'fileTransferResponseNotification':
                    fileTransferManager.handleTransferResponse(message);
                    break;
                case 'realtimeFileChunkNotification':
                    fileTransferManager.handleFileChunk(message);
                    break;
                case 'fileTransferCancelNotification':
                    fileTransferManager.handleTransferCancel(message);
                    break;
                case 'fileTransferConfirmationNotification':
                    fileTransferManager.handleTransferConfirmation(message);
                    break;
                case 'fileChunkAckNotification':
                    fileTransferManager.handleFileChunkAck(message);
                    break;
                case 'voiceNotification':
                    handleVoiceMessage(message);
                    break;
                case 'liveAudioNotification':
                    handleLiveAudio(message);
                    break;
                case 'error':
                    showNotification(message.message, 'error');
                    break;
            }
        }

        function handleRegistered(message) {
            userId = message.profile.id;
            userName = message.profile.name;

            messageInputEl.disabled = false;
            sendButtonEl.disabled = false;

            showNotification('æ³¨å†ŒæˆåŠŸ');

            // è¯·æ±‚ç”¨æˆ·åˆ—è¡¨
            websocket.send(JSON.stringify({ type: 'getUsers' }));
        }

        function handleUserList(message) {
            users.clear();
            message.users.forEach(user => {
                users.set(user.id, user);
            });
            updateUserList();
        }

        function updateUserList() {
            userListEl.innerHTML = '';

            users.forEach((user, id) => {
                const userEl = document.createElement('div');
                userEl.className = `user-item ${id === userId ? 'self' : ''}`;

                userEl.innerHTML = `
                    <div class="user-name">${user.name}</div>
                    <div class="user-id">${user.id}</div>
                    ${id !== userId ? `
                        <button class="file-transfer-btn" onclick="selectFileForUser('${id}')">
                            å‘é€æ–‡ä»¶
                        </button>
                    ` : ''}
                `;

                userListEl.appendChild(userEl);
            });
        }

        function selectFileForUser(peerId) {
            const input = document.createElement('input');
            input.type = 'file';
            input.multiple = true;
            input.onchange = (e) => {
                const files = Array.from(e.target.files);
                files.forEach(file => sendFileToUser(peerId, file));
            };
            input.click();
        }

        async function sendFileToUser(peerId, file) {
            if (!fileTransferManager) {
                showNotification('æ–‡ä»¶ä¼ è¾“ç®¡ç†å™¨æœªåˆå§‹åŒ–', 'error');
                return;
            }

            try {
                await fileTransferManager.initiateFileTransfer(peerId, file);
            } catch (error) {
                console.error('Failed to send file:', error);
                showNotification(`æ–‡ä»¶å‘é€å¤±è´¥: ${error.message}`, 'error');
            }
        }

        function handleFileSelect(event) {
            const files = Array.from(event.target.files);
            if (files.length === 0) return;

            // å¦‚æœåªæœ‰ä¸€ä¸ªåœ¨çº¿ç”¨æˆ·ï¼ˆé™¤äº†è‡ªå·±ï¼‰ï¼Œç›´æ¥å‘é€
            const otherUsers = Array.from(users.keys()).filter(id => id !== userId);
            if (otherUsers.length === 1) {
                files.forEach(file => sendFileToUser(otherUsers[0], file));
            } else if (otherUsers.length > 1) {
                // è®©ç”¨æˆ·é€‰æ‹©å‘é€ç»™è°
                const userNames = otherUsers.map(id => `${id}: ${getUserName(id)}`).join('\n');
                const selectedUserId = prompt(`é€‰æ‹©å‘é€ç»™å“ªä¸ªç”¨æˆ·:\n${userNames}\n\nè¯·è¾“å…¥ç”¨æˆ·ID:`);
                if (selectedUserId && users.has(selectedUserId)) {
                    files.forEach(file => sendFileToUser(selectedUserId, file));
                }
            } else {
                showNotification('æ²¡æœ‰å…¶ä»–åœ¨çº¿ç”¨æˆ·', 'warning');
            }

            // æ¸…ç©ºæ–‡ä»¶è¾“å…¥
            event.target.value = '';
        }

        function handleImageSelect(event) {
            const files = Array.from(event.target.files);
            if (files.length === 0) return;

            files.forEach(file => {
                if (file.type.startsWith('image/')) {
                    sendMediaFile(file, 'image');
                } else {
                    showNotification('è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶', 'error');
                }
            });

            event.target.value = '';
        }

        function handleVideoSelect(event) {
            const files = Array.from(event.target.files);
            if (files.length === 0) return;

            files.forEach(file => {
                if (file.type.startsWith('video/')) {
                    sendMediaFile(file, 'video');
                } else {
                    showNotification('è¯·é€‰æ‹©è§†é¢‘æ–‡ä»¶', 'error');
                }
            });

            event.target.value = '';
        }

        function sendMediaFile(file, mediaType) {
            // å¦‚æœåªæœ‰ä¸€ä¸ªåœ¨çº¿ç”¨æˆ·ï¼ˆé™¤äº†è‡ªå·±ï¼‰ï¼Œç›´æ¥å‘é€
            const otherUsers = Array.from(users.keys()).filter(id => id !== userId);
            if (otherUsers.length === 1) {
                sendFileToUser(otherUsers[0], file);
                // ä¸ºå‘é€æ–¹æ˜¾ç¤ºåª’ä½“é¢„è§ˆ
                const mediaUrl = URL.createObjectURL(file);
                displayMediaMessage(userId, file, 'sent', null, mediaUrl);
            } else if (otherUsers.length > 1) {
                // è®©ç”¨æˆ·é€‰æ‹©å‘é€ç»™è°
                const userNames = otherUsers.map(id => `${id}: ${getUserName(id)}`).join('\n');
                const selectedUserId = prompt(`é€‰æ‹©å‘é€ç»™å“ªä¸ªç”¨æˆ·:\n${userNames}\n\nè¯·è¾“å…¥ç”¨æˆ·ID:`);
                if (selectedUserId && users.has(selectedUserId)) {
                    sendFileToUser(selectedUserId, file);
                    // ä¸ºå‘é€æ–¹æ˜¾ç¤ºåª’ä½“é¢„è§ˆ
                    const mediaUrl = URL.createObjectURL(file);
                    displayMediaMessage(userId, file, 'sent', null, mediaUrl);
                }
            } else {
                showNotification('æ²¡æœ‰å…¶ä»–åœ¨çº¿ç”¨æˆ·', 'warning');
            }
        }



        function showMediaFullscreen(url, type) {
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.9);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
                cursor: pointer;
            `;

            let mediaElement;
            if (type === 'image') {
                mediaElement = document.createElement('img');
                mediaElement.src = url;
                mediaElement.style.cssText = 'max-width: 90%; max-height: 90%; object-fit: contain;';
            } else if (type === 'video') {
                mediaElement = document.createElement('video');
                mediaElement.src = url;
                mediaElement.controls = true;
                mediaElement.style.cssText = 'max-width: 90%; max-height: 90%;';
            }

            overlay.appendChild(mediaElement);
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    document.body.removeChild(overlay);
                    URL.revokeObjectURL(url);
                }
            });

            document.body.appendChild(overlay);
        }

        function handleTransferAction(transferId, senderId, action, buttonElement) {
            // é˜²æ­¢é‡å¤ç‚¹å‡»
            if (buttonElement.disabled) {
                return;
            }

            // ç¦ç”¨æ‰€æœ‰ç›¸å…³æŒ‰é’®
            const parentDiv = buttonElement.parentElement;
            const buttons = parentDiv.querySelectorAll('button');
            buttons.forEach(btn => {
                btn.disabled = true;
                btn.style.opacity = '0.5';
            });

            try {
                if (action === 'accept') {
                    fileTransferManager.acceptTransfer(transferId, senderId);
                } else if (action === 'reject') {
                    fileTransferManager.rejectTransfer(transferId, senderId);
                }
            } catch (error) {
                console.error('Error handling transfer action:', error);
                // é‡æ–°å¯ç”¨æŒ‰é’®
                buttons.forEach(btn => {
                    btn.disabled = false;
                    btn.style.opacity = '1';
                });
            }
        }

        function displayFileTransferRequest(senderId, transferId, metadata) {
            const messageEl = document.createElement('div');
            messageEl.className = 'message system';

            messageEl.innerHTML = `
                <div style="margin-bottom: 10px;">
                    <strong>${getUserName(senderId)}</strong> æƒ³è¦å‘é€æ–‡ä»¶:
                </div>
                <div class="file-message">
                    <div class="file-icon">ğŸ“„</div>
                    <div class="file-info">
                        <div class="file-name">${metadata.fileName}</div>
                        <div class="file-size">${formatFileSize(metadata.fileSize)}</div>
                        <div class="file-hash">MD5: ${metadata.fileHash.substring(0, 16)}...</div>
                    </div>
                    <div>
                        <button class="download-btn" onclick="handleTransferAction('${transferId}', '${senderId}', 'accept', this)">
                            æ¥å—
                        </button>
                        <button class="cancel-btn" onclick="handleTransferAction('${transferId}', '${senderId}', 'reject', this)">
                            æ‹’ç»
                        </button>
                    </div>
                </div>
            `;

            messagesEl.appendChild(messageEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }

        function displayFileMessage(senderId, file, type, fileHash) {
            const messageEl = document.createElement('div');
            messageEl.className = `message ${type} file`;

            const senderName = getUserName(senderId);

            messageEl.innerHTML = `
                <div class="sender-info">
                    <span class="sender-name">${senderName}</span>
                    <span class="message-time">${new Date().toLocaleTimeString()}</span>
                </div>
                <div class="file-message">
                    <div class="file-icon">ğŸ“„</div>
                    <div class="file-info">
                        <div class="file-name">${file.name}</div>
                        <div class="file-size">${formatFileSize(file.size)}</div>
                        ${fileHash ? `<div class="file-hash">MD5: ${fileHash.substring(0, 16)}...</div>` : ''}
                    </div>
                    ${type === 'received' ? '<div style="color: var(--success);">âœ“ å·²ä¸‹è½½</div>' : ''}
                </div>
            `;

            messagesEl.appendChild(messageEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }

        function displayMediaMessage(senderId, file, type, fileHash, mediaUrl) {
            const messageEl = document.createElement('div');
            messageEl.className = `message ${type}`;

            const senderName = getUserName(senderId);
            const isImage = file.type.startsWith('image/');
            const isVideo = file.type.startsWith('video/');

            let mediaContent = '';
            if (isImage) {
                mediaContent = `
                    <img src="${mediaUrl}" 
                         alt="${file.name}" 
                         class="media-preview" 
                         onclick="showMediaFullscreen('${mediaUrl}', 'image')"
                         style="cursor: pointer; border-radius: 8px; max-width: 300px; max-height: 200px; object-fit: cover;">
                `;
            } else if (isVideo) {
                mediaContent = `
                    <video src="${mediaUrl}" 
                           class="video-preview" 
                           controls 
                           style="border-radius: 8px; max-width: 300px; max-height: 200px;">
                        æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè§†é¢‘æ’­æ”¾ã€‚
                    </video>
                `;
            }

            messageEl.innerHTML = `
                <div class="sender-info">
                    <span class="sender-name">${senderName}</span>
                    <span class="message-time">${new Date().toLocaleTimeString()}</span>
                </div>
                <div style="margin-top: 8px;">
                    ${mediaContent}
                    <div style="margin-top: 5px; font-size: 0.8em; color: #ccc;">
                        <div>${file.name}</div>
                        <div>${formatFileSize(file.size)}</div>
                        ${fileHash ? `<div style="font-family: monospace; font-size: 0.7em;">MD5: ${fileHash.substring(0, 16)}...</div>` : ''}
                    </div>
                </div>
            `;

            messagesEl.appendChild(messageEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }

        function displayMediaMessage(senderId, file, type, fileHash, mediaUrl) {
            const messageEl = document.createElement('div');
            messageEl.className = `message ${type}`;

            const senderName = getUserName(senderId);
            const isImage = file.type.startsWith('image/');
            const isVideo = file.type.startsWith('video/');

            let mediaContent = '';
            if (isImage) {
                mediaContent = `
                    <img src="${mediaUrl}" 
                         alt="${file.name}" 
                         class="media-preview" 
                         onclick="showMediaFullscreen('${mediaUrl}', 'image')"
                         style="cursor: pointer; border-radius: 8px; max-width: 300px; max-height: 200px; object-fit: cover;">
                `;
            } else if (isVideo) {
                mediaContent = `
                    <video src="${mediaUrl}" 
                           class="video-preview" 
                           controls 
                           style="border-radius: 8px; max-width: 300px; max-height: 200px;">
                        æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè§†é¢‘æ’­æ”¾ã€‚
                    </video>
                `;
            }

            messageEl.innerHTML = `
                <div class="sender-info">
                    <span class="sender-name">${senderName}</span>
                    <span class="message-time">${new Date().toLocaleTimeString()}</span>
                </div>
                <div style="margin-top: 8px;">
                    ${mediaContent}
                    <div style="margin-top: 5px; font-size: 0.8em; color: #ccc;">
                        <div>${file.name}</div>
                        <div>${formatFileSize(file.size)}</div>
                        ${fileHash ? `<div style="font-family: monospace; font-size: 0.7em;">MD5: ${fileHash.substring(0, 16)}...</div>` : ''}
                    </div>
                </div>
            `;

            messagesEl.appendChild(messageEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }

        function displaySystemMessage(text) {
            const messageEl = document.createElement('div');
            messageEl.className = 'message system';
            messageEl.innerHTML = `
                <div>${text}</div>
                <div class="message-time">${new Date().toLocaleTimeString()}</div>
            `;

            messagesEl.appendChild(messageEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }

        function getUserName(userId) {
            const user = users.get(userId);
            return user ? user.name : userId;
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // å…¶ä»–å¿…è¦çš„å‡½æ•°ï¼ˆå¯†é’¥ç®¡ç†ã€æ¶ˆæ¯å‘é€ç­‰ï¼‰
        function loadKeysFromStorage() {
            privateKey = localStorage.getItem('privateKey') || '';
            publicKey = localStorage.getItem('publicKey') || '';

            if (publicKey) {
                extractUserProfile(publicKey).then(profile => {
                    userId = profile.id;
                    userName = profile.name;
                    keyIdEl.textContent = userId;

                    if (websocket && websocket.readyState === WebSocket.OPEN) {
                        registerUser();
                    }
                });
            }
        }

        function registerUser() {
            if (!publicKey) return;

            const registerMessage = {
                type: 'register',
                publicKey: publicKey
            };

            websocket.send(JSON.stringify(registerMessage));
        }

        async function generateKeys() {
            try {
                const name = prompt('è¯·è¾“å…¥æ‚¨çš„å§“å:') || 'Anonymous';

                const { privateKey: privKey, publicKey: pubKey } = await openpgp.generateKey({
                    type: 'ecc',
                    curve: 'curve25519',
                    userIDs: [{ name: name }],
                    passphrase: '',
                    format: 'armored'
                });

                privateKey = privKey;
                publicKey = pubKey;

                localStorage.setItem('privateKey', privateKey);
                localStorage.setItem('publicKey', publicKey);

                const profile = await extractUserProfile(publicKey);
                userId = profile.id;
                userName = profile.name;
                keyIdEl.textContent = userId;

                showNotification('å¯†é’¥ç”ŸæˆæˆåŠŸ');

                if (websocket && websocket.readyState === WebSocket.OPEN) {
                    registerUser();
                }
            } catch (error) {
                showNotification('å¯†é’¥ç”Ÿæˆå¤±è´¥: ' + error.message, 'error');
            }
        }

        async function extractUserProfile(publicKeyArmored) {
            try {
                const publicKeyObj = await openpgp.readKey({ armoredKey: publicKeyArmored });
                const primaryUser = await publicKeyObj.getPrimaryUser();
                const userID = primaryUser.user.userID;

                let name = '';
                let email = '';
                let id = '';

                if (userID) {
                    const userIdString = userID.userID || '';
                    const match = userIdString.match(/^(.+?)\s*<([^>]+)>$/);

                    if (match) {
                        name = match[1].trim();
                        email = match[2].trim();
                    } else {
                        if (userIdString.includes('@')) {
                            email = userIdString.trim();
                            name = email.split('@')[0];
                        } else {
                            name = userIdString.trim();
                        }
                    }
                }

                id = publicKeyObj.getFingerprint().toUpperCase();

                if (!name) {
                    name = `User_${Math.random().toString(36).substr(2, 8)}`;
                }
                if (!email) {
                    email = `${name.toLowerCase().replace(/\s+/g, '')}@example.com`;
                }

                return { id, name, email };

            } catch (error) {
                console.error('è§£æå…¬é’¥æ—¶å‡ºé”™:', error);
                return {
                    id: Math.random().toString(36).substr(2, 8),
                    name: 'Unknown User',
                    email: 'unknown@example.com'
                };
            }
        }

        function importPublicKey() {
            const key = prompt('è¯·ç²˜è´´å…¬é’¥:');
            if (key && key.includes('-----BEGIN PGP PUBLIC KEY BLOCK-----')) {
                publicKey = key;
                localStorage.setItem('publicKey', publicKey);

                extractUserProfile(publicKey).then(profile => {
                    userId = profile.id;
                    userName = profile.name;
                    keyIdEl.textContent = userId;

                    showNotification('å…¬é’¥å¯¼å…¥æˆåŠŸ');

                    if (websocket && websocket.readyState === WebSocket.OPEN) {
                        registerUser();
                    }
                });
            } else {
                showNotification('æ— æ•ˆçš„å…¬é’¥æ ¼å¼', 'error');
            }
        }

        function importPrivateKey() {
            const key = prompt('è¯·ç²˜è´´ç§é’¥:');
            if (key && key.includes('-----BEGIN PGP PRIVATE KEY BLOCK-----')) {
                privateKey = key;
                localStorage.setItem('privateKey', privateKey);
                showNotification('ç§é’¥å¯¼å…¥æˆåŠŸ');
            } else {
                showNotification('æ— æ•ˆçš„ç§é’¥æ ¼å¼', 'error');
            }
        }

        function copyPublicKey() {
            if (publicKey) {
                navigator.clipboard.writeText(publicKey).then(() => {
                    showNotification('å…¬é’¥å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
                });
            } else {
                showNotification('æ²¡æœ‰å¯å¤åˆ¶çš„å…¬é’¥', 'warning');
            }
        }

        async function sendMessage() {
            const text = messageInputEl.value.trim();
            if (!text || !publicKey) return;

            try {
                const encryptedData = await encryptForAllUsers(text);

                const message = {
                    type: 'message',
                    encryptedData: encryptedData
                };

                websocket.send(JSON.stringify(message));
                messageInputEl.value = '';

            } catch (error) {
                showNotification('æ¶ˆæ¯å‘é€å¤±è´¥: ' + error.message, 'error');
            }
        }

        async function encryptForAllUsers(data) {
            const publicKeys = Array.from(users.values()).map(user => user.publicKey);

            if (publicKeys.length === 0) {
                throw new Error('æ²¡æœ‰å¯ç”¨çš„å…¬é’¥');
            }

            const keys = await Promise.all(
                publicKeys.map(key => openpgp.readKey({ armoredKey: key }))
            );

            let message;
            if (typeof data === 'string') {
                message = await openpgp.createMessage({ text: data });
            } else {
                // å¤„ç†äºŒè¿›åˆ¶æ•°æ®ï¼ˆå¦‚è¯­éŸ³ï¼‰
                message = await openpgp.createMessage({ binary: data });
            }

            const encrypted = await openpgp.encrypt({
                message: message,
                encryptionKeys: keys,
                format: 'armored'
            });

            return encrypted;
        }

        async function decryptMessage(encryptedData) {
            if (!privateKey) {
                throw new Error('ç§é’¥æœªè®¾ç½®');
            }

            try {
                const encryptedMessage = await openpgp.readMessage({
                    armoredMessage: encryptedData
                });

                const privKey = await openpgp.readPrivateKey({
                    armoredKey: privateKey
                });

                const { data: decrypted } = await openpgp.decrypt({
                    message: encryptedMessage,
                    decryptionKeys: privKey,
                    format: 'binary'
                });

                return decrypted;

            } catch (error) {
                console.error('è§£å¯†å¤±è´¥:', error);
                throw error;
            }
        }

        async function handleEncryptedMessage(message) {
            if (!privateKey) {
                displayEncryptedMessage(message);
                return;
            }

            try {
                const encryptedMessage = await openpgp.readMessage({
                    armoredMessage: message.encryptedData
                });

                const privKey = await openpgp.readPrivateKey({
                    armoredKey: privateKey
                });

                const { data: decrypted } = await openpgp.decrypt({
                    message: encryptedMessage,
                    decryptionKeys: privKey
                });

                displayMessage(message.senderId, decrypted, message.timestamp);

            } catch (error) {
                console.error('è§£å¯†å¤±è´¥:', error);
                displayEncryptedMessage(message);
            }
        }

        function displayMessage(senderId, text, timestamp) {
            const messageEl = document.createElement('div');
            messageEl.className = `message ${senderId === userId ? 'sent' : 'received'}`;

            const senderName = getUserName(senderId);
            const time = new Date(timestamp).toLocaleTimeString();

            messageEl.innerHTML = `
                <div class="sender-info">
                    <span class="sender-name">${senderName}</span>
                    <span class="message-time">${time}</span>
                </div>
                <div class="message-text">${text}</div>
            `;

            messagesEl.appendChild(messageEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }

        function displayEncryptedMessage(message) {
            const messageEl = document.createElement('div');
            messageEl.className = 'message received encrypted';

            const senderName = getUserName(message.senderId);
            const time = new Date(message.timestamp).toLocaleTimeString();

            messageEl.innerHTML = `
                <div class="sender-info">
                    <span class="sender-name">${senderName}</span>
                    <span class="message-time">${time}</span>
                </div>
                <div class="message-text">ğŸ”’ åŠ å¯†æ¶ˆæ¯ (éœ€è¦ç§é’¥è§£å¯†)</div>
            `;

            messagesEl.appendChild(messageEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }

        function showNotification(message, type = 'success') {
            notificationEl.textContent = message;
            notificationEl.className = `notification ${type}`;
            notificationEl.classList.add('show');

            setTimeout(() => {
                notificationEl.classList.remove('show');
            }, 3000);
        }

        // æ˜¾ç¤ºæˆ¿é—´é“¾æ¥
        function displayRoomUrl() {
            // æ„å»ºåŒ…å«æˆ¿é—´IDçš„å®Œæ•´URL
            const baseUrl = window.location.origin + window.location.pathname;
            const roomUrl = `${baseUrl}?room=${roomId}`;

            roomUrlEl.textContent = roomUrl;
            roomUrlEl.title = 'ç‚¹å‡»å¤åˆ¶æˆ¿é—´é“¾æ¥';
            roomUrlEl.addEventListener('click', () => {
                navigator.clipboard.writeText(roomUrl).then(() => {
                    showNotification('æˆ¿é—´é“¾æ¥å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
                }).catch(err => {
                    showNotification('å¤åˆ¶å¤±è´¥: ' + err.message, 'error');
                });
            });
        }

        // åˆå§‹åŒ–è¯­éŸ³åŠŸèƒ½
        async function initVoiceSupport() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });

                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'audio/webm;codecs=opus'
                });

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    await sendVoiceMessage(audioBlob);
                    audioChunks = [];
                };

                voiceBtnEl.disabled = false;
                console.log('è¯­éŸ³åŠŸèƒ½åˆå§‹åŒ–å®Œæˆ');

            } catch (error) {
                console.log(`è¯­éŸ³åŠŸèƒ½åˆå§‹åŒ–å¤±è´¥: ${error.message}`);
                voiceBtnEl.disabled = true;
                voiceStatusEl.textContent = 'éº¦å…‹é£æƒé™è¢«æ‹’ç»';
            }
        }

        // å¼€å§‹/åœæ­¢å½•éŸ³
        function toggleVoiceRecording() {
            if (!mediaRecorder) {
                showNotification('è¯­éŸ³åŠŸèƒ½æœªåˆå§‹åŒ–', 'error');
                return;
            }

            if (!publicKey) {
                showNotification('è¯·å…ˆå¯¼å…¥æˆ–ç”Ÿæˆå¯†é’¥', 'warning');
                return;
            }

            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        }

        function startRecording() {
            if (mediaRecorder && mediaRecorder.state === 'inactive') {
                audioChunks = [];
                mediaRecorder.start();
                isRecording = true;
                recordingStartTime = Date.now();

                voiceBtnEl.classList.add('recording');
                voiceBtnEl.textContent = 'ğŸ”´ åœæ­¢';
                voiceStatusEl.textContent = 'æ­£åœ¨å½•éŸ³...';

                showNotification('å¼€å§‹å½•éŸ³ï¼Œå†æ¬¡ç‚¹å‡»åœæ­¢');
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                isRecording = false;

                voiceBtnEl.classList.remove('recording');
                voiceBtnEl.textContent = 'ğŸ¤ è¯­éŸ³';
                voiceStatusEl.textContent = 'å¤„ç†ä¸­...';
            }
        }

        async function sendVoiceMessage(audioBlob) {
            try {
                const duration = Math.round((Date.now() - recordingStartTime) / 1000);
                const voiceId = generateId();

                // è¯»å–éŸ³é¢‘æ•°æ®
                const arrayBuffer = await audioBlob.arrayBuffer();
                const audioData = new Uint8Array(arrayBuffer);

                // åŠ å¯†è¯­éŸ³æ•°æ®
                const encryptedVoiceData = await encryptForAllUsers(audioData);

                const voiceMetadata = {
                    voiceId: voiceId,
                    duration: duration,
                    sampleRate: 48000,
                    format: 'webm'
                };

                const voiceMessage = {
                    type: 'voice',
                    metadata: voiceMetadata,
                    encryptedVoiceData: encryptedVoiceData
                };

                if (websocket && websocket.readyState === WebSocket.OPEN) {
                    websocket.send(JSON.stringify(voiceMessage));
                }

                voiceStatusEl.textContent = '';
                showNotification(`è¯­éŸ³æ¶ˆæ¯å‘é€æˆåŠŸ (${duration}ç§’)`);

            } catch (error) {
                console.error('è¯­éŸ³æ¶ˆæ¯å‘é€å¤±è´¥:', error);
                voiceStatusEl.textContent = '';
                showNotification('è¯­éŸ³æ¶ˆæ¯å‘é€å¤±è´¥: ' + error.message, 'error');
            }
        }

        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        }

        async function handleVoiceMessage(message) {
            if (!privateKey) {
                displayEncryptedVoiceMessage(message);
                return;
            }

            try {
                // è§£å¯†è¯­éŸ³æ•°æ®
                const encryptedMessage = await openpgp.readMessage({
                    armoredMessage: message.encryptedVoiceData
                });

                const privKey = await openpgp.readPrivateKey({
                    armoredKey: privateKey
                });

                const { data: decrypted } = await openpgp.decrypt({
                    message: encryptedMessage,
                    decryptionKeys: privKey,
                    format: 'binary'
                });

                // åˆ›å»ºéŸ³é¢‘ Blob
                const audioBlob = new Blob([decrypted], { type: 'audio/webm' });
                const audioUrl = URL.createObjectURL(audioBlob);

                displayVoiceMessage(message.senderId, message.metadata, audioUrl, message.timestamp);

            } catch (error) {
                console.error('è¯­éŸ³æ¶ˆæ¯è§£å¯†å¤±è´¥:', error);
                displayEncryptedVoiceMessage(message);
            }
        }

        function displayVoiceMessage(senderId, metadata, audioUrl, timestamp) {
            const messageEl = document.createElement('div');
            messageEl.className = `message ${senderId === userId ? 'sent' : 'received'} voice`;

            const senderName = getUserName(senderId);
            const time = new Date(timestamp).toLocaleTimeString();

            messageEl.innerHTML = `
                <div class="sender-info">
                    <span class="sender-name">${senderName}</span>
                    <span class="message-time">${time}</span>
                </div>
                <div class="voice-message">
                    <div class="voice-icon">ğŸµ</div>
                    <div class="voice-waveform">
                        è¯­éŸ³æ¶ˆæ¯ ${metadata.duration}ç§’
                    </div>
                    <button class="play-btn" onclick="playVoiceMessage('${audioUrl}')">
                        â–¶ï¸
                    </button>
                </div>
            `;

            messagesEl.appendChild(messageEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }

        function displayEncryptedVoiceMessage(message) {
            const messageEl = document.createElement('div');
            messageEl.className = 'message received voice';

            const senderName = getUserName(message.senderId);
            const time = new Date(message.timestamp).toLocaleTimeString();

            messageEl.innerHTML = `
                <div class="sender-info">
                    <span class="sender-name">${senderName}</span>
                    <span class="message-time">${time}</span>
                </div>
                <div class="voice-message">
                    <div class="voice-icon">ğŸ”’</div>
                    <div class="voice-waveform">
                        åŠ å¯†è¯­éŸ³æ¶ˆæ¯ (éœ€è¦ç§é’¥è§£å¯†)
                    </div>
                </div>
            `;

            messagesEl.appendChild(messageEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }

        function playVoiceMessage(audioUrl) {
            const audio = new Audio(audioUrl);
            audio.play().catch(error => {
                console.error('æ’­æ”¾è¯­éŸ³å¤±è´¥:', error);
                showNotification('æ’­æ”¾è¯­éŸ³å¤±è´¥', 'error');
            });
        }

        // å®æ—¶è¯­éŸ³åŠŸèƒ½
        async function toggleLiveVoice() {
            if (isLiveVoiceActive) {
                stopLiveVoice();
            } else {
                await startLiveVoice();
            }
        }

        async function startLiveVoice() {
            try {
                // ä¼˜åŒ–çš„éŸ³é¢‘çº¦æŸ
                liveAudioStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: 48000, // æé«˜é‡‡æ ·ç‡ä»¥è·å¾—æ›´å¥½çš„éŸ³è´¨
                        channelCount: 1,   // å•å£°é“å‡å°‘æ•°æ®é‡
                        latency: 0.01      // ä½å»¶è¿Ÿè®¾ç½®
                    }
                });

                // åˆ›å»ºéŸ³é¢‘ä¸Šä¸‹æ–‡
                liveAudioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 48000,
                    latencyHint: 'interactive'
                });

                const source = liveAudioContext.createMediaStreamSource(liveAudioStream);

                // åˆ›å»ºéŸ³é‡åˆ†æå™¨
                volumeAnalyser = liveAudioContext.createAnalyser();
                volumeAnalyser.fftSize = 512;
                volumeAnalyser.smoothingTimeConstant = 0.3;
                source.connect(volumeAnalyser);

                // åˆ›å»ºä¼˜åŒ–çš„åª’ä½“å½•åˆ¶å™¨
                const supportedMimeTypes = [
                    'audio/webm;codecs=opus',
                    'audio/webm',
                    'audio/ogg;codecs=opus',
                    'audio/mp4'
                ];

                let selectedMimeType = null;
                for (const mimeType of supportedMimeTypes) {
                    if (MediaRecorder.isTypeSupported(mimeType)) {
                        selectedMimeType = mimeType;
                        console.log(`ä½¿ç”¨éŸ³é¢‘æ ¼å¼: ${mimeType}`);
                        break;
                    }
                }

                if (!selectedMimeType) {
                    throw new Error('æµè§ˆå™¨ä¸æ”¯æŒä»»ä½•éŸ³é¢‘å½•åˆ¶æ ¼å¼');
                }

                // ä¼˜åŒ–çš„å½•åˆ¶å™¨é…ç½®
                const recorderOptions = {
                    mimeType: selectedMimeType,
                    audioBitsPerSecond: 96000 // æé«˜ç ç‡ä»¥è·å¾—æ›´å¥½çš„éŸ³è´¨
                };

                try {
                    liveMediaRecorder = new MediaRecorder(liveAudioStream, recorderOptions);
                } catch (error) {
                    console.log('ä½¿ç”¨é»˜è®¤å½•åˆ¶è®¾ç½®:', error.message);
                    liveMediaRecorder = new MediaRecorder(liveAudioStream, {
                        mimeType: selectedMimeType
                    });
                }

                // ä¼˜åŒ–çš„æ•°æ®å¤„ç†
                liveMediaRecorder.ondataavailable = async (event) => {
                    if (event.data.size > 0) {
                        // æ·»åŠ åˆ°ç¼“å†²åŒºè€Œä¸æ˜¯ç«‹å³å‘é€
                        audioBuffer.push(event.data);
                        console.log(`éŸ³é¢‘å—ç¼“å†²: ${event.data.size} å­—èŠ‚, ç¼“å†²åŒºå¤§å°: ${audioBuffer.length}`);

                        // æ£€æŸ¥æ˜¯å¦éœ€è¦å‘é€ç¼“å†²çš„éŸ³é¢‘
                        await processAudioBuffer();
                    }
                };

                liveMediaRecorder.onerror = (event) => {
                    console.error('å½•åˆ¶å™¨é”™è¯¯:', event.error);
                    showNotification('å½•åˆ¶é”™è¯¯: ' + event.error.message, 'error');
                };

                // ä½¿ç”¨æ›´é•¿çš„å½•åˆ¶é—´éš”ä»¥å‡å°‘ç½‘ç»œè¯·æ±‚é¢‘ç‡
                liveMediaRecorder.start(sendInterval);

                isLiveVoiceActive = true;
                liveVoiceBtnEl.textContent = 'ğŸ“ åœæ­¢å®æ—¶è¯­éŸ³';
                liveVoiceBtnEl.style.background = 'var(--danger)';

                // æ˜¾ç¤ºå®æ—¶è¯­éŸ³æ§åˆ¶ç•Œé¢
                showLiveVoiceControls();

                // å¼€å§‹ä¼˜åŒ–çš„éŸ³é‡ç›‘æµ‹
                startOptimizedVolumeMonitoring();

                // å¯åŠ¨å®šæœŸå‘é€æœºåˆ¶
                startPeriodicSend();

                showNotification('å®æ—¶è¯­éŸ³å·²å¼€å¯ (ä¼˜åŒ–æ¨¡å¼)');

            } catch (error) {
                console.error('å¯åŠ¨å®æ—¶è¯­éŸ³å¤±è´¥:', error);
                showNotification('å¯åŠ¨å®æ—¶è¯­éŸ³å¤±è´¥: ' + error.message, 'error');
            }
        }

        function stopLiveVoice() {
            // å‘é€å‰©ä½™çš„ç¼“å†²éŸ³é¢‘
            if (audioBuffer.length > 0) {
                const finalBlob = new Blob(audioBuffer, { type: audioBuffer[0].type });
                sendLiveAudioChunk(finalBlob).catch(console.error);
                audioBuffer = [];
            }

            if (liveAudioStream) {
                liveAudioStream.getTracks().forEach(track => track.stop());
                liveAudioStream = null;
            }

            if (liveAudioContext) {
                liveAudioContext.close();
                liveAudioContext = null;
            }

            if (liveMediaRecorder && liveMediaRecorder.state !== 'inactive') {
                liveMediaRecorder.stop();
                liveMediaRecorder = null;
            }

            if (liveVoiceInterval) {
                clearInterval(liveVoiceInterval);
                liveVoiceInterval = null;
            }

            // æ¸…ç†ä¼˜åŒ–ç›¸å…³çš„å˜é‡
            volumeAnalyser = null;
            audioBuffer = [];
            lastSendTime = 0;

            isLiveVoiceActive = false;
            liveVoiceBtnEl.textContent = 'ğŸ“ å®æ—¶è¯­éŸ³';
            liveVoiceBtnEl.style.background = '';

            // æ¸…ç†æ‰€æœ‰éŸ³é¢‘æµ
            cleanupAllAudioStreams();

            // æ¸…ç†æ™ºèƒ½æ’­æ”¾æ•°æ®
            clearSmartPlaybackData();

            // æ¸…ç†éŸ³é¢‘æŒ‡ç¤ºå™¨
            if (audioIndicatorElement && audioIndicatorElement.parentNode) {
                audioIndicatorElement.parentNode.removeChild(audioIndicatorElement);
                audioIndicatorElement = null;
            }
            if (audioIndicatorTimeout) {
                clearTimeout(audioIndicatorTimeout);
                audioIndicatorTimeout = null;
            }
            liveVoiceBtnEl.style.background = '';

            // éšè—å®æ—¶è¯­éŸ³æ§åˆ¶ç•Œé¢
            hideLiveVoiceControls();

            showNotification('å®æ—¶è¯­éŸ³å·²å…³é—­');
        }

        // ä¼˜åŒ–çš„éŸ³é¢‘ç¼“å†²å¤„ç†
        async function processAudioBuffer() {
            const currentTime = Date.now();

            // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„éŸ³é¢‘æ•°æ®æˆ–è€…è·ç¦»ä¸Šæ¬¡å‘é€æ—¶é—´è¶³å¤Ÿé•¿
            if (audioBuffer.length >= minBufferSize || (currentTime - lastSendTime) > sendInterval * 2) {
                // æ£€æµ‹éŸ³é‡ä»¥å†³å®šæ˜¯å¦å‘é€
                const hasAudio = await detectAudioActivity();

                if (hasAudio && audioBuffer.length > 0) {
                    // åˆå¹¶ç¼“å†²åŒºä¸­çš„éŸ³é¢‘æ•°æ®
                    const combinedBlob = new Blob(audioBuffer, { type: audioBuffer[0].type });
                    console.log(`å‘é€åˆå¹¶éŸ³é¢‘: ${combinedBlob.size} å­—èŠ‚, åŒ…å« ${audioBuffer.length} ä¸ªå—`);

                    // å‘é€åˆå¹¶çš„éŸ³é¢‘æ•°æ®
                    await sendLiveAudioChunk(combinedBlob);

                    // æ¸…ç©ºç¼“å†²åŒº
                    audioBuffer = [];
                    lastSendTime = currentTime;
                } else if (!hasAudio) {
                    // å¦‚æœæ£€æµ‹åˆ°é™éŸ³ï¼Œæ¸…ç©ºç¼“å†²åŒºä½†ä¸å‘é€
                    console.log('æ£€æµ‹åˆ°é™éŸ³ï¼Œè·³è¿‡å‘é€');
                    audioBuffer = [];
                    lastSendTime = currentTime;
                }
            }
        }

        // éŸ³é¢‘æ´»åŠ¨æ£€æµ‹
        async function detectAudioActivity() {
            if (!volumeAnalyser) return true; // å¦‚æœæ²¡æœ‰åˆ†æå™¨ï¼Œé»˜è®¤å‘é€

            const bufferLength = volumeAnalyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            volumeAnalyser.getByteFrequencyData(dataArray);

            // è®¡ç®—å¹³å‡éŸ³é‡
            let sum = 0;
            for (let i = 0; i < bufferLength; i++) {
                sum += dataArray[i];
            }
            const average = sum / bufferLength / 255; // å½’ä¸€åŒ–åˆ° 0-1

            // æ£€æŸ¥æ˜¯å¦è¶…è¿‡é™éŸ³é˜ˆå€¼
            const hasActivity = average > silenceThreshold;

            if (hasActivity) {
                console.log(`éŸ³é¢‘æ´»åŠ¨æ£€æµ‹: ${(average * 100).toFixed(1)}% (é˜ˆå€¼: ${(silenceThreshold * 100).toFixed(1)}%)`);
            }

            return hasActivity;
        }

        // ä¼˜åŒ–çš„éŸ³é‡ç›‘æµ‹
        function startOptimizedVolumeMonitoring() {
            if (!volumeAnalyser) return;

            const bufferLength = volumeAnalyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            function updateVolume() {
                if (!isLiveVoiceActive) return;

                volumeAnalyser.getByteFrequencyData(dataArray);

                let sum = 0;
                for (let i = 0; i < bufferLength; i++) {
                    sum += dataArray[i];
                }
                const average = sum / bufferLength;
                const volume = Math.min(100, (average / 255) * 100);

                // æ›´æ–°UIæ˜¾ç¤º
                updateVolumeDisplay(volume);

                requestAnimationFrame(updateVolume);
            }

            updateVolume();
        }

        // å®šæœŸå‘é€æœºåˆ¶
        function startPeriodicSend() {
            liveVoiceInterval = setInterval(async () => {
                if (isLiveVoiceActive && audioBuffer.length > 0) {
                    await processAudioBuffer();
                }
            }, sendInterval);
        }

        // æ›´æ–°éŸ³é‡æ˜¾ç¤º
        function updateVolumeDisplay(volume) {
            const volumeBar = document.getElementById('volumeBar');
            const volumeText = document.getElementById('volumeText');
            const audioStatus = document.getElementById('audioStatus');
            const bufferStatus = document.getElementById('bufferStatus');

            if (volumeBar) {
                volumeBar.style.width = `${volume}%`;
                volumeBar.style.backgroundColor = volume > silenceThreshold * 100 ? '#4CAF50' : '#ccc';
            }

            if (volumeText) {
                volumeText.textContent = `${volume.toFixed(1)}%`;
            }

            if (audioStatus) {
                const isActive = volume > silenceThreshold * 100;
                audioStatus.textContent = `çŠ¶æ€: ${isActive ? 'æ´»è·ƒ' : 'é™éŸ³'}`;
                audioStatus.style.color = isActive ? '#4CAF50' : '#999';
            }

            if (bufferStatus) {
                bufferStatus.textContent = `ç¼“å†²: ${audioBuffer.length}`;
            }
        }

        async function sendLiveAudioChunk(audioBlob) {
            try {
                // éªŒè¯éŸ³é¢‘æ•°æ®
                if (!audioBlob || audioBlob.size === 0) {
                    console.log('è·³è¿‡ç©ºéŸ³é¢‘å—');
                    return;
                }

                console.log(`å‘é€éŸ³é¢‘å—: ${audioBlob.size} å­—èŠ‚, ç±»å‹: ${audioBlob.type}`);

                const arrayBuffer = await audioBlob.arrayBuffer();
                const audioData = new Uint8Array(arrayBuffer);

                // éªŒè¯éŸ³é¢‘æ•°æ®å¤´
                const header = Array.from(audioData.slice(0, 4)).map(b => b.toString(16).padStart(2, '0')).join('');
                console.log(`å‘é€éŸ³é¢‘æ•°æ®å¤´: ${header}, å¤§å°: ${audioData.length} å­—èŠ‚`);

                // åŠ å¯†éŸ³é¢‘æ•°æ®
                const encryptedAudioData = await encryptForAllUsers(audioData);

                const liveAudioMessage = {
                    type: 'liveAudio',
                    encryptedAudioData: encryptedAudioData,
                    timestamp: Date.now(),
                    audioFormat: audioBlob.type || 'audio/webm;codecs=opus',
                    audioSize: audioData.length
                };

                if (websocket && websocket.readyState === WebSocket.OPEN) {
                    websocket.send(JSON.stringify(liveAudioMessage));
                }

            } catch (error) {
                console.error('å‘é€å®æ—¶éŸ³é¢‘å¤±è´¥:', error);
            }
        }

        function showLiveVoiceControls() {
            let controlsEl = document.getElementById('liveVoiceControls');
            if (!controlsEl) {
                controlsEl = document.createElement('div');
                controlsEl.id = 'liveVoiceControls';
                controlsEl.className = 'live-voice-controls';
                controlsEl.innerHTML = `
                    <div class="voice-control-panel">
                        <div class="voice-status">
                            <div class="live-voice-indicator" id="liveVoiceIndicator"></div>
                            <span>å®æ—¶è¯­éŸ³é€šè¯ä¸­ (ä¼˜åŒ–æ¨¡å¼)</span>
                        </div>
                        <div class="volume-section">
                            <label>éŸ³é‡ç›‘æµ‹:</label>
                            <div class="volume-meter">
                                <div id="volumeBar" class="volume-bar"></div>
                            </div>
                            <span id="volumeText">0%</span>
                        </div>
                        <div class="settings-section">
                            <label>é™éŸ³é˜ˆå€¼:</label>
                            <input type="range" id="silenceSlider" min="0" max="0.1" step="0.005" value="${silenceThreshold}">
                            <span id="silenceText">${(silenceThreshold * 100).toFixed(1)}%</span>
                        </div>
                        <div class="settings-section">
                            <label>å‘é€é—´éš”:</label>
                            <select id="intervalSelect">
                                <option value="300" ${sendInterval === 300 ? 'selected' : ''}>300ms (é«˜è´¨é‡)</option>
                                <option value="500" ${sendInterval === 500 ? 'selected' : ''}>500ms (å¹³è¡¡)</option>
                                <option value="1000" ${sendInterval === 1000 ? 'selected' : ''}>1000ms (çœæµé‡)</option>
                            </select>
                        </div>
                        <div class="status-section">
                            <span id="audioStatus">çŠ¶æ€: æ­£å¸¸</span>
                            <span id="bufferStatus">ç¼“å†²: 0</span>
                        </div>
                    </div>
                `;

                // æ’å…¥åˆ°è¾“å…¥åŒºåŸŸä¸Šæ–¹
                const inputArea = document.querySelector('.input-area');
                inputArea.parentNode.insertBefore(controlsEl, inputArea);
            }

            // ç»‘å®šæ§åˆ¶äº‹ä»¶
            bindVoiceControlEvents();
            controlsEl.style.display = 'block';
        }

        function bindVoiceControlEvents() {
            const silenceSlider = document.getElementById('silenceSlider');
            const silenceText = document.getElementById('silenceText');
            const intervalSelect = document.getElementById('intervalSelect');

            if (silenceSlider) {
                silenceSlider.addEventListener('input', (e) => {
                    silenceThreshold = parseFloat(e.target.value);
                    silenceText.textContent = `${(silenceThreshold * 100).toFixed(1)}%`;
                    console.log('é™éŸ³é˜ˆå€¼æ›´æ–°:', silenceThreshold);
                });
            }

            if (intervalSelect) {
                intervalSelect.addEventListener('change', (e) => {
                    const newInterval = parseInt(e.target.value);
                    if (newInterval !== sendInterval) {
                        sendInterval = newInterval;
                        console.log('å‘é€é—´éš”æ›´æ–°:', sendInterval + 'ms');

                        // é‡å¯å½•åˆ¶å™¨ä»¥åº”ç”¨æ–°çš„é—´éš”
                        if (liveMediaRecorder && liveMediaRecorder.state === 'recording') {
                            liveMediaRecorder.stop();
                            setTimeout(() => {
                                if (isLiveVoiceActive) {
                                    liveMediaRecorder.start(sendInterval);
                                }
                            }, 100);
                        }

                        // é‡å¯å®šæœŸå‘é€
                        if (liveVoiceInterval) {
                            clearInterval(liveVoiceInterval);
                            startPeriodicSend();
                        }
                    }
                });
            }
        }

        function hideLiveVoiceControls() {
            const controlsEl = document.getElementById('liveVoiceControls');
            if (controlsEl) {
                controlsEl.remove();
            }
        }

        function startVolumeMonitoring(analyser) {
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            liveVoiceInterval = setInterval(() => {
                analyser.getByteFrequencyData(dataArray);

                // è®¡ç®—å¹³å‡éŸ³é‡
                let sum = 0;
                for (let i = 0; i < bufferLength; i++) {
                    sum += dataArray[i];
                }
                const average = sum / bufferLength;
                const volume = (average / 255) * 100;

                // æ›´æ–°éŸ³é‡æ¡
                const volumeBar = document.getElementById('volumeBar');
                const indicator = document.getElementById('liveVoiceIndicator');

                if (volumeBar) {
                    volumeBar.style.width = volume + '%';
                }

                if (indicator) {
                    if (volume > 10) {
                        indicator.classList.add('speaking');
                    } else {
                        indicator.classList.remove('speaking');
                    }
                }

            }, 100);
        }

        // åˆå§‹åŒ–éŸ³é¢‘æ’­æ”¾ä¸Šä¸‹æ–‡
        async function initPlaybackAudioContext() {
            if (!playbackAudioContext) {
                playbackAudioContext = new (window.AudioContext || window.webkitAudioContext)();

                // å¦‚æœä¸Šä¸‹æ–‡è¢«æš‚åœï¼Œå°è¯•æ¢å¤
                if (playbackAudioContext.state === 'suspended') {
                    await playbackAudioContext.resume();
                }
            }
            return playbackAudioContext;
        }

        // åœ¨ç”¨æˆ·äº¤äº’æ—¶åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡
        function initAudioContextOnUserInteraction() {
            const initOnClick = async () => {
                try {
                    await initPlaybackAudioContext();
                    console.log('éŸ³é¢‘ä¸Šä¸‹æ–‡å·²åˆå§‹åŒ–');

                    // ç§»é™¤äº‹ä»¶ç›‘å¬å™¨ï¼Œåªéœ€è¦åˆå§‹åŒ–ä¸€æ¬¡
                    document.removeEventListener('click', initOnClick);
                    document.removeEventListener('keydown', initOnClick);
                    document.removeEventListener('touchstart', initOnClick);
                } catch (error) {
                    console.error('éŸ³é¢‘ä¸Šä¸‹æ–‡åˆå§‹åŒ–å¤±è´¥:', error);
                }
            };

            // ç›‘å¬ç”¨æˆ·äº¤äº’äº‹ä»¶
            document.addEventListener('click', initOnClick);
            document.addEventListener('keydown', initOnClick);
            document.addEventListener('touchstart', initOnClick);
        }

        // å¤„ç†æ¥æ”¶åˆ°çš„å®æ—¶éŸ³é¢‘ - æ™ºèƒ½ç‰ˆæœ¬
        async function handleLiveAudio(message) {
            if (!privateKey) {
                return;
            }

            try {
                // è§£å¯†éŸ³é¢‘æ•°æ®
                const decryptedData = await decryptMessage(message.encryptedAudioData);
                const audioData = new Uint8Array(decryptedData);

                console.log(`æ¥æ”¶åˆ°éŸ³é¢‘æ•°æ®: ${audioData.length} å­—èŠ‚ from ${message.senderId.slice(-8)}`);

                // ä½¿ç”¨æ™ºèƒ½éŸ³é¢‘æ’­æ”¾
                await smartAudioPlayback(message.senderId, audioData);

                // æ˜¾ç¤ºéŸ³é¢‘æ¥æ”¶æŒ‡ç¤ºå™¨
                showAudioReceiveIndicator();

            } catch (error) {
                console.error('å¤„ç†å®æ—¶éŸ³é¢‘å¤±è´¥:', error);
                showAudioReceiveIndicator(); // å³ä½¿å¤±è´¥ä¹Ÿæ˜¾ç¤ºæ¥æ”¶æŒ‡ç¤ºå™¨
            }
        }

        // æ™ºèƒ½éŸ³é¢‘æ’­æ”¾æ ¸å¿ƒé€»è¾‘
        async function smartAudioPlayback(senderId, audioData) {
            try {
                // åˆå§‹åŒ–ç”¨æˆ·æ•°æ®
                if (!audioStreamBuffer.has(senderId)) {
                    audioStreamBuffer.set(senderId, {
                        chunks: [],
                        totalSize: 0,
                        lastUpdate: Date.now(),
                        isProcessing: false
                    });
                    playbackStats.set(senderId, { success: 0, total: 0 });
                }

                const buffer = audioStreamBuffer.get(senderId);
                const stats = playbackStats.get(senderId);

                buffer.chunks.push(audioData);
                buffer.totalSize += audioData.length;
                buffer.lastUpdate = Date.now();
                stats.total++;

                console.log(`æ™ºèƒ½ç¼“å†² [${senderId.slice(-8)}]: ${audioData.length} å­—èŠ‚ï¼Œæ€»è®¡: ${buffer.totalSize} å­—èŠ‚`);

                // å¦‚æœä¸åœ¨å¤„ç†ä¸­ï¼Œå¼€å§‹æ™ºèƒ½æ’­æ”¾
                if (!buffer.isProcessing) {
                    buffer.isProcessing = true;
                    await processSmartAudioBuffer(senderId);
                }

            } catch (error) {
                console.error('æ™ºèƒ½éŸ³é¢‘æ’­æ”¾å¤±è´¥:', error);
                showAudioReceiveIndicator();
            }
        }

        // å¤„ç†æ™ºèƒ½éŸ³é¢‘ç¼“å†²åŒº
        async function processSmartAudioBuffer(senderId) {
            const buffer = audioStreamBuffer.get(senderId);
            const stats = playbackStats.get(senderId);

            if (!buffer || buffer.chunks.length === 0) {
                if (buffer) buffer.isProcessing = false;
                return;
            }

            try {
                let playSuccess = false;

                // ç­–ç•¥1: å¦‚æœæœ‰å¤´ä¿¡æ¯å—ï¼Œä¸å¤´ä¿¡æ¯å—åˆå¹¶æ’­æ”¾
                if (headerChunks.has(senderId) && buffer.chunks.length > 0) {
                    const headerChunk = headerChunks.get(senderId);
                    const currentChunk = buffer.chunks.shift();
                    buffer.totalSize -= currentChunk.length;

                    const mergedAudio = new Uint8Array(headerChunk.length + currentChunk.length);
                    mergedAudio.set(headerChunk, 0);
                    mergedAudio.set(currentChunk, headerChunk.length);

                    if (await trySmartPlayAudio(mergedAudio)) {
                        console.log(`æ™ºèƒ½æ’­æ”¾æˆåŠŸ [${senderId.slice(-8)}]: å¤´ä¿¡æ¯åˆå¹¶ (${mergedAudio.length} å­—èŠ‚)`);
                        stats.success++;
                        playSuccess = true;
                    }
                }

                // ç­–ç•¥2: æµ‹è¯•ç¬¬ä¸€ä¸ªå—æ˜¯å¦åŒ…å«å¤´ä¿¡æ¯
                if (!playSuccess && !headerChunks.has(senderId) && buffer.chunks.length > 0) {
                    const firstChunk = buffer.chunks[0];

                    if (await trySmartPlayAudio(firstChunk)) {
                        console.log(`å‘ç°å¤´ä¿¡æ¯å— [${senderId.slice(-8)}]: ${firstChunk.length} å­—èŠ‚`);
                        headerChunks.set(senderId, firstChunk);
                        buffer.chunks.shift();
                        buffer.totalSize -= firstChunk.length;
                        stats.success++;
                        playSuccess = true;

                        // æ˜¾ç¤ºæˆåŠŸç‡
                        const successRate = ((stats.success / stats.total) * 100).toFixed(1);
                        console.log(`æ’­æ”¾æˆåŠŸç‡ [${senderId.slice(-8)}]: ${successRate}% (${stats.success}/${stats.total})`);
                    }
                }

                // ç­–ç•¥3: ç¼“å†²åˆå¹¶æ’­æ”¾
                if (!playSuccess && buffer.chunks.length >= 2) {
                    const chunksToMerge = buffer.chunks.splice(0, 2);
                    const mergedSize = chunksToMerge.reduce((sum, chunk) => sum + chunk.length, 0);
                    buffer.totalSize -= mergedSize;

                    const mergedAudio = new Uint8Array(mergedSize);
                    let offset = 0;
                    for (const chunk of chunksToMerge) {
                        mergedAudio.set(chunk, offset);
                        offset += chunk.length;
                    }

                    if (await trySmartPlayAudio(mergedAudio)) {
                        console.log(`æ™ºèƒ½æ’­æ”¾æˆåŠŸ [${senderId.slice(-8)}]: ç¼“å†²åˆå¹¶ (${mergedAudio.length} å­—èŠ‚)`);
                        stats.success++;
                        playSuccess = true;
                    }
                }

                // ç­–ç•¥4: å•å—æ’­æ”¾ï¼ˆæœ€åå°è¯•ï¼‰
                if (!playSuccess && buffer.chunks.length > 0) {
                    const singleChunk = buffer.chunks.shift();
                    buffer.totalSize -= singleChunk.length;

                    if (await trySmartPlayAudio(singleChunk)) {
                        console.log(`æ™ºèƒ½æ’­æ”¾æˆåŠŸ [${senderId.slice(-8)}]: å•å—æ’­æ”¾ (${singleChunk.length} å­—èŠ‚)`);
                        stats.success++;
                        playSuccess = true;
                    }
                }

                if (!playSuccess) {
                    console.log(`æ™ºèƒ½æ’­æ”¾å¤±è´¥ [${senderId.slice(-8)}]`);
                }

                // æ˜¾ç¤ºå½“å‰æˆåŠŸç‡
                if (stats.total > 0) {
                    const successRate = ((stats.success / stats.total) * 100).toFixed(1);
                    if (stats.total % 5 === 0) { // æ¯5ä¸ªå—æ˜¾ç¤ºä¸€æ¬¡ç»Ÿè®¡
                        console.log(`ğŸ“Š æ’­æ”¾ç»Ÿè®¡ [${senderId.slice(-8)}]: ${successRate}% æˆåŠŸç‡ (${stats.success}/${stats.total})`);
                    }
                    // æ›´æ–°ç•Œé¢æ˜¾ç¤º
                    updateSmartPlaybackStatus();
                }

                // ç»§ç»­å¤„ç†å‰©ä½™æ•°æ®
                if (buffer.chunks.length > 0) {
                    setTimeout(() => processSmartAudioBuffer(senderId), 50);
                } else {
                    buffer.isProcessing = false;
                }

            } catch (error) {
                console.error('æ™ºèƒ½éŸ³é¢‘å¤„ç†å¤±è´¥:', error);
                buffer.isProcessing = false;
            }
        }

        // æ™ºèƒ½éŸ³é¢‘æ’­æ”¾å°è¯•
        async function trySmartPlayAudio(audioData) {
            // æ–¹æ³•1: ç›´æ¥æ’­æ”¾ (æ›´å¿«ï¼Œä¼˜å…ˆä½¿ç”¨)
            if (await tryDirectPlaySmart(audioData)) {
                return true;
            }

            // æ–¹æ³•2: Web Audio API (å¤‡ç”¨)
            if (await tryWebAudioPlaySmart(audioData)) {
                return true;
            }

            return false;
        }

        // æ™ºèƒ½ç›´æ¥æ’­æ”¾
        async function tryDirectPlaySmart(audioData) {
            try {
                const audioBlob = new Blob([audioData], { type: 'audio/webm;codecs=opus' });
                const audioUrl = URL.createObjectURL(audioBlob);
                const audio = new Audio();

                audio.src = audioUrl;
                audio.volume = 0.7;

                return new Promise((resolve) => {
                    let resolved = false;

                    const cleanup = () => {
                        if (!resolved) {
                            resolved = true;
                            URL.revokeObjectURL(audioUrl);
                        }
                    };

                    audio.oncanplaythrough = () => {
                        audio.play().then(() => {
                            cleanup();
                            resolve(true);
                        }).catch(() => {
                            cleanup();
                            resolve(false);
                        });
                    };

                    audio.onerror = () => {
                        cleanup();
                        resolve(false);
                    };

                    // å¿«é€Ÿè¶…æ—¶ï¼Œæé«˜å“åº”é€Ÿåº¦
                    setTimeout(() => {
                        cleanup();
                        resolve(false);
                    }, 500);
                });

            } catch (error) {
                return false;
            }
        }

        // æ™ºèƒ½Web Audioæ’­æ”¾
        async function tryWebAudioPlaySmart(audioData) {
            try {
                const audioContext = await initPlaybackAudioContext();
                const audioBuffer = await audioContext.decodeAudioData(audioData.buffer.slice());

                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                const gainNode = audioContext.createGain();
                gainNode.gain.value = 0.7;

                source.connect(gainNode);
                gainNode.connect(audioContext.destination);
                source.start(0);

                return true;
            } catch (error) {
                return false;
            }
        }

        // æ›´æ–°æ™ºèƒ½æ’­æ”¾çŠ¶æ€æ˜¾ç¤º
        function updateSmartPlaybackStatus() {
            if (!smartPlaybackStatusEl) return;

            let totalSuccess = 0;
            let totalAttempts = 0;
            let activeUsers = 0;
            let usersWithHeaders = 0;

            // ç»Ÿè®¡æ‰€æœ‰ç”¨æˆ·çš„æ’­æ”¾æƒ…å†µ
            playbackStats.forEach((stats, userId) => {
                if (stats.total > 0) {
                    totalSuccess += stats.success;
                    totalAttempts += stats.total;
                    activeUsers++;

                    if (headerChunks.has(userId)) {
                        usersWithHeaders++;
                    }
                }
            });

            if (totalAttempts > 0) {
                const overallSuccessRate = ((totalSuccess / totalAttempts) * 100).toFixed(1);
                let statusText = `ğŸ§  æ™ºèƒ½æ’­æ”¾: ${overallSuccessRate}% æˆåŠŸç‡`;

                if (activeUsers > 1) {
                    statusText += ` (${activeUsers} ç”¨æˆ·)`;
                }

                if (usersWithHeaders > 0) {
                    statusText += ` | ${usersWithHeaders} å¤´ä¿¡æ¯`;
                }

                smartPlaybackStatusEl.textContent = statusText;
                smartPlaybackStatusEl.style.display = 'block';

                // æ ¹æ®æˆåŠŸç‡è®¾ç½®é¢œè‰²
                if (overallSuccessRate >= 70) {
                    smartPlaybackStatusEl.style.color = '#4ec9b0'; // ç»¿è‰²
                } else if (overallSuccessRate >= 40) {
                    smartPlaybackStatusEl.style.color = '#ffa500'; // æ©™è‰²
                } else {
                    smartPlaybackStatusEl.style.color = '#ff6b6b'; // çº¢è‰²
                }
            } else {
                smartPlaybackStatusEl.style.display = 'none';
            }
        }

        // æ¸…ç†æ™ºèƒ½æ’­æ”¾æ•°æ®
        function clearSmartPlaybackData() {
            headerChunks.clear();
            playbackStats.clear();
            audioStreamBuffer.clear();
            updateSmartPlaybackStatus();
            console.log('ğŸ§  æ™ºèƒ½æ’­æ”¾æ•°æ®å·²æ¸…ç†');
        }

        // æ–¹æ³•1: Web Audio API ç›´æ¥æ’­æ”¾
        async function tryWebAudioDirectPlay(audioData) {
            try {
                const audioContext = await initPlaybackAudioContext();

                // å°è¯•ç›´æ¥è§£ç éŸ³é¢‘æ•°æ®
                const audioBuffer = await audioContext.decodeAudioData(audioData.buffer.slice());

                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;

                const gainNode = audioContext.createGain();
                gainNode.gain.value = 0.8;

                source.connect(gainNode);
                gainNode.connect(audioContext.destination);
                source.start(0);

                return true;
            } catch (error) {
                console.log('Web Audio API ç›´æ¥æ’­æ”¾å¤±è´¥:', error.message);
                return false;
            }
        }

        // æ–¹æ³•2: WebM/Opus æ ¼å¼æ’­æ”¾ - æ”¹è¿›ç‰ˆ
        async function tryWebMOpusPlay(audioData) {
            try {
                const audioBlob = new Blob([audioData], { type: 'audio/webm;codecs=opus' });
                const audioUrl = URL.createObjectURL(audioBlob);
                const audio = new Audio();

                audio.src = audioUrl;
                audio.volume = 0.8;
                audio.preload = 'metadata'; // æ”¹ä¸ºmetadataï¼Œå‡å°‘åŠ è½½æ—¶é—´

                return new Promise((resolve, reject) => {
                    let resolved = false;

                    const cleanup = () => {
                        if (!resolved) {
                            resolved = true;
                            URL.revokeObjectURL(audioUrl);
                            audio.removeEventListener('loadedmetadata', onLoadedMetadata);
                            audio.removeEventListener('canplay', onCanPlay);
                            audio.removeEventListener('error', onError);
                            audio.removeEventListener('ended', onEnded);
                        }
                    };

                    const onLoadedMetadata = () => {
                        // å¦‚æœèƒ½åŠ è½½å…ƒæ•°æ®ï¼Œè¯´æ˜æ ¼å¼æ­£ç¡®
                        audio.play().then(() => {
                            console.log('éŸ³é¢‘å¼€å§‹æ’­æ”¾');
                        }).catch(onError);
                    };

                    const onCanPlay = () => {
                        if (!resolved) {
                            cleanup();
                            resolve(true);
                        }
                    };

                    const onError = (e) => {
                        cleanup();
                        const errorMsg = e.target?.error?.message || e.message || 'Unknown audio error';
                        reject(new Error(errorMsg));
                    };

                    const onEnded = () => {
                        cleanup();
                        resolve(true);
                    };

                    audio.addEventListener('loadedmetadata', onLoadedMetadata);
                    audio.addEventListener('canplay', onCanPlay);
                    audio.addEventListener('error', onError);
                    audio.addEventListener('ended', onEnded);

                    // å‡å°‘è¶…æ—¶æ—¶é—´ï¼Œå¿«é€Ÿå¤±è´¥
                    setTimeout(() => {
                        if (!resolved) {
                            cleanup();
                            reject(new Error('æ’­æ”¾è¶…æ—¶'));
                        }
                    }, 1500);
                });

            } catch (error) {
                console.log('WebM/Opus æ’­æ”¾å¤±è´¥:', error.message);
                return false;
            }
        }

        // æ–¹æ³•3: MediaSource API æµå¼æ’­æ”¾
        async function tryMediaSourcePlay(audioData) {
            try {
                if (!window.MediaSource || !MediaSource.isTypeSupported('audio/webm;codecs=opus')) {
                    return false;
                }

                const mediaSource = new MediaSource();
                const audio = new Audio();
                audio.src = URL.createObjectURL(mediaSource);

                await new Promise((resolve, reject) => {
                    mediaSource.addEventListener('sourceopen', () => {
                        try {
                            const sourceBuffer = mediaSource.addSourceBuffer('audio/webm;codecs=opus');
                            sourceBuffer.appendBuffer(audioData);

                            sourceBuffer.addEventListener('updateend', () => {
                                if (mediaSource.readyState === 'open') {
                                    mediaSource.endOfStream();
                                }
                                resolve();
                            });

                            sourceBuffer.addEventListener('error', reject);
                        } catch (error) {
                            reject(error);
                        }
                    });

                    mediaSource.addEventListener('error', reject);

                    // è¶…æ—¶å¤„ç†
                    setTimeout(() => reject(new Error('MediaSource è¶…æ—¶')), 2000);
                });

                audio.volume = 0.8;
                await audio.play();

                return true;
            } catch (error) {
                console.log('MediaSource æ’­æ”¾å¤±è´¥:', error.message);
                return false;
            }
        }

        // ç®€åŒ–çš„éŸ³é¢‘æ’­æ”¾æ–¹æ³•
        async function playSimpleAudio(audioData) {
            try {
                // ç›´æ¥å°è¯•æ’­æ”¾éŸ³é¢‘ï¼Œä¸è¿›è¡Œå¤æ‚çš„ç¼“å†²
                const audioBlob = new Blob([audioData], { type: 'audio/webm;codecs=opus' });
                const audioUrl = URL.createObjectURL(audioBlob);
                const audio = new Audio();

                audio.src = audioUrl;
                audio.volume = 0.8;
                audio.preload = 'auto';

                // ç®€å•çš„æ’­æ”¾å¤„ç†
                const playPromise = audio.play();

                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        console.log('éŸ³é¢‘æ’­æ”¾æˆåŠŸ');
                    }).catch(error => {
                        console.log('éŸ³é¢‘æ’­æ”¾å¤±è´¥:', error.message);
                        // æ’­æ”¾å¤±è´¥æ—¶æ˜¾ç¤ºæŒ‡ç¤ºå™¨
                        showAudioReceiveIndicator();
                    }).finally(() => {
                        URL.revokeObjectURL(audioUrl);
                    });
                }

                return true;
            } catch (error) {
                console.log('ç®€å•éŸ³é¢‘æ’­æ”¾å¤±è´¥:', error.message);
                return false;
            }
        }





        // æ˜¾ç¤ºéŸ³é¢‘æ¥æ”¶æŒ‡ç¤ºå™¨
        let audioIndicatorTimeout = null;
        let audioIndicatorElement = null;
        let audioPacketCount = 0;

        function showAudioReceiveIndicator() {
            audioPacketCount++;

            // å¦‚æœå·²ç»æœ‰æŒ‡ç¤ºå™¨ï¼Œæ›´æ–°å†…å®¹
            if (audioIndicatorElement) {
                clearTimeout(audioIndicatorTimeout);
                audioIndicatorElement.innerHTML = `
                    <div style="width: 8px; height: 8px; background: #27ae60; border-radius: 50%; animation: pulse 1s infinite;"></div>
                    ğŸ”Š å®æ—¶éŸ³é¢‘ (${audioPacketCount} åŒ…)
                `;
            } else {
                // åˆ›å»ºæ–°çš„æŒ‡ç¤ºå™¨
                audioIndicatorElement = document.createElement('div');
                audioIndicatorElement.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: rgba(39, 174, 96, 0.9);
                    color: white;
                    padding: 8px 15px;
                    border-radius: 15px;
                    font-size: 12px;
                    z-index: 1000;
                    pointer-events: none;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
                    transition: all 0.3s ease;
                `;
                audioIndicatorElement.innerHTML = `
                    <div style="width: 8px; height: 8px; background: #27ae60; border-radius: 50%; animation: pulse 1s infinite;"></div>
                    ğŸ”Š å®æ—¶éŸ³é¢‘ (${audioPacketCount} åŒ…)
                `;
                document.body.appendChild(audioIndicatorElement);
            }

            // è®¾ç½®è‡ªåŠ¨ç§»é™¤è®¡æ—¶å™¨
            audioIndicatorTimeout = setTimeout(() => {
                if (audioIndicatorElement && audioIndicatorElement.parentNode) {
                    audioIndicatorElement.parentNode.removeChild(audioIndicatorElement);
                    audioIndicatorElement = null;
                    audioPacketCount = 0; // é‡ç½®è®¡æ•°
                }
            }, 3000);
        }

        // é™çº§éŸ³é¢‘æ’­æ”¾æ–¹æ³•
        function fallbackAudioPlayback(audioData) {
            console.log('ä½¿ç”¨é™çº§éŸ³é¢‘æ’­æ”¾æ–¹æ³•');

            // å°è¯•ä¸åŒçš„éŸ³é¢‘æ ¼å¼
            const formats = [
                'audio/webm;codecs=opus',
                'audio/webm',
                'audio/ogg;codecs=opus',
                'audio/ogg'
            ];

            let playbackAttempted = false;

            for (const format of formats) {
                if (playbackAttempted) break;

                try {
                    const audioBlob = new Blob([audioData], { type: format });
                    const audioUrl = URL.createObjectURL(audioBlob);
                    const audio = new Audio(audioUrl);

                    audio.volume = 0.8;
                    audio.preload = 'auto';

                    const playPromise = audio.play();

                    if (playPromise !== undefined) {
                        playPromise.then(() => {
                            console.log(`æˆåŠŸä½¿ç”¨æ ¼å¼æ’­æ”¾: ${format}`);
                            playbackAttempted = true;

                            audio.addEventListener('ended', () => {
                                URL.revokeObjectURL(audioUrl);
                            });

                        }).catch((error) => {
                            console.log(`æ ¼å¼ ${format} æ’­æ”¾å¤±è´¥:`, error);
                            URL.revokeObjectURL(audioUrl);
                        });
                    }

                } catch (error) {
                    console.log(`æ ¼å¼ ${format} åˆ›å»ºå¤±è´¥:`, error);
                }
            }

            if (!playbackAttempted) {
                console.warn('æ‰€æœ‰éŸ³é¢‘æ’­æ”¾æ–¹æ³•éƒ½å¤±è´¥äº†');
                showNotification('éŸ³é¢‘æ’­æ”¾å¤±è´¥ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨å…¼å®¹æ€§', 'error');
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', init);

        // æ·»åŠ å¿«æ·é”®æ”¯æŒ (Ctrl+Shift+S æ˜¾ç¤ºæ™ºèƒ½æ’­æ”¾ç»Ÿè®¡)
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === 'S') {
                e.preventDefault();
                showSmartPlaybackStats();
            }
        });

        // æ˜¾ç¤ºè¯¦ç»†çš„æ™ºèƒ½æ’­æ”¾ç»Ÿè®¡
        function showSmartPlaybackStats() {
            console.log('ğŸ“Š æ™ºèƒ½æ’­æ”¾è¯¦ç»†ç»Ÿè®¡:');
            console.log('==================');

            if (playbackStats.size === 0) {
                console.log('æš‚æ— æ’­æ”¾æ•°æ®');
                return;
            }

            let totalSuccess = 0;
            let totalAttempts = 0;

            playbackStats.forEach((stats, userId) => {
                const userName = getUserName(userId) || userId.slice(-8);
                const successRate = stats.total > 0 ? ((stats.success / stats.total) * 100).toFixed(1) : 0;
                const hasHeader = headerChunks.has(userId) ? 'âœ…' : 'âŒ';

                console.log(`ç”¨æˆ· ${userName}:`);
                console.log(`  æˆåŠŸç‡: ${successRate}% (${stats.success}/${stats.total})`);
                console.log(`  å¤´ä¿¡æ¯: ${hasHeader}`);

                totalSuccess += stats.success;
                totalAttempts += stats.total;
            });

            const overallRate = totalAttempts > 0 ? ((totalSuccess / totalAttempts) * 100).toFixed(1) : 0;
            console.log('==================');
            console.log(`æ€»ä½“æˆåŠŸç‡: ${overallRate}% (${totalSuccess}/${totalAttempts})`);
            console.log(`æ´»è·ƒç”¨æˆ·: ${playbackStats.size}`);
            console.log(`å¤´ä¿¡æ¯ç”¨æˆ·: ${headerChunks.size}`);
            console.log('æç¤º: æŒ‰ Ctrl+Shift+S æŸ¥çœ‹æ­¤ç»Ÿè®¡');
        }

        // é¡µé¢å¸è½½æ—¶æ¸…ç†
        window.addEventListener('beforeunload', () => {
            if (fileTransferManager) {
                // å–æ¶ˆæ‰€æœ‰æ´»è·ƒçš„ä¼ è¾“
                activeTransfers.forEach((transfer, transferId) => {
                    if (transfer.status === 'sending' || transfer.status === 'receiving') {
                        fileTransferManager.cancelTransfer(transferId);
                    }
                });
            }
        });
    </script>
</body>

</html>